# Motion Intelligence Grid - Application Source Guide

This document contains the complete source code of the deployed Motion Intelligence Grid application.

**Generated on:** 2025-12-17
**Version:** v1.0 (Enterprise)

---

## Table of Contents
1. [Infrastructure & Deployment](#infrastructure--deployment)
2. [Frontend (React/Vite)](#frontend-reactvite)
3. [API Server (Node/Express)](#api-server-nodeexpress)
4. [Simulation Engine (Python)](#simulation-engine-python)

---

## 1. Root

#### deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting deployment for Motion Intelligence Grid..."

# 1. Build and Push Containers
Write-Host "Building and Pushing Containers..."
gcloud builds submit --config cloudbuild.yaml . --project $ProjectId

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# 2. Apply Terraform
Write-Host "Applying Terraform..."
cd infrastructure
terraform init
terraform apply -var="project_id=$ProjectId" -var="region=$Region" -auto-approve

if ($LASTEXITCODE -ne 0) {
    Write-Error "Terraform failed!"
    exit 1
}

Write-Host "Deployment Complete!"

```

#### cloudbuild.yaml
```yaml
steps:
  # Build API
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-api:latest', './server']
    
  # Build Simulation
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest', './simulation']
    
  # Build Frontend
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest', './frontend']

  # Push Images
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-api:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest']


options:
  machineType: 'N1_HIGHCPU_8'

```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # MongoDB database
  mongodb:
    image: mongo:6
    container_name: motiongrid-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: devpassword123
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - motiongrid-network
    command: --wiredTigerCacheSizeGB 1.5

  # Redis (optional, for caching)
  redis:
    image: redis:7-alpine
    container_name: motiongrid-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - motiongrid-network
    command: redis-server --appendonly yes

  # API Gateway (Node.js + Express + Socket.io)
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-api
    restart: unless-stopped
    environment:
      NODE_ENV: development
      PORT: 3001
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
      REDIS_URL: redis://redis:6379
      JWT_SECRET: dev-secret-key
      SIMULATION_API_URL: http://simulation:8000
    ports:
      - "3001:3001"
    volumes:
      - ./server/src:/app/src
    depends_on:
      - mongodb
      - redis
    networks:
      - motiongrid-network
    command: npm run dev

  # Simulation Engine (Python + FastAPI)
  simulation:
    build:
      context: ./simulation
      dockerfile: Dockerfile
    container_name: motiongrid-simulation
    restart: unless-stopped
    environment:
      PYTHONUNBUFFERED: 1
      API_PORT: 8000
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
    ports:
      - "8000:8000"
    volumes:
      - ./simulation/src:/app/src
    depends_on:
      - mongodb
    networks:
      - motiongrid-network
    command: uvicorn src.api.server:app --host 0.0.0.0 --port 8000 --reload

  # Frontend (React SPA)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_WS_URL: ws://localhost:3001
    ports:
      - "5173:5173"
    volumes:
      - ./frontend/src:/app/src
    networks:
      - motiongrid-network
    command: npm run dev

volumes:
  mongodb_data:
  redis_data:


networks:
  motiongrid-network:
    driver: bridge

```

#### .gcloudignore
```
node_modules/
.git/
.github/
infrastructure/.terraform/
.DS_Store
*.log
coverage/
dist/
tmp/
gcloud_temp/

```

## 2. Infrastructure

#### infrastructure\main.tf
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

resource "google_cloud_run_service" "api" {
  name     = "motiongrid-api"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-api:latest"
        ports {
            container_port = 3001
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "1Gi"
          }
        }
        env {
          name  = "NODE_ENV"
          value = "production"
        }
        env {
            name = "MONGODB_URI"
            value = var.mongodb_uri
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

resource "google_cloud_run_service" "simulation" {
  name     = "motiongrid-simulation"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-simulation:latest"
        ports {
            container_port = 8000
        }
        resources {
          limits = {
            cpu    = "2000m"
            memory = "2Gi"
          }
        }
        env {
            name = "MONGODB_URI"
            value = var.mongodb_uri
        }
      }
    }
  }
}

resource "google_cloud_run_service" "frontend" {
  name     = "motiongrid-frontend"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-frontend:latest"
        ports {
            container_port = 80
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        env {
            name = "VITE_API_URL"
            value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service_iam_member" "public_access_frontend" {
  service  = google_cloud_run_service.frontend.name
  location = google_cloud_run_service.frontend.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_api" {
  service  = google_cloud_run_service.api.name
  location = google_cloud_run_service.api.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_simulation" {
  service  = google_cloud_run_service.simulation.name
  location = google_cloud_run_service.simulation.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "frontend_url" {
  value = google_cloud_run_service.frontend.status[0].url
}

```

#### infrastructure\variables.tf
```hcl
variable "project_id" {
  description = "GCP Project ID"
  type        = string
  default     = "freeforge-481415"
}

variable "region" {
  description = "GCP Region"
  type        = string
  default     = "us-central1"
}

variable "mongodb_uri" {
    description = "MongoDB Connection String"
    type = string
    sensitive = true
    default = "memory"
}

```

## 3. Server

#### server\Dockerfile
```
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

# Stage: Development/Build dependencies
FROM base AS deps
RUN npm install

# Stage: Production dependencies
FROM base AS production-deps
RUN npm install --only=production

# Stage: Development
FROM deps AS development
COPY . .
CMD ["npm", "run", "dev"]



# Stage: Production
FROM deps AS production
ENV NODE_ENV=production
COPY . .
EXPOSE 3001
CMD ["npx", "ts-node", "src/index.ts"]

```

#### server\package.json
```json
{
  "name": "motiongrid-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.2",
    "mongoose": "^8.0.3",
    "redis": "^4.6.11",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "axios": "^1.6.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/express": "^4.17.21",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "typescript": "^5.3.3",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11"
  }
}
```

#### server\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2016",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": false,
        "noImplicitAny": false,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts"
    ]
}
```

#### server\src\database.ts
```typescript
import mongoose from 'mongoose';

export const connectDB = async () => {
    try {
        if (!uri || uri === 'memory') {
            console.warn('⚠️ MONGODB_URI is missing or set to "memory". Database connection skipped. Application will run without persistence.');
            return;
        }

        await mongoose.connect(uri);
        console.log('MongoDB connected successfully');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        // Don't exit process, just log error for robustness in deployment
        console.warn('Continuing without database connection...');
    }
};

```

#### server\src\index.ts
```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import { connectDB } from './database';
import { socketService } from './services/SocketService';
import nodesRouter from './routes/nodes';
import sessionsRouter from './routes/sessions';
import anomaliesRouter from './routes/anomalies';
import entitiesRouter from './routes/entities';
import simulationRouter from './routes/simulation';
import analyticsRouter from './routes/analytics';


dotenv.config();

const app = express();
const httpServer = createServer(app);

// Initialize Socket.io via Service
socketService.initialize(httpServer);

app.use(helmet());
app.use(cors());
app.use(express.json());

app.use('/api/nodes', nodesRouter);
app.use('/api/sessions', sessionsRouter);
app.use('/api/anomalies', anomaliesRouter);
app.use('/api/entities', entitiesRouter);
app.use('/api/simulation', simulationRouter);
app.use('/api/analytics', analyticsRouter);

// Basic health check
app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date() });
});



const PORT = process.env.PORT || 3001;

const startServer = async () => {
    try {
        await connectDB();
        httpServer.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
            console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
        });
    } catch (error) {
        console.error('Failed to start server:', error);
        process.exit(1);
    }
};

startServer();

```

#### server\src\models\Anomaly.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IAnomaly extends Document {
    anomalyId: string;
    sessionId: mongoose.Types.ObjectId;
    entityIds: mongoose.Types.ObjectId[];
    nodeIds: string[];
    occurredAt: Date;
    duration: number;
    type: 'GEOGRAPHICS' | 'KINETICS' | 'PROXEMICS' | 'ATMOSPHERICS';
    subtype: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    scenario?: string;
    headline: string;
    description: string;
    baselineText: string;
    anomalyText: string;
    metrics: {
        baselineDelta: number;
        confidence: number;
        riskScore: number;
    };
    ruleOfThreeHit: boolean;
    relatedAnomalies: mongoose.Types.ObjectId[];
    zone: string;
    location: { x: number; y: number; z: number };
    triage: {
        status: 'UNREVIEWED' | 'CONFIRMED' | 'DOWNGRADED' | 'FALSE_POSITIVE';
        notes?: string;
    };
    tags: string[];
    createdAt: Date;
    updatedAt: Date;
}

const AnomalySchema: Schema = new Schema({
    anomalyId: { type: String, required: true, unique: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    entityIds: [{ type: Schema.Types.ObjectId, ref: 'Entity' }],
    nodeIds: [String],
    occurredAt: { type: Date, default: Date.now },
    duration: { type: Number, default: 0 },
    type: { type: String, enum: ['GEOGRAPHICS', 'KINETICS', 'PROXEMICS', 'ATMOSPHERICS'], required: true },
    subtype: String,
    severity: { type: String, enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'], default: 'LOW' },
    scenario: String,
    headline: String,
    description: String,
    baselineText: String,
    anomalyText: String,
    metrics: {
        baselineDelta: Number,
        confidence: Number,
        riskScore: Number
    },
    ruleOfThreeHit: { type: Boolean, default: false },
    relatedAnomalies: [{ type: Schema.Types.ObjectId, ref: 'Anomaly' }],
    zone: String,
    location: {
        x: Number,
        y: Number,
        z: Number
    },
    triage: {
        status: { type: String, enum: ['UNREVIEWED', 'CONFIRMED', 'DOWNGRADED', 'FALSE_POSITIVE'], default: 'UNREVIEWED' },
        notes: String
    },
    tags: [String]
}, { timestamps: true });

export const Anomaly = mongoose.model<IAnomaly>('Anomaly', AnomalySchema);

```

#### server\src\models\Entity.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IEntity extends Document {
    entityId: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    name?: string;
    lastPosition: { x: number; y: number; z: number };
    lastVelocity: { x: number; y: number; z: number };
    lastSeenAt: Date;
    sessionId?: string;
}

const EntitySchema: Schema = new Schema({
    entityId: { type: String, required: true, unique: true },
    type: { type: String, enum: ['PERSON', 'OBJECT'], required: true },
    role: { type: String, enum: ['PLAYER', 'OFFICIAL', 'SPECTATOR', 'BALL'], default: 'SPECTATOR' },
    team: { type: String, enum: ['HOME', 'AWAY'] },
    name: String,
    lastPosition: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastVelocity: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastSeenAt: { type: Date, default: Date.now },
    sessionId: String
}, { timestamps: true });

export const Entity = mongoose.model<IEntity>('Entity', EntitySchema);

```

#### server\src\models\Node.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INode extends Document {
    nodeId: string;
    name: string;
    type: 'EDGE_NODE';
    status: 'ONLINE' | 'OFFLINE' | 'DEGRADED';
    position: { x: number; y: number; z: number };
    orientation: { pitch: number; yaw: number; roll: number };
    sensors: {
        camera: {
            enabled: boolean;
            resolution: { width: number; height: number };
            fps: number;
            fov: number;
            exposure: number;
            gain: number;
        };
        lidar: {
            enabled: boolean;
            model: string;
            channels: number;
            pointsPerSecond: number;
            range: number;
            accuracy: number;
        };
        imu: {
            enabled: boolean;
            sampleRate: number;
            accelRange: number;
            gyroRange: number;
        };
    };
    calibration: {
        intrinsic: {
            cameraMatrix: number[][];
            distortion: number[];
        };
        extrinsic: {
            rotationMatrix: number[][];
            translationVector: number[];
        };
        lidarToCameraTransform: number[][];
        calibrationQuality: number;
        calibratedAt: Date;
    };
    network: {
        ipAddress: string;
        port: number;
        ptpDomain: number;
        clockOffset: number;
        lastSyncAt: Date;
    };
    sessionId?: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const NodeSchema: Schema = new Schema({
    nodeId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    type: { type: String, default: 'EDGE_NODE' },
    status: { type: String, enum: ['ONLINE', 'OFFLINE', 'DEGRADED'], default: 'OFFLINE' },
    position: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    orientation: {
        pitch: { type: Number, default: 0 },
        yaw: { type: Number, default: 0 },
        roll: { type: Number, default: 0 }
    },
    sensors: {
        camera: {
            enabled: { type: Boolean, default: true },
            resolution: {
                width: { type: Number, default: 1920 },
                height: { type: Number, default: 1080 }
            },
            fps: { type: Number, default: 30 },
            fov: { type: Number, default: 90 },
            exposure: { type: Number, default: 50 },
            gain: { type: Number, default: 0 }
        },
        lidar: {
            enabled: { type: Boolean, default: true },
            model: { type: String, default: 'VLP-16' },
            channels: { type: Number, default: 16 },
            pointsPerSecond: { type: Number, default: 300000 },
            range: { type: Number, default: 100 },
            accuracy: { type: Number, default: 0.03 }
        },
        imu: {
            enabled: { type: Boolean, default: true },
            sampleRate: { type: Number, default: 100 },
            accelRange: { type: Number, default: 16 },
            gyroRange: { type: Number, default: 2000 }
        }
    },
    calibration: {
        intrinsic: {
            cameraMatrix: [[Number]],
            distortion: [Number]
        },
        extrinsic: {
            rotationMatrix: [[Number]],
            translationVector: [Number]
        },
        lidarToCameraTransform: [[Number]],
        calibrationQuality: { type: Number, default: 0 },
        calibratedAt: Date
    },
    network: {
        ipAddress: String,
        port: Number,
        ptpDomain: { type: Number, default: 0 },
        clockOffset: { type: Number, default: 0 },
        lastSyncAt: Date
    },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session' }
}, { timestamps: true });

export const Node = mongoose.model<INode>('Node', NodeSchema);

```

#### server\src\models\SensorFrame.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISensorFrame extends Document {
    frameId: string;
    sessionId: mongoose.Types.ObjectId;
    nodeId: string;
    timestamp: Date;
    frameNumber: number;
    camera?: {
        imagePath: string;
        resolution: { width: number; height: number };
    };
    lidar?: {
        pointCloudPath: string;
        pointCount: number;
    };
    fusion?: {
        detectedEntities: any[];
        processingTime: number;
    };
    createdAt: Date;
}

const SensorFrameSchema: Schema = new Schema({
    frameId: { type: String, required: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    nodeId: { type: String, required: true },
    timestamp: { type: Date, required: true },
    frameNumber: Number,
    camera: {
        imagePath: String,
        resolution: { width: Number, height: Number }
    },
    lidar: {
        pointCloudPath: String,
        pointCount: Number
    },
    fusion: {
        detectedEntities: [],
        processingTime: Number
    }
}, {
    timeseries: {
        timeField: 'timestamp',
        metaField: 'nodeId',
        granularity: 'seconds'
    },
    expireAfterSeconds: 86400 * 7 // 7 days retention
});

export const SensorFrame = mongoose.model<ISensorFrame>('SensorFrame', SensorFrameSchema);

```

#### server\src\models\Session.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISession extends Document {
    sessionId: string;
    name: string;
    sport: 'BASKETBALL' | 'SOCCER' | 'COMBAT' | 'CUSTOM';
    venue: string;
    startedAt: Date;
    endedAt?: Date;
    duration: number;
    status: 'RECORDING' | 'STOPPED' | 'PROCESSING' | 'READY';
    nodeIds: string[];
    stats: {
        totalFrames: number;
        totalEntities: number;
        totalAnomalies: number;
        anomalyBreakdown: {
            critical: number;
            high: number;
            medium: number;
            low: number;
        };
        avgOccupancy: number;
        peakOccupancy: number;
        avgActivityIndex: number;
    };
    scenario: {
        entityCount: number;
        crowdDensity: number;
        anomalyRate: number;
        environmentConfig: {
            lighting: 'BRIGHT' | 'DIM' | 'VARIABLE';
            weather?: 'CLEAR' | 'RAIN' | 'SNOW';
        };
    };
    dataPath: string;
    thumbnailPath?: string;
    createdAt: Date;
    updatedAt: Date;
}

const SessionSchema: Schema = new Schema({
    sessionId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    sport: { type: String, enum: ['BASKETBALL', 'SOCCER', 'COMBAT', 'CUSTOM'], required: true },
    venue: String,
    startedAt: { type: Date, default: Date.now },
    endedAt: Date,
    duration: { type: Number, default: 0 },
    status: { type: String, enum: ['RECORDING', 'STOPPED', 'PROCESSING', 'READY'], default: 'RECORDING' },
    nodeIds: [String],
    stats: {
        totalFrames: { type: Number, default: 0 },
        totalEntities: { type: Number, default: 0 },
        totalAnomalies: { type: Number, default: 0 },
        anomalyBreakdown: {
            critical: { type: Number, default: 0 },
            high: { type: Number, default: 0 },
            medium: { type: Number, default: 0 },
            low: { type: Number, default: 0 }
        },
        avgOccupancy: { type: Number, default: 0 },
        peakOccupancy: { type: Number, default: 0 },
        avgActivityIndex: { type: Number, default: 0 }
    },
    scenario: {
        entityCount: { type: Number, default: 0 },
        crowdDensity: { type: Number, default: 0 },
        anomalyRate: { type: Number, default: 0 },
        environmentConfig: {
            lighting: { type: String, default: 'BRIGHT' },
            weather: String
        }
    },
    dataPath: String,
    thumbnailPath: String
}, { timestamps: true });

export const Session = mongoose.model<ISession>('Session', SessionSchema);

```

#### server\src\models\User.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
    username: string;
    email: string;
    passwordHash: string;
    role: 'OPERATOR' | 'ANALYST' | 'ADMIN';
    permissions: string[];
    preferences: {
        theme: 'DARK' | 'LIGHT';
    };
    createdAt: Date;
    updatedAt: Date;
}

const UserSchema: Schema = new Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['OPERATOR', 'ANALYST', 'ADMIN'], default: 'OPERATOR' },
    permissions: [String],
    preferences: {
        theme: { type: String, default: 'DARK' }
    }
}, { timestamps: true });

export const User = mongoose.model<IUser>('User', UserSchema);

```

#### server\src\routes\analytics.ts
```typescript
import express from 'express';

const router = express.Router();

router.get('/stats', (req, res) => {
    // Return aggregated stats
    res.json({
        totalAnomalies: 42,
        activeEntities: 15,
        systemHealth: 98.6,
        uptimeSeconds: 3600
    });
});

router.get('/performance', (req, res) => {
    // Return system performance metrics (FPS, Latency)
    res.json({
        simulationFps: 29.8,
        networkLatencyMs: 12,
        processingTimeMs: 4
    });
});

export default router;

```

#### server\src\routes\anomalies.ts
```typescript
import express from 'express';
import { Anomaly } from '../models/Anomaly';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, severity, status } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (severity) query.severity = severity;
        if (status) query['triage.status'] = status;

        const anomalies = await Anomaly.find(query).sort({ occurredAt: -1 }).limit(100);
        res.json({ anomalies, count: anomalies.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id/triage', async (req, res) => {
    try {
        const { status, notes } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            {
                'triage.status': status,
                'triage.notes': notes,
                'triage.triageAt': new Date()
            },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\entities.ts
```typescript
import express from 'express';
// In a real scenario, this might query the database or the simulation state
// For now, we'll return mock data or proxy to simulation if needed
const router = express.Router();

router.get('/', (req, res) => {
    // Return list of active entities
    // Could proxy to simulation: SimulationClient.getEntities()
    res.json([
        { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME' },
        { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY' }
    ]);
});

router.get('/:id/track', (req, res) => {
    const { id } = req.params;
    // Return history/track for entity
    res.json({
        entityId: id,
        path: []
    });
});

export default router;

```

#### server\src\routes\nodes.ts
```typescript
import express from 'express';
import { NodeService } from '../services/NodeService';

const router = express.Router();
const nodeService = new NodeService();

router.post('/', async (req, res) => {
    try {
        const node = await nodeService.createNode(req.body);
        res.status(201).json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const nodes = await nodeService.getNodes(req.query);
        res.json({ nodes, count: nodes.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const node = await nodeService.getNode(req.params.id);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
}
});

router.patch('/:id', async (req, res) => {
    try {
        const node = await nodeService.updateNode(req.params.id, req.body);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await nodeService.deleteNode(req.params.id);
        if (!success) return res.status(404).json({ error: 'Node not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\sessions.ts
```typescript
import express from 'express';
import { SessionService } from '../services/SessionService';

const router = express.Router();
const sessionService = new SessionService();

router.post('/', async (req, res) => {
    try {
        const session = await sessionService.createSession(req.body);
        res.status(201).json(session);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const sessions = await sessionService.getSessions(req.query);
        res.json({ sessions, count: sessions.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/start', async (req, res) => {
    try {
        const session = await sessionService.startSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/stop', async (req, res) => {
    try {
        const session = await sessionService.stopSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
}
});

router.patch('/:id', async (req, res) => {
    try {
        const session = await sessionService.updateSession(req.params.id, req.body);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json(session);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await sessionService.deleteSession(req.params.id);
        if (!success) return res.status(404).json({ error: 'Session not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\simulation.ts
```typescript
import express from 'express';
import { SimulationClient } from '../services/simulation_client';

const router = express.Router();

router.post('/start', async (req, res) => {
    const config = req.body;
    const success = await SimulationClient.startSimulation(config);
    if (success) {
        res.json({ message: 'Simulation started' });
    } else {
        res.status(500).json({ error: 'Failed to start simulation' });
    }
});

router.post('/stop', async (req, res) => {
    const success = await SimulationClient.stopSimulation();
    if (success) {
        res.json({ message: 'Simulation stopped' });
    } else {
        res.status(500).json({ error: 'Failed to stop simulation' });
    }
});

router.get('/status', async (req, res) => {
    const isHealthy = await SimulationClient.healthCheck();
    res.json({
        status: isHealthy ? 'running' : 'stopped',
        service: 'python-engine'
    });
});

export default router;

```

#### server\src\services\AnalyticsService.ts
```typescript
import { Session } from '../models/Session';
import { Anomaly } from '../models/Anomaly';

export class AnalyticsService {
    async getSessionStats(sessionId: string) {
        const session = await Session.findOne({ sessionId });
        if (!session) throw new Error('Session not found');

        const anomalyCount = await Anomaly.countDocuments({ sessionId: session._id });
        const criticalAnomalies = await Anomaly.countDocuments({ sessionId: session._id, severity: 'CRITICAL' });

        return {
            ...session.toJSON().stats,
            anomalyCount,
            criticalAnomalies
        };
    }

    async getGlobalStats() {
        const totalSessions = await Session.countDocuments();
        const totalAnomalies = await Anomaly.countDocuments();

        return {
            totalSessions,
            totalAnomalies,
            systemHealth: 'HEALTHY' // Placeholder
        };
    }
}

```

#### server\src\services\NodeService.ts
```typescript
import { Node, INode } from '../models/Node';

export class NodeService {
    async createNode(data: Partial<INode>): Promise<INode> {
        // Validation: Check if nodeId exists
        const existing = await Node.findOne({ nodeId: data.nodeId });
        if (existing) {
            throw new Error('Node ID already exists');
        }

        const node = new Node(data);
        return await node.save();
    }

    async getNodes(filter: any = {}): Promise<INode[]> {
        return await Node.find(filter);
    }

    async getNode(nodeId: string): Promise<INode | null> {
        return await Node.findOne({ nodeId });
    }

    async updateNode(nodeId: string, data: Partial<INode>): Promise<INode | null> {
        return await Node.findOneAndUpdate({ nodeId }, data, { new: true });
    }

    async deleteNode(nodeId: string): Promise<boolean> {
        const result = await Node.deleteOne({ nodeId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\SessionService.ts
```typescript
import { Session, ISession } from '../models/Session';
import mongoose from 'mongoose';

export class SessionService {
    async createSession(data: Partial<ISession>): Promise<ISession> {
        const session = new Session({
            ...data,
            sessionId: `SES_${Date.now()}`
        });
        return await session.save();
    }

    async getSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOne({ sessionId });
    }

    async getSessions(filter: any = {}): Promise<ISession[]> {
        return await Session.find(filter).sort({ createdAt: -1 });
    }

    async startSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'RECORDING',
                startedAt: new Date()
            },
            { new: true }
        );
    }

    async stopSession(sessionId: string): Promise<ISession | null> {
        const session = await Session.findOne({ sessionId });
        if (!session) return null;

        const endedAt = new Date();
        const duration = (endedAt.getTime() - session.startedAt.getTime()) / 1000;

        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'STOPPED',
                endedAt,
                duration
            },
            { new: true }
        );
    }


    async updateSession(sessionId: string, data: Partial<ISession>): Promise<ISession | null> {
        return await Session.findOneAndUpdate({ sessionId }, data, { new: true });
    }

    async deleteSession(sessionId: string): Promise<boolean> {
        const result = await Session.deleteOne({ sessionId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\simulation_client.ts
```typescript
import axios from 'axios';

const SIMULATION_API_URL = process.env.SIMULATION_API_URL || 'http://localhost:8000';

export class SimulationClient {

    static async healthCheck(): Promise<boolean> {
        try {
            const response = await axios.get(`${SIMULATION_API_URL}/health`);
            return response.data.status === 'ok';
        } catch (error) {
            console.error('Simulation API unhealthy:', error.message);
            return false;
        }
    }

    static async startSimulation(config: any): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/start`, config);
            return response.data.status === 'started';
        } catch (error) {
            console.error('Failed to start simulation:', error.message);
            return false;
        }
    }

    static async stopSimulation(): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/stop`);
            return response.data.status === 'stopped';
        } catch (error) {
            console.error('Failed to stop simulation:', error.message);
            return false;
        }
    }
}

```

#### server\src\services\SocketService.ts
```typescript
import { Server, Socket } from 'socket.io';

class SocketService {
    private io: Server | null = null;

    initialize(server: any) {
        this.io = new Server(server, {
            cors: {
                origin: "*", // Configure properly in production
                methods: ["GET", "POST"]
            }
        });

        this.io.on('connection', (socket: Socket) => {
            console.log('Client connected:', socket.id);

            socket.on('disconnect', () => {
                console.log('Client disconnected:', socket.id);
            });

            // Handle subscriptions
            socket.on('subscribe:session', (data) => {
                console.log(`Client ${socket.id} subscribed to session ${data.sessionId}`);
                socket.join(`session:${data.sessionId}`);
            });

            socket.on('subscribe:node', (data) => {
                console.log(`Client ${socket.id} subscribed to node ${data.nodeId}`);
                socket.join(`node:${data.nodeId}`);
            });
        });
    }

    emit(event: string, data: any, room?: string) {
        if (!this.io) {
            console.warn('SocketService not initialized');
            return;
        }

        if (room) {
            this.io.to(room).emit(event, data);
        } else {
            this.io.emit(event, data);
        }
    }
}

export const socketService = new SocketService();

```

#### server\src\__tests__\integration\session-flow.test.ts
```typescript
import request from 'supertest';
// Mocking app import since we might not export it correctly for testing in index.ts
// In a real setup, we'd export `app` from app.ts and import it in index.ts
// For now, pseudo-integration test or need to refactor index.ts
// Refactoring index.ts to export app is best practice.

describe('Session Flow Integration', () => {
    it('placeholder for integration test', async () => {
        expect(true).toBe(true);
    });
});

```

#### server\src\__tests__\services\NodeService.test.ts
```typescript
import { NodeService } from '../../services/NodeService';
import { connectDB } from '../../database';
import mongoose from 'mongoose';
import { Node } from '../../models/Node';

describe('NodeService', () => {
    let nodeService: NodeService;

    // We need to mock mongoose or use an in-memory db for real tests.
    // For this environment, we will assume a connected DB or mock it.
    // Since we are running in a CI/CD or local env without a dedicated test DB setup in this quick script,
    // we'll try to connect to the dev DB or mock.
    // Let's mock the Node model methods for safety if possible, or just write a basic test.

    // Actually, writing a test that hits the real DB might dirty it.
    // Let's use jest mocks.

    beforeEach(() => {
        nodeService = new NodeService();
        jest.clearAllMocks();
    });

    it('should create a node', async () => {
        // Mock Node.findOne to return null (no duplicate)
        Node.findOne = jest.fn().mockResolvedValue(null);
        // Mock Node.prototype.save
        const mockSave = jest.fn().mockResolvedValue({
            nodeId: 'TEST_001',
            name: 'Test Node'
        });
        jest.spyOn(Node.prototype, 'save').mockImplementation(mockSave);

        const result = await nodeService.createNode({
            nodeId: 'TEST_001',
            name: 'Test Node'
        });

        expect(result.nodeId).toBe('TEST_001');
        expect(Node.findOne).toHaveBeenCalledWith({ nodeId: 'TEST_001' });
    });
});

```

## 4. Simulation

#### simulation\Dockerfile
```
FROM python:3.10-slim AS base

WORKDIR /app

# System dependencies removed as we use opencv-headless

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM base AS development
COPY . .
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

FROM base AS production
COPY src ./src
ENV PYTHONUNBUFFERED=1
EXPOSE 8000
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]

```

#### simulation\requirements.txt
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
numpy==1.24.3
scipy==1.11.4
opencv-python-headless==4.8.1.78
open3d==0.17.0
pymongo==4.6.0
motor==3.3.2
python-dateutil==2.8.2
pytz==2023.3

```

#### simulation\src\anomalies\detector.py
```python
from typing import List

class AnomalyDetector:
    def detect(self, entities: List[dict]) -> List[dict]:
        anomalies = []
        
        # 1. Check Crowd Compression
        # Radius check -> if many entities in small area
        
        # 2. Check Speed
        for e in entities:
             if abs(e.get('velocity', {}).get('x', 0)) > 10: # >10m/s
                 anomalies.append({
                     'id': f"SPEED_{e['id']}",
                     'type': 'KINETICS',
                     'headline': f"High Speed Detected: {e['id']}",
                     'severity': 'MEDIUM'
                 })
                 
        return anomalies

```

#### simulation\src\anomalies\generator.py
```python
import numpy as np
from typing import List, Dict, Optional
import uuid
from datetime import datetime

class AnomalyGenerator:
    """
    Generates realistic anomalies based on entity behavior and scenario context.
    """
    
    def __init__(self):
        self.baselines = {}  # Zone -> baseline metrics
        self.anomaly_rate = 2.0  # anomalies per minute (configurable)
        self.last_anomaly_time = 0
        self.min_anomaly_interval = 5.0  # seconds between anomalies
        
    def detect(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """
        Check for anomalies based on entity behavior.
        Returns list of anomaly dicts.
        """
        anomalies = []
        
        # Update baselines
        self._update_baselines(entities, scenario)
        
        # 1. Crowd Compression (Geographics + Proxemics)
        for zone in scenario.zones:
            compression = self._check_crowd_compression(entities, zone, timestamp)
            if compression:
                anomalies.append(compression)
        
        # 2. Speed Violations (Kinetics)
        speed_anomalies = self._check_speed_anomalies(entities, timestamp)
        anomalies.extend(speed_anomalies)
        
        # 3. Loitering (Atmospherics)
        loitering = self._check_loitering(entities, timestamp)
        anomalies.extend(loitering)
        
        # 4. Restricted Zone Entry (Geographics)
        trespass = self._check_restricted_zones(entities, scenario, timestamp)
        anomalies.extend(trespass)
        
        # Apply Rule of Three
        anomalies = self._apply_rule_of_three(anomalies, timestamp)
        
        return anomalies
    
    def _check_crowd_compression(self, entities: List[Dict], zone, timestamp: float) -> Optional[Dict]:
        """Detect crowd compression/crush risk."""
        # Filter entities in this zone
        entities_in_zone = [
            e for e in entities 
            if self._entity_in_zone(e, zone)
        ]
        
        if not entities_in_zone:
            return None
        
        # Calculate density
        area = zone.area
        density = len(entities_in_zone) / area
        
        # Get baseline
        baseline_key = f"{zone.name}_density"
        baseline_density = self.baselines.get(baseline_key, 0.5)
        
        # Threshold: 2.5× baseline or >4 people/m² (crowd crush risk)
        threshold = max(baseline_density * 2.5, 4.0)
        
        if density > threshold:
            severity = 'CRITICAL' if density > 6.0 else 'HIGH'
            
            return {
                'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                'type': 'GEOGRAPHICS',
                'subtype': 'CROWD_COMPRESSION',
                'severity': severity,
                'scenario': 'CRUSH',
                'headline': f'{zone.name} Crowd Compression Risk',
                'description': f'Density {density:.1f} people/m², {density/baseline_density:.1f}× baseline',
                'baselineText': f'Normal density: {baseline_density:.1f} people/m²',
                'anomalyText': f'Current density: {density:.1f} people/m² ({len(entities_in_zone)} in {area:.0f}m²)',
                'zone': zone.name,
                'location': zone.center if hasattr(zone, 'center') else {'x': 0, 'y': 0, 'z': 0},
                'entityIds': [e['id'] for e in entities_in_zone],
                'metrics': {
                    'baselineDelta': ((density / baseline_density) - 1) * 100,
                    'confidence': 0.95,
                    'riskScore': min(density * 15, 100)
                },
                'occurredAt': datetime.fromtimestamp(timestamp),
                'ruleOfThreeHit': False
            }
        
        return None
    
    def _check_speed_anomalies(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect excessive speed violations."""
        anomalies = []
        
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            vel = entity.get('velocity', {'x': 0, 'y': 0, 'z': 0})
            speed = np.sqrt(vel['x']**2 + vel['y']**2)  # Horizontal speed
            
            # Thresholds based on role
            role = entity.get('role', 'SPECTATOR')
            if role == 'PLAYER':
                max_speed = 10.0  # m/s (fast sprinting)
            elif role == 'OFFICIAL':
                max_speed = 5.0   # m/s
            else:
                max_speed = 2.0   # m/s (walking speed for spectators)
            
            if speed > max_speed * 1.5:  # 1.5× threshold
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'KINETICS',
                    'subtype': 'SPEED_VIOLATION',
                    'severity': 'MEDIUM',
                    'headline': f'Excessive Speed: {entity["id"]}',
                    'description': f'Entity moving at {speed:.1f} m/s, {(speed/max_speed):.1f}× expected',
                    'baselineText': f'Expected max speed: {max_speed:.1f} m/s for {role}',
                    'anomalyText': f'Current speed: {speed:.1f} m/s',
                    'zone': 'UNKNOWN',  # TODO: Determine zone from position
                    'location': entity['position'],
                    'entityIds': [entity['id']],
                    'metrics': {
                        'baselineDelta': ((speed / max_speed) - 1) * 100,
                        'confidence': 0.88,
                        'riskScore': min(speed * 8, 100)
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp),
                    'ruleOfThreeHit': False
                })
        
        return anomalies
    
    def _check_loitering(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect loitering patterns (entities moving very slowly in same area)."""
        # TODO: Implement with entity history tracking
        return []
    
    def _check_restricted_zones(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """Detect entities entering restricted zones."""
        anomalies = []
        
        restricted_zones = [z for z in scenario.zones if z.type == 'RESTRICTED']
        
        for zone in restricted_zones:
            for entity in entities:
                if entity.get('role') == 'PLAYER':
                    continue  # Players allowed in restricted zones
                    
                if self._entity_in_zone(entity, zone):
                    anomalies.append({
                        'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                        'type': 'GEOGRAPHICS',
                        'subtype': 'RESTRICTED_ZONE_ENTRY',
                        'severity': 'HIGH',
                        'headline': f'Unauthorized Entry: {zone.name}',
                        'description': f'{entity["id"]} entered restricted zone',
                        'baselineText': f'Zone {zone.name} is restricted',
                        'anomalyText': f'{entity["role"]} entity detected in zone',
                        'zone': zone.name,
                        'location': entity['position'],
                        'entityIds': [entity['id']],
                        'metrics': {
                            'baselineDelta': 100,
                            'confidence': 0.92,
                            'riskScore': 75
                        },
                        'occurredAt': datetime.fromtimestamp(timestamp),
                        'ruleOfThreeHit': False
                    })
        
        return anomalies
    
    def _apply_rule_of_three(self, anomalies: List[Dict], timestamp: float) -> List[Dict]:
        """
        Apply Rule of Three: flag when 3+ independent anomaly types
        converge in same space-time.
        """
        # Group anomalies by proximity
        spatial_threshold = 10.0  # meters
        temporal_threshold = 30.0  # seconds
        
        groups = []
        for anomaly in anomalies:
            placed = False
            for group in groups:
                # Check if anomaly belongs to this group
                representative = group[0]
                
                # Spatial proximity
                loc1 = anomaly['location']
                loc2 = representative['location']
                dist = np.sqrt(
                    (loc1['x'] - loc2['x'])**2 + 
                    (loc1['y'] - loc2['y'])**2
                )
                
                # Temporal proximity
                time_diff = abs(
                    anomaly['occurredAt'].timestamp() - 
                    representative['occurredAt'].timestamp()
                )
                
                if dist < spatial_threshold and time_diff < temporal_threshold:
                    group.append(anomaly)
                    placed = True
                    break
            
            if not placed:
                groups.append([anomaly])
        
        # Check each group for Rule of Three
        for group in groups:
            distinct_types = set(a['type'] for a in group)
            
            if len(distinct_types) >= 3:
                # Mark all anomalies in group
                for anomaly in group:
                    anomaly['ruleOfThreeHit'] = True
                    anomaly['severity'] = 'CRITICAL'  # Escalate
                    anomaly['relatedAnomalies'] = [
                        a['anomalyId'] for a in group if a != anomaly
                    ]
        
        return anomalies
    
    def _update_baselines(self, entities: List[Dict], scenario):
        """Update baseline metrics using exponential moving average."""
        # TODO: Implement proper baseline learning
        # For now, use static baselines
        for zone in scenario.zones:
            baseline_key = f"{zone.name}_density"
            if baseline_key not in self.baselines:
                self.baselines[baseline_key] = 1.0  # 1 person/m² default
    
    def _entity_in_zone(self, entity: Dict, zone) -> bool:
        """Check if entity is inside zone bounds."""
        pos = entity['position']
        bounds = zone.bounds  # (x_min, y_min, x_max, y_max)
        
        return (
            bounds[0] <= pos['x'] <= bounds[2] and
            bounds[1] <= pos['y'] <= bounds[3]
        )

```

#### simulation\src\api\server.py
```python
from fastapi import FastAPI
from contextlib import asynccontextmanager
import os
import uvicorn

from .core.orchestrator import SimulationOrchestrator

orchestrator = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global orchestrator
    # Initialize with default config
    orchestrator = SimulationOrchestrator({})
    print("Simulation Engine Starting...")
    yield
    # Shutdown
    if orchestrator:
        orchestrator.stop()
    print("Simulation Engine Stopping...")

app = FastAPI(lifespan=lifespan)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "simulation-engine"}

@app.post("/simulation/start")
async def start_simulation(config: dict):
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.load_scenario(config.get('sport', 'BASKETBALL'), config)
    orchestrator.start()
    return {"status": "started"}

@app.post("/simulation/stop")
async def stop_simulation():
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.stop()
    return {"status": "stopped"}

@app.get("/")
async def root():
    return {"message": "Motion Intelligence Simulation Engine v1.0"}

if __name__ == "__main__":
    uvicorn.run("src.api.server:app", host="0.0.0.0", port=8000, reload=True)

```

#### simulation\src\calibration\utils.py
```python
import numpy as np

def generate_default_calibration():
    # Intrinsic (Camera)
    # 1920x1080, FOV ~90 deg
    fx = 1000
    fy = 1000
    cx = 960
    cy = 540
    camera_matrix = [
        [fx, 0, cx],
        [0, fy, cy],
        [0, 0, 1]
    ]
    
    # Extrinsic (Identity for now)
    rotation = np.eye(3).tolist()
    translation = [0, 0, 0]
    
    # Lidar to Camera (Example: Camera is 10cm above LIDAR)
    lidar_to_camera = np.eye(4)
    lidar_to_camera[1, 3] = -0.1 # y-axis translation
    
    return {
        'intrinsic': {
            'cameraMatrix': camera_matrix,
            'distortion': [0, 0, 0, 0, 0]
        },
        'extrinsic': {
            'rotationMatrix': rotation,
            'translationVector': translation
        },
        'lidarToCameraTransform': lidar_to_camera.tolist(),
        'calibrationQuality': 100,
        'calibratedAt': '2025-12-16T12:00:00Z'
    }

```

#### simulation\src\core\orchestrator.py
```python
import time
import threading
from typing import List, Optional, Dict
import numpy as np

from .physics_engine import PhysicsEngine
from .scenario_manager import ScenarioManager
from ..nodes.edge_node import EdgeNode
from ..anomalies.generator import AnomalyGenerator
from ..utils.ptp_sync import PTPClock

class SimulationOrchestrator:
    def __init__(self, config: dict):
        self.config = config
        self.running = False
        self.paused = False
        self.thread = None
        
        # Core components
        self.physics_engine = PhysicsEngine()
        self.scenario = None
        self.anomaly_generator = AnomalyGenerator()
        self.clock = PTPClock(is_master=True)
        
        # State
        self.nodes: List[EdgeNode] = []
        self.entities: List[Dict] = []
        self.current_time = 0.0
        self.frame_count = 0
        self.target_fps = 30
        self.actual_fps = 0.0
        
    def load_scenario(self, sport: str, config: dict):
        """Load sport-specific scenario."""
        self.scenario = ScenarioManager.create_scenario(sport, config)
        self.scenario.initialize(self.entities)
        print(f"Loaded scenario: {sport} with {len(self.entities)} entities")
        
    def add_node(self, node_config: dict) -> EdgeNode:
        """Add a sensor node to the simulation."""
        node = EdgeNode(
            node_id=node_config['nodeId'],
            position=np.array([
                node_config['position']['x'],
                node_config['position']['y'],
                node_config['position']['z']
            ]),
            orientation=np.array([
                node_config['orientation']['pitch'],
                node_config['orientation']['yaw'],
                node_config['orientation']['roll']
            ]),
            sensors=node_config['sensors'],
            calibration=node_config.get('calibration', {})
        )
        self.nodes.append(node)
        print(f"Added node: {node_config['nodeId']}")
        return node
        
    def start(self):
        """Start the simulation loop."""
        if self.running:
            return
            
        if not self.scenario:
            # Fallback for empty start
            try:
                self.load_scenario('BASKETBALL', {})
            except:
                print("Failed to load default scenario")
            
        self.running = True
        self.paused = False
        self.thread = threading.Thread(target=self._loop, daemon=True)
        self.thread.start()
        print("Simulation started")
        
    def stop(self):
        """Stop the simulation."""
        self.running = False
        if self.thread:
            self.thread.join()
        print("Simulation stopped")
        
    def pause(self):
        """Pause the simulation."""
        self.paused = True
        
    def resume(self):
        """Resume the simulation."""
        self.paused = False
        
    def _loop(self):
        """Main simulation loop - runs at 30 FPS."""
        target_dt = 1.0 / self.target_fps
        last_fps_check = time.time()
        fps_frame_count = 0
        
        while self.running:
            if self.paused:
                time.sleep(0.1)
                continue
                
            loop_start = time.time()
            
            # 1. Update simulation time (PTP clock)
            self.current_time = self.clock.get_time() / 1e9  # Convert ns to seconds
            
            # 2. Update entity behaviors (scenario-specific)
            if self.scenario:
                self.scenario.update(self.entities, target_dt)
            
            # 3. Update physics (entity movement)
            self.physics_engine.step(self.entities, target_dt)
            
            # 4. Generate sensor data from all nodes
            # For this MVP, we just generate generating logs or frames
            # Logic to publish via WebSocket would go here
            """
            for node in self.nodes:
                frame = node.generate_frame(
                    entities=self.entities,
                    timestamp=self.current_time
                )
                self._publish_frame(frame)
            """
            
            # 5. Detect anomalies
            if self.scenario:
                anomalies = self.anomaly_generator.detect(
                    entities=self.entities,
                    scenario=self.scenario,
                    timestamp=self.current_time
                )
                for anomaly in anomalies:
                    self._publish_anomaly(anomaly)
            
            # 6. Update frame counter
            self.frame_count += 1
            fps_frame_count += 1
            
            # 7. Calculate actual FPS every second
            now = time.time()
            if now - last_fps_check >= 1.0:
                self.actual_fps = fps_frame_count / (now - last_fps_check)
                fps_frame_count = 0
                last_fps_check = now
                # print(f"Simulation FPS: {self.actual_fps:.1f} | Entities: {len(self.entities)}")
            
            # 8. Sleep to maintain frame rate
            elapsed = time.time() - loop_start
            if elapsed < target_dt:
                time.sleep(target_dt - elapsed)
                
    def _publish_frame(self, frame):
        """Publish sensor frame (to be implemented with message queue or API callback)."""
        pass
        
    def _publish_anomaly(self, anomaly):
        """Publish detected anomaly."""
        pass


```

#### simulation\src\core\physics_engine.py
```python
import numpy as np
from typing import List

class PhysicsEngine:
    def __init__(self):
        self.gravity = -9.81
        self.friction_coeff = 0.5

    def step(self, entities: List[dict], dt: float):
        """
        Update entity positions based on velocity and forces.
        """
        for entity in entities:
            # Simple Euler integration
            vel = np.array(entity.get('velocity', [0, 0, 0]), dtype=float)
            pos = np.array(entity.get('position', [0, 0, 0]), dtype=float)
            
            # Apply friction (damping)
            vel = vel * (1.0 - self.friction_coeff * dt)
            
            # Update position
            pos += vel * dt
            
            # Floor constraint (z >= 0)
            if pos[2] < 0:
                pos[2] = 0
                vel[2] = 0
            
            # Update entity state
            entity['position'] = {
                'x': float(pos[0]),
                'y': float(pos[1]),
                'z': float(pos[2])
            }
            entity['velocity'] = {
                'x': float(vel[0]),
                'y': float(vel[1]),
                'z': float(vel[2])
            }

```

#### simulation\src\core\scenario_manager.py
```python
from typing import List, Dict, Optional
import numpy as np

class Zone:
    def __init__(self, name: str, bounds: tuple, area: float, type: str):
        self.name = name
        self.bounds = bounds # (x_min, y_min, x_max, y_max)
        self.area = area
        self.type = type
        self.center = {
            'x': (bounds[0] + bounds[2]) / 2,
            'y': (bounds[1] + bounds[3]) / 2,
            'z': 0
        }

class Scenario:
    def __init__(self):
        self.zones: List[Zone] = []
        self.entities: List[dict] = []
        self.sport = 'UNKNOWN'

    def initialize(self, entities: List[dict]):
        """Populate initial entities"""
        pass

    def update(self, entities: List[dict], dt: float):
        """Update entity behaviors"""
        pass

class ScenarioManager:
    @staticmethod
    def create_scenario(sport: str, config: dict) -> Scenario:
        if sport == 'BASKETBALL':
            from ..sports.basketball import BasketballScenario
            return BasketballScenario(config)
        else:
            raise ValueError(f"Unknown sport: {sport}")

```

#### simulation\src\nodes\camera_simulator.py
```python
import numpy as np
import cv2
import time
from typing import List, Tuple

class CameraSimulator:
    def __init__(self, resolution: dict, fps: int, fov: float):
        self.width = resolution['width']
        self.height = resolution['height']
        self.fps = fps
        self.fov = fov
        self.last_frame_time = 0
        self.frame_interval = 1.0 / fps

    def render(self, entities: List[dict], timestamp: float) -> Optional[bytes]:
        """
        Render a frame if enough time has passed.
        Returns JPEG bytes or None.
        """
        # Simple frame rate control
        if timestamp - self.last_frame_time < self.frame_interval:
            return None
            
        self.last_frame_time = timestamp
        
        # Create blank image (dark gray background)
        image = np.full((self.height, self.width, 3), 30, dtype=np.uint8)
        
        # Draw entities (simplified 2D projection for now)
        for entity in entities:
             # Basic projection logic (placeholder)
             # In a real 3D sim, we'd use a projection matrix
             pos = entity.get('position', {'x':0, 'y':0, 'z':0})
             
             # Map x/y to screen coordinates (very rough approx)
             cx = int(self.width / 2 + pos['x'] * 50) 
             cy = int(self.height / 2 + pos['y'] * 50)
             
             if 0 <= cx < self.width and 0 <= cy < self.height:
                 cv2.circle(image, (cx, cy), 10, (0, 255, 0), -1)
                 cv2.putText(image, entity.get('id', '?'), (cx+15, cy), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        # Add noise
        noise = np.random.normal(0, 5, image.shape).astype(np.uint8)
        image = cv2.add(image, noise)
        
        # Encode to JPEG
        _, encoded = cv2.imencode('.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 80])
        return encoded.tobytes()

```

#### simulation\src\nodes\edge_node.py
```python
from typing import List, Dict, Any
import numpy as np
from .camera_simulator import CameraSimulator
from .lidar_simulator import LidarSimulator
from .imu_simulator import ImuSimulator

class EdgeNode:
    def __init__(self, node_id: str, position: np.ndarray, orientation: np.ndarray, sensors: dict, calibration: dict):
        self.node_id = node_id
        self.position = position
        self.orientation = orientation
        self.calibration = calibration
        
        # Initialize Sensors
        self.camera = None
        if sensors.get('camera', {}).get('enabled'):
            cam_config = sensors['camera']
            self.camera = CameraSimulator(
                resolution=cam_config.get('resolution', {'width': 1920, 'height': 1080}),
                fps=cam_config.get('fps', 30),
                fov=cam_config.get('fov', 90)
            )
            
        self.lidar = None
        if sensors.get('lidar', {}).get('enabled'):
            lid_config = sensors['lidar']
            self.lidar = LidarSimulator(
                model=lid_config.get('model', 'VLP-16'),
                channels=lid_config.get('channels', 16),
                range_m=lid_config.get('range', 100)
            )
            
        self.imu = None
        if sensors.get('imu', {}).get('enabled'):
            self.imu = ImuSimulator(
                sample_rate=sensors['imu'].get('sampleRate', 100)
            )

    def generate_frame(self, entities: List[dict], timestamp: float) -> Dict[str, Any]:
        """Generate a synchronized frame from all enabled sensors."""
        frame = {
            'nodeId': self.node_id,
            'timestamp': timestamp,
            'sensors': {}
        }
        
        # Transform entities to node-local coordinates if needed
        # For now, simulators handle global entities
        
        if self.camera:
            image_data = self.camera.render(entities, timestamp)
            if image_data:
                frame['sensors']['camera'] = image_data # In real app, this would be a path or heavy blob
        
        if self.lidar:
            point_cloud = self.lidar.scan(entities, timestamp)
            frame['sensors']['lidar'] = point_cloud # Numpy array
            
        if self.imu:
            imu_data = self.imu.read(timestamp, self.position) # Simplified IMU read
            frame['sensors']['imu'] = imu_data
            
        return frame

```

#### simulation\src\nodes\fusion_engine.py
```python
import numpy as np
from typing import List, Dict, Tuple

class FusionEngine:
    """
    Sensor data fusion engine.
    Merges 2D detections from Cameras with 3D point clouds from LIDAR.
    Performs object tracking and ID association.
    """
    
    def __init__(self):
        self.tracks = {}  # ID -> track history
        self.kalman_filters = {}  # ID -> filter state (placeholder)
        
    def fuse(self, camera_data: List[Dict], lidar_data: List[np.ndarray], timestamp: float) -> List[Dict]:
        """
        Fuse multi-modal sensor data into a unified object list.
        """
        fused_objects = []
        
        # 1. Process LIDAR clusters (Primary source for implementation)
        # In a real system, we'd cluster the point cloud.
        # Here we assume lidar_data contains raw points or pre-clustered centroids.
        # For this simulation, we'll assume we receive simulated "detections" that need merging.
        
        # If we just have raw list of detections from EdgeNodes:
        all_detections = []
        for cam_frame in camera_data:
            # cam_frame has 'type': 'CAMERA', 'detections': [...]
            pass
            
        # Simplified logic:
        # The Orchestrator currently passes specific entities. 
        # In a real fusion engine, we would:
        # 1. Project 3D LIDAR points to Camera 2D plane.
        # 2. Compute IoU between Projected LIDAR and Camera Bounding Box.
        # 3. If match -> Create Fused Object with 3D Pos + Visual Class.
        
        # Since we are simulating, we will implement a "passthrough with noise reduction"
        # to simulate the benefit of fusion.
        
        return fused_objects

    def associate_tracks(self, detections: List[Dict], timestamp: float):
        """
        Associate new detections with existing tracks (Hungarian Algorithm).
        """
        pass
        
    def update_state(self, track_id: str, measurement: np.ndarray, dt: float):
        """
        Update Kalman Filter state.
        """
        pass

```

#### simulation\src\nodes\imu_simulator.py
```python
import numpy as np

class IMUSimulator:
    def __init__(self, sample_rate: int):
        self.sample_rate = sample_rate
        self.accel_bias = np.random.normal(0, 0.01, 3)
        self.gyro_bias = np.random.normal(0, 0.001, 3)

    def sample(self, timestamp: float, motion: dict) -> dict:
        """
        Generate IMU reading based on actual motion.
        """
        true_accel = motion.get('acceleration', np.zeros(3))
        true_gyro = motion.get('angular_velocity', np.zeros(3))
        
        # Add noise and bias
        accel_noise = np.random.normal(0, 0.01, 3)
        gyro_noise = np.random.normal(0, 0.001, 3)
        
        accel = true_accel + self.accel_bias + accel_noise
        gyro = true_gyro + self.gyro_bias + gyro_noise
        
        # Add gravity (assuming z is up)
        accel[2] += 9.81
        
        return {
            'acceleration': accel.tolist(),
            'gyroscope': gyro.tolist(),
            'temperature': 45.0 + np.random.normal(0, 0.1)
        }

```

#### simulation\src\nodes\lidar_simulator.py
```python
import numpy as np
from typing import List, Tuple

class LidarSimulator:
    def __init__(self, model: str, channels: int, range_m: float):
        self.model = model
        self.channels = channels
        self.range = range_m
        self.points_per_second = 300000

    def scan(self, entities: List[dict], timestamp: float) -> np.ndarray:
        """
        Generate a point cloud.
        Returns numpy array of (x, y, z, intensity).
        """
        # Generate background points (ground plane)
        # Simplified: Grid of points
        x = np.linspace(-20, 20, 100)
        y = np.linspace(-20, 20, 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X) # Ground is at z=0
        
        # Flatten
        ground_points = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1)
        
        entity_points = []
        for entity in entities:
            pos = entity.get('position', {'x':0, 'y':0, 'z':0})
            # Generate a cluster of points for the entity
            num_points = 50
            # Gaussian distribution around entity position
            ep = np.random.normal([pos['x'], pos['y'], pos['z']], 0.2, (num_points, 3))
            entity_points.append(ep)
            
        if entity_points:
            all_entity_points = np.vstack(entity_points)
            points = np.vstack([ground_points, all_entity_points])
        else:
            points = ground_points

        # Add intensity (random for now)
        intensities = np.random.rand(len(points), 1)
        
        return np.hstack([points, intensities]).astype(np.float32)

```

#### simulation\src\sports\basketball.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class BasketballScenario(Scenario):
    """NBA-style basketball simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'BASKETBALL'
        
        # Court dimensions (NBA standard in meters)
        self.court_length = 28.65
        self.court_width = 15.24
        
        # Zones
        self.zones = [
            Zone(
                name='COURT',
                bounds=self._court_bounds(),
                area=self.court_length * self.court_width,
                type='FIELD'
            ),
            Zone(
                name='HOME_BENCH',
                bounds=(0, 0, 5, 2),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='AWAY_BENCH',
                bounds=(0, self.court_width - 2, 5, self.court_width),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='PAINT_HOME',
                bounds=(0, self.court_width/2 - 2.44, 5.8, self.court_width/2 + 2.44),
                area=28.3,
                type='RESTRICTED'
            )
        ]
        
        self.crowd_count = config.get('crowdCount', 5000) if config else 5000
        
    def initialize(self, entities: List[Dict]):
        """Set up players, refs, ball, crowd."""
        
        # Home team (5 players)
        for i in range(5):
            pos = self._get_formation_position('HOME', i)
            entity = {
                'id': f'HOME_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'HOME',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (255, 0, 0),  # Red
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Away team (5 players)
        for i in range(5):
            pos = self._get_formation_position('AWAY', i)
            entity = {
                'id': f'AWAY_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'AWAY',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (0, 0, 255),  # Blue
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Referees (3)
        for i in range(3):
            entity = {
                'id': f'REF_{i+1}',
                'type': 'PERSON',
                'role': 'OFFICIAL',
                'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 1.8,
                'color': (128, 128, 128),  # Gray
                'reflectance': 0.4,
                'behavior': 'referee'
            }
            entities.append(entity)
        
        # Basketball
        entity = {
            'id': 'BALL',
            'type': 'OBJECT',
            'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 1.5},
            'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
            'radius': 0.12,
            'color': (255, 165, 0),  # Orange
            'reflectance': 0.6
        }
        entities.append(entity)
        
        # Crowd (simplified - grouped entities)
        self._generate_crowd(entities, self.crowd_count)
        
        print(f"Basketball scenario initialized: {len(entities)} entities")
        
    def update(self, entities: List[Dict], dt: float):
        """Update entity behaviors each frame."""
        for entity in entities:
            behavior = entity.get('behavior')
            
            if behavior == 'basketball_player':
                self._update_player_behavior(entity, entities, dt)
            elif behavior == 'referee':
                self._update_referee_behavior(entity, entities, dt)
        
        # Update ball physics (bouncing, possession)
        self._update_ball(entities, dt)
        
    def _get_formation_position(self, team: str, index: int) -> tuple:
        """Get initial position for player in formation."""
        # Simple positioning - half court
        if team == 'HOME':
            x_base = self.court_length * 0.25
        else:
            x_base = self.court_length * 0.75
            
        # Spread players across court width
        y = (self.court_width / 6) * (index + 1)
        
        return (x_base, y)
        
    def _update_player_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Basic basketball player AI."""
        # Find ball
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Move towards ball (simplified)
        dx = ball['position']['x'] - entity['position']['x']
        dy = ball['position']['y'] - entity['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 0.5:  # Not at ball
            # Move towards ball
            speed = 3.0  # m/s
            entity['velocity']['x'] = (dx / dist) * speed
            entity['velocity']['y'] = (dy / dist) * speed
        else:
            # At ball - slow down
            entity['velocity']['x'] *= 0.5
            entity['velocity']['y'] *= 0.5
            
    def _update_referee_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Referee follows play."""
        # Similar to player but slower
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if ball:
            dx = ball['position']['x'] - entity['position']['x']
            dy = ball['position']['y'] - entity['position']['y']
            dist = np.sqrt(dx**2 + dy**2)
            
            if dist > 3.0:
                speed = 2.0
                entity['velocity']['x'] = (dx / dist) * speed
                entity['velocity']['y'] = (dy / dist) * speed
                
    def _update_ball(self, entities: List[Dict], dt: float):
        """Update ball physics."""
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Gravity
        ball['velocity']['z'] -= 9.81 * dt
        
        # Bounce on floor
        if ball['position']['z'] <= 0.12:  # Ball radius
            ball['position']['z'] = 0.12
            ball['velocity']['z'] = -ball['velocity']['z'] * 0.7  # Bounce with loss
            
    def _court_bounds(self) -> tuple:
        """Return (x_min, y_min, x_max, y_max)."""
        return (0, 0, self.court_length, self.court_width)
        
    def _generate_crowd(self, entities: List[Dict], count: int):
        """Generate crowd entities (simplified grouping)."""
        # Stands are outside court boundaries
        # Create grouped "crowd sections" rather than individual spectators
        num_sections = 8
        people_per_section = count // num_sections
        
        for i in range(num_sections):
            entity = {
                'id': f'CROWD_SECTION_{i+1}',
                'type': 'GROUP',
                'role': 'SPECTATOR',
                'count': people_per_section,
                'position': {
                    'x': np.random.uniform(-5, self.court_length + 5),
                    'y': np.random.uniform(-5, self.court_width + 5),
                    'z': 0.0
                },
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 2.0,  # Group radius
                'color': (100, 100, 200),
                'reflectance': 0.3
            }
            entities.append(entity)

```

#### simulation\src\sports\combat.py
```python
from ..core.scenario_manager import Scenario
import numpy as np

class CombatScenario(Scenario):
    def initialize(self, entities: List[dict]):
        # Octagon: ~9m diameter
        
        # 2 Fighters
        fighters = [
            {'id': 'FIGHTER_RED', 'color': '#ff0000', 'x': -2},
            {'id': 'FIGHTER_BLUE', 'color': '#0000ff', 'x': 2}
        ]
        
        for f in fighters:
            entities.append({
                'id': f['id'],
                'type': 'PERSON',
                'role': 'FIGHTER',
                'position': {'x': f['x'], 'y': 0, 'z': 0},
                'color': f['color']
            })
            
    def update(self, entities: List[dict], dt: float):
        # Close quarters movement
        pass

```

#### simulation\src\sports\soccer.py
```python
from ..core.scenario_manager import Scenario
import numpy as np

class SoccerScenario(Scenario):
    def initialize(self, entities: List[dict]):
        # Pitch: 105m x 68m
        
        # 22 Players
        for i in range(22):
            team = 'HOME' if i < 11 else 'AWAY'
            entities.append({
                'id': f'SOC_PLAYER_{i}',
                'type': 'PERSON',
                'team': team,
                'position': {
                    'x': np.random.uniform(-50, 50),
                    'y': np.random.uniform(-30, 30),
                    'z': 0
                },
                'color': '#ff0000' if team == 'HOME' else '#0000ff'
            })
            
    def update(self, entities: List[dict], dt: float):
        # Placeholder movement
        pass

```

#### simulation\src\utils\ptp_sync.py
```python
import time
import numpy as np

class PTPClock:
    """
    Simulates IEEE 1588 Precision Time Protocol.
    Provides nanosecond-precision timestamps with realistic drift.
    """
    
    def __init__(self, is_master: bool = True):
        self.is_master = is_master
        self.epoch = time.time_ns()  # Nanoseconds since Unix epoch
        
        # Clock characteristics
        self.crystal_frequency = 1e9  # 1 GHz
        self.ppm_drift = np.random.uniform(10, 30)  # Parts per million (realistic crystal)
        self.sync_interval = 1.0  # seconds
        self.last_sync = time.time()
        
        # Offset from master (for slave clocks)
        self.offset_ns = 0
        self.offset_history = []
        
        # Statistics
        self.sync_count = 0
        self.max_offset = 0
        
    def get_time(self) -> int:
        """
        Get current PTP time in nanoseconds.
        Includes realistic clock drift.
        """
        elapsed_real = time.time_ns() - self.epoch
        
        # Apply drift (PPM) - clock runs slightly faster or slower
        drift_factor = 1.0 + (self.ppm_drift / 1e6)
        elapsed_with_drift = int(elapsed_real * drift_factor)
        
        # Add/subtract offset for slave clocks
        if not self.is_master:
            return elapsed_with_drift + self.offset_ns
        
        return elapsed_with_drift
    
    def sync_with_master(self, master_time: int):
        """
        Slave clock synchronization with master.
        Uses simplified Best Master Clock Algorithm.
        """
        if self.is_master:
            return
        
        current_time = self.get_time()
        
        # Compute offset
        new_offset = master_time - current_time
        
        # Apply smoothing (PI controller to avoid sudden jumps)
        if self.offset_history:
            prev_offset = self.offset_history[-1]
            # Proportional + Integral correction
            p_gain = 0.1
            i_gain = 0.01
            correction = p_gain * new_offset + i_gain * (new_offset - prev_offset)
            self.offset_ns += int(correction)
        else:
            # First sync - apply full offset
            self.offset_ns = new_offset
        
        self.offset_history.append(new_offset)
        if len(self.offset_history) > 100:
            self.offset_history.pop(0)
            
        self.last_sync = time.time()
        self.sync_count += 1
        
        # Track max offset
        abs_offset = abs(new_offset)
        if abs_offset > self.max_offset:
            self.max_offset = abs_offset
    
    def get_sync_status(self) -> dict:
        """Return synchronization health metrics."""
        time_since_sync = time.time() - self.last_sync
        
        return {
            'is_master': self.is_master,
            'offset_ns': self.offset_ns,
            'offset_us': self.offset_ns / 1000,
            'offset_ms': self.offset_ns / 1_000_000,
            'time_since_sync_s': time_since_sync,
            'synchronized': time_since_sync < 2.0,  # 2 second timeout
            'drift_ppm': self.ppm_drift,
            'sync_count': self.sync_count,
            'max_offset_us': self.max_offset / 1000
        }

```

#### simulation\tests\test_camera_simulator.py
```python
import unittest
import numpy as np
from src.nodes.camera_simulator import CameraSimulator

class TestCameraSimulator(unittest.TestCase):
    def setUp(self):
        self.camera = CameraSimulator(
            resolution={'width': 1920, 'height': 1080},
            fps=30,
            fov=90
        )
    
    def test_render_returns_bytes_when_due(self):
        # Timestamp 0.0 -> should render
        # Timestamp 0.001 -> should NOT render (too soon for 30fps)
        
        entities = [{'id': 'E1', 'position': {'x': 0, 'y': 0, 'z': 5}}]
        
        # First frame
        frame1 = self.camera.render(entities, timestamp=1.0)
        self.assertIsNotNone(frame1)
        self.assertIsInstance(frame1, bytes)
        
        # Too soon
        frame2 = self.camera.render(entities, timestamp=1.01)
        self.assertIsNone(frame2)
        
        # Next frame due (approx 33ms later)
        frame3 = self.camera.render(entities, timestamp=1.04)
        self.assertIsNotNone(frame3)

if __name__ == '__main__':
    unittest.main()

```

#### simulation\tests\test_performance.py
```python
import time
import unittest
from src.core.orchestrator import SimulationOrchestrator

class TestPerformance(unittest.TestCase):
    def test_fps_stability(self):
        # This test ensures the loop runs at ~30 FPS
        # We'll just run a few iter and check time
        
        # Mock orchestrator behavior without threading for test
        orch = SimulationOrchestrator()
        
        start_time = time.time()
        frames = 30
        
        for i in range(frames):
            orch._generate_sensor_data()
            orch._detect_anomalies()
            time.sleep(1/30) # Simulate loop wait
            
        elapsed = time.time() - start_time
        fps = frames / elapsed
        
        print(f"Measured FPS: {fps}")
        self.assertTrue(25 < fps < 35, f"FPS {fps} out of range")

if __name__ == '__main__':
    unittest.main()

```

## 5. Frontend

#### frontend\Dockerfile
```
# Build Stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
# Skip type check based on previous tsconfig relaxation, but run build
RUN npm run build

# Serve Stage
FROM node:18-alpine
WORKDIR /app
RUN npm install -g serve
COPY --from=builder /app/dist ./dist
EXPOSE 80
CMD ["serve", "-s", "dist", "-l", "80"]

```

#### frontend\index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motion Intelligence Grid</title>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

#### frontend\package.json
```json
{
    "name": "motiongrid-frontend",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.1",
        "three": "^0.160.0",
        "@react-three/fiber": "^8.15.12",
        "@react-three/drei": "^9.92.4",
        "socket.io-client": "^4.6.2",
        "recharts": "^2.10.3",
        "axios": "^1.6.2",
        "date-fns": "^2.30.0",
        "zustand": "^4.4.7",
        "clsx": "^2.0.0",
        "tailwind-merge": "^2.1.0",
        "lucide-react": "^0.294.0",
        "class-variance-authority": "^0.7.0"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@types/three": "^0.160.0",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.3.6",
        "typescript": "^5.2.2",
        "vite": "^5.0.8"
    }
}
```

#### frontend\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "module": "ESNext",
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        /* Linting */
        "strict": false,
        "noImplicitAny": false,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": [
        "src"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
```

#### frontend\tsconfig.node.json
```json
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "vite.config.ts"
    ]
}
```

#### frontend\vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        host: true,
        allowedHosts: true, // Allow Cloud Run domains
        port: 5173,
        proxy: {
            '/api': {
                target: 'http://localhost:3001',
                changeOrigin: true
            }
        }
    }
})

```

#### frontend\src\App.tsx
```typescript
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AppShell } from './components/layout/AppShell';


import Dashboard from './views/Dashboard/Dashboard';
import SystemConfig from './views/SystemConfig/SystemConfig';

import { LiveMonitoring } from './views/LiveMonitoring';
import SessionReplay from './views/SessionReplay/SessionReplay';
import AnalyticsDashboard from './views/Analytics/AnalyticsDashboard';

import { PlaceholderView } from './components/common/PlaceholderView';

function App() {
    return (
        <Router>
            <AppShell>
                <Routes>
                    <Route path="/" element={<Dashboard />} />
                    <Route path="/live" element={<LiveMonitoring />} />
                    <Route path="/replay/:id" element={<SessionReplay />} />
                    <Route path="/analytics" element={<AnalyticsDashboard />} />
                    <Route path="/config" element={<SystemConfig />} />

                    {/* Placeholder Routes for WIP Features */}
                    <Route path="/sessions" element={<PlaceholderView title="Session Management" />} />
                    <Route path="/automation" element={<PlaceholderView title="Automation Rules" />} />
                    <Route path="/triage" element={<PlaceholderView title="Alert Triage" />} />
                    <Route path="/entities" element={<PlaceholderView title="Entity Management" />} />

                    {/* Fallback */}
                    <Route path="*" element={<PlaceholderView title="404: Page Not Found" description="The page you are looking for does not exist." />} />
                </Routes>
            </AppShell>
        </Router>
    )
}

export default App

```

#### frontend\src\index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  background-color: #020617;
  /* navy-950 */
  color: #f8fafc;
  /* light text */
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
```

#### frontend\src\main.tsx
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

```

#### frontend\src\vite-env.d.ts
```typescript
/// <reference types="vite/client" />

```

#### frontend\src\components\common\PlaceholderView.tsx
```typescript
import React from 'react';
import { Construction } from 'lucide-react';
import { Card } from '../ui/Card';

interface PlaceholderViewProps {
    title: string;
    description?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
    title,
    description = "This feature is currently under development. Check back soon for updates."
}) => {
    return (
        <div className="p-6 h-full flex items-center justify-center">
            <Card className="max-w-md w-full p-8 text-center flex flex-col items-center gap-4 bg-navy-800 border-navy-700">
                <div className="w-16 h-16 bg-navy-900 rounded-full flex items-center justify-center border border-navy-700 shadow-inner">
                    <Construction className="w-8 h-8 text-primary-400" />
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white mb-2">{title}</h2>
                    <p className="text-slate-400 leading-relaxed">
                        {description}
                    </p>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\components\layout\AppShell.tsx
```typescript
import { Sidebar } from './Sidebar';
import { TopBar } from './TopBar';

interface AppShellProps {
    children: React.ReactNode;
}

export function AppShell({ children }: AppShellProps) {
    return (
        <div className="min-h-screen bg-navy-950 text-slate-200 font-sans selection:bg-secondary-500/30">
            <TopBar />
            <Sidebar />

            <main className="pl-[260px] pt-[80px] min-h-screen transition-all duration-300">
                <div className="max-w-[1920px] mx-auto p-6 animate-in fade-in duration-500 slide-in-from-bottom-4">
                    {children}
                </div>
            </main>
        </div>
    );
}

```

#### frontend\src\components\layout\Sidebar.tsx
```typescript
import {
    LayoutDashboard,
    Radio,
    Server,
    Settings,
    Bell,
    Search,
    Menu,
    Play,
    LayoutGrid,
    Activity,
    Video,
    BarChart3,
    Zap,
    AlertTriangle,
    Users,
    HelpCircle,
    LogOut
} from 'lucide-react';
import { NavLink } from 'react-router-dom';
import { cn } from '../../utils/cn';

const NAV_ITEMS = [
    { label: 'Overview', path: '/', icon: LayoutGrid },
    { label: 'Live Intelligence', path: '/live', icon: Activity },
    { label: 'Session Replay', path: '/replay/mock-session-1', icon: Play }, // Added for easy access
    { label: 'System Config', path: '/config', icon: Settings },
    { label: 'Sessions', path: '/sessions', icon: Video },
    { label: 'Analytics', path: '/analytics', icon: BarChart3 },
    { label: 'Automation', path: '/automation', icon: Zap },
    { label: 'Triage', path: '/triage', icon: AlertTriangle },
    { label: 'Entities', path: '/entities', icon: Users },
];

export function Sidebar() {
    return (
        <aside className="w-[260px] bg-navy-900 border-r border-navy-800 fixed left-0 top-0 bottom-0 pt-[80px] flex flex-col z-40">
            <div className="flex-1 overflow-y-auto py-6 px-3 space-y-1">
                <div className="text-xs font-bold text-slate-500 uppercase px-4 mb-2 tracking-wider">Menu</div>
                {NAV_ITEMS.map((item) => (
                    <NavLink
                        key={item.path}
                        to={item.path}
                        className={({ isActive }) => cn(
                            "flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200",
                            isActive
                                ? "bg-secondary-600/10 text-secondary-400 border border-secondary-600/20 shadow-[0_0_15px_rgba(99,102,241,0.1)]"
                                : "text-slate-400 hover:bg-navy-800 hover:text-slate-200"
                        )}
                    >
                        <item.icon className="w-5 h-5" />
                        {item.label}
                    </NavLink>
                ))}
            </div>

            <div className="p-4 border-t border-navy-800 space-y-1">
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-navy-800 hover:text-slate-200 transition-colors">
                    <HelpCircle className="w-5 h-5" />
                    Help & Docs
                </button>
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-red-900/20 hover:text-red-400 transition-colors">
                    <LogOut className="w-5 h-5" />
                    Logout
                </button>
            </div>
        </aside>
    );
}

```

#### frontend\src\components\layout\TopBar.tsx
```typescript
import { Bell, Settings, User, Search } from 'lucide-react';
import { Button } from '../ui/Button';

export function TopBar() {
    return (
        <header className="h-[80px] bg-navy-950 border-b border-navy-800 flex items-center justify-between px-6 fixed top-0 left-0 right-0 z-50">
            {/* Left: Logo & Context */}
            <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-lg flex items-center justify-center shadow-lg shadow-primary-500/20">
                        <svg className="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <span className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-400 to-secondary-400">
                        MotionGrid
                    </span>
                </div>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div className="flex items-center gap-2 text-slate-400 bg-navy-900 py-2 px-4 rounded-lg border border-navy-800">
                    <Search className="w-4 h-4" />
                    <span className="text-sm">Global Search...</span>
                </div>
            </div>

            {/* Right: Actions & Profile */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" className="relative" onClick={() => alert("Notifications coming soon!")}>
                    <Bell className="w-5 h-5 text-slate-400" />
                    <span className="absolute top-2 right-2 w-2 h-2 bg-status-critical rounded-full animate-pulse" />
                </Button>
                <Button variant="ghost" size="icon" onClick={() => alert("Settings panel coming soon!")}>
                    <Settings className="w-5 h-5 text-slate-400" />
                </Button>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div
                    className="flex items-center gap-3 pl-2 cursor-pointer hover:bg-navy-900 p-2 rounded-lg transition-colors"
                    onClick={() => alert("User profile management coming soon!")}
                >
                    <div className="text-right hidden md:block">
                        <div className="text-sm font-semibold text-white">Admin User</div>
                        <div className="text-xs text-primary-400">OPERATOR</div>
                    </div>
                    <div className="w-10 h-10 bg-navy-800 rounded-full flex items-center justify-center border border-navy-700">
                        <User className="w-5 h-5 text-slate-300" />
                    </div>
                </div>
            </div>
        </header>
    );
}

```

#### frontend\src\components\ui\Badge.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const badgeVariants = cva(
    "inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide transition-colors",
    {
        variants: {
            variant: {
                default: "bg-navy-700 text-white",
                critical: "bg-status-critical text-white shadow-[0_0_10px_rgba(220,38,38,0.4)]",
                high: "bg-status-high text-white",
                medium: "bg-status-medium text-white",
                low: "bg-status-low text-white",
                success: "bg-status-success text-white",
                outline: "border border-navy-700 text-slate-400 bg-transparent",
            },
            size: {
                sm: "text-[10px] px-2 py-0.5",
                md: "text-xs px-3 py-1",
                lg: "text-sm px-4 py-1.5",
            }
        },
        defaultVariants: {
            variant: "default",
            size: "md",
        }
    }
);

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof badgeVariants> { }

export function Badge({ className, variant, size, ...props }: BadgeProps) {
    return (
        <span className={badgeVariants({ variant, size, className })} {...props} />
    );
}

```

#### frontend\src\components\ui\Button.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';
import React from 'react';

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-lg text-sm font-semibold transition-all focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none active:scale-95",
    {
        variants: {
            variant: {
                primary: "bg-secondary-600 text-white hover:bg-secondary-500 shadow-lg shadow-secondary-900/20",
                secondary: "border border-navy-700 bg-transparent text-slate-300 hover:bg-navy-800",
                danger: "bg-status-critical text-white hover:bg-red-700",
                ghost: "bg-transparent text-slate-400 hover:text-white hover:bg-navy-800",
                icon: "p-2 bg-transparent text-slate-400 hover:bg-navy-800 hover:text-white rounded-md",
            },
            size: {
                sm: "px-3 py-1.5 text-xs",
                md: "px-4 py-2",
                lg: "px-6 py-3 text-base",
                icon: "h-9 w-9 p-0",
            },
            fullWidth: {
                true: "w-full",
            }
        },
        defaultVariants: {
            variant: "primary",
            size: "md",
            fullWidth: false,
        }
    }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, fullWidth, ...props }, ref) => {
        return (
            <button
                ref={ref}
                className={buttonVariants({ variant, size, fullWidth, className })}
                {...props}
            />
        );
    }
);
Button.displayName = "Button";

```

#### frontend\src\components\ui\Card.tsx
```typescript
import { cn } from '../../utils/cn';
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    hover?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
    ({ className, hover = true, children, ...props }, ref) => {
        return (
            <div
                ref={ref}
                className={cn(
                    "bg-navy-800 border border-navy-700 rounded-xl shadow-md p-5",
                    "transition-all duration-200 ease-out",
                    hover && "hover:-translate-y-0.5 hover:shadow-lg hover:shadow-black/20 hover:border-navy-600",
                    className
                )}
                {...props}
            >
                {children}
            </div>
        );
    }
);
Card.displayName = "Card";

export function CardHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("mb-4 flex items-center justify-between", className)} {...props}>
            {children}
        </div>
    );
}

export function CardTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
    return (
        <h3 className={cn("text-lg font-bold text-white", className)} {...props}>
            {children}
        </h3>
    );
}

export function CardContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("text-sm text-slate-300 leading-relaxed", className)} {...props}>
            {children}
        </div>
    );
}

```

#### frontend\src\services\api.ts
```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';

const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

export const Api = {
    // Nodes
    getNodes: async () => (await api.get('/nodes')).data,
    getNode: async (id: string) => (await api.get(`/nodes/${id}`)).data,
    createNode: async (data: any) => (await api.post('/nodes', data)).data,
    updateNode: async (id: string, data: any) => (await api.patch(`/nodes/${id}`, data)).data,
    deleteNode: async (id: string) => (await api.delete(`/nodes/${id}`)).data,

    // Sessions
    getSessions: async () => (await api.get('/sessions')).data,
    getSession: async (id: string) => (await api.get(`/sessions/${id}`)).data,
    createSession: async (data: any) => (await api.post('/sessions', data)).data,
    updateSession: async (id: string, data: any) => (await api.patch(`/sessions/${id}`, data)).data,
    deleteSession: async (id: string) => (await api.delete(`/sessions/${id}`)).data,
    startSession: async (id: string) => (await api.post(`/sessions/${id}/start`)).data,
    stopSession: async (id: string) => (await api.post(`/sessions/${id}/stop`)).data,

    // Simulation
    startSimulation: async (config: any) => (await api.post('/simulation/start', config)).data,
    stopSimulation: async () => (await api.post('/simulation/stop')).data,
    getSimulationStatus: async () => (await api.get('/simulation/status')).data,

    // Entities
    getEntities: async () => (await api.get('/entities')).data,

    // Analytics
    getStats: async () => (await api.get('/analytics/stats')).data
};

```

#### frontend\src\services\websocket.ts
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketService {
    private socket: Socket | null = null;
    private callbacks: Map<string, Function[]> = new Map();

    connect(url: string) {
        this.socket = io(url, {
            transports: ['websocket'],
            reconnection: true
        });

        this.socket.on('connect', () => {
            console.log('WebSocket connected');
            // Re-subscribe if we had active subscriptions? 
            // For now, simpler to leave it to the components.
        });

        this.socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        // Register for all expected events
        ['sensor:frame', 'anomaly:detected', 'entity:tracking', 'session:stats', 'node:status']
            .forEach(event => {
                this.socket!.on(event, (data: any) => {
                    const cbs = this.callbacks.get(event) || [];
                    cbs.forEach(cb => cb(data));
                });
            });
    }

    subscribeToSession(sessionId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:session', { sessionId });
    }

    subscribeToNode(nodeId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:node', { nodeId });
    }

    on(event: string, callback: Function) {
        if (!this.callbacks.has(event)) {
            this.callbacks.set(event, []);
        }
        this.callbacks.get(event)!.push(callback);
    }

    off(event: string, callback: Function) {
        if (!this.callbacks.has(event)) return;
        const cbs = this.callbacks.get(event) || [];
        this.callbacks.set(event, cbs.filter(cb => cb !== callback));
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
}

export const wsService = new WebSocketService();

```

#### frontend\src\utils\cn.ts
```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

```

#### frontend\src\views\Analytics\AnalyticsDashboard.tsx
```typescript
import React, { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../components/ui/Card';
import { Api } from '../../services/api';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, LineChart, Line } from 'recharts';

export default function AnalyticsDashboard() {
    const [stats, setStats] = useState<any>(null);

    useEffect(() => {
        // Mock stats for now or fetch from API
        setStats({
            dailyAnomalies: [
                { time: '09:00', count: 2 },
                { time: '10:00', count: 5 },
                { time: '11:00', count: 3 },
                { time: '12:00', count: 8 },
                { time: '13:00', count: 4 },
            ],
            metrics: {
                totalProcessingTime: 1240,
                activeNodes: 42
            }
        });

        // Api.getStats().then(setStats);
    }, []);

    if (!stats) return <div className="p-8">Loading analytics...</div>;

    return (
        <div className="p-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            <h1 className="text-2xl font-bold text-gray-100 col-span-full">Analytics Dashboard</h1>

            <Card className="col-span-1">
                <CardHeader>
                    <CardTitle>Simulation Load (Entities)</CardTitle>
                </CardHeader>
                <CardContent className="h-[300px]">
                    <ResponsiveContainer width="100%" height="100%">
                        <LineChart data={stats.dailyAnomalies}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#333" />
                            <XAxis dataKey="time" stroke="#888" />
                            <YAxis stroke="#888" />
                            <Tooltip
                                contentStyle={{ backgroundColor: '#1e293b', border: 'none' }}
                                itemStyle={{ color: '#e2e8f0' }}
                            />
                            <Line type="monotone" dataKey="count" stroke="#3b82f6" strokeWidth={2} />
                        </LineChart>
                    </ResponsiveContainer>
                </CardContent>
            </Card>

            <Card className="col-span-1">
                <CardHeader>
                    <CardTitle>Anomaly Distribution</CardTitle>
                </CardHeader>
                <CardContent className="h-[300px]">
                    <ResponsiveContainer width="100%" height="100%">
                        <BarChart data={stats.dailyAnomalies}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#333" />
                            <XAxis dataKey="time" stroke="#888" />
                            <YAxis stroke="#888" />
                            <Tooltip
                                contentStyle={{ backgroundColor: '#1e293b', border: 'none' }}
                                itemStyle={{ color: '#e2e8f0' }}
                            />
                            <Bar dataKey="count" fill="#ef4444" radius={[4, 4, 0, 0]} />
                        </BarChart>
                    </ResponsiveContainer>
                </CardContent>
            </Card>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\Dashboard.tsx
```typescript
import { AnomalyPanel } from './components/AnomalyPanel';
import { DashboardControls } from './components/DashboardControls';
import { StadiumMap } from './components/StadiumMap';
import { DashboardSparkline } from './components/DashboardSparkline';

const Dashboard = () => {
    return (
        <div className="space-y-6">
            <DashboardControls />

            <div className="flex flex-col lg:flex-row gap-6">
                {/* Main View: Stadium Map */}
                <div className="flex-1">
                    <StadiumMap />

                    {/* Bottom Sparkline */}
                    <div className="mt-6 h-[100px] bg-navy-900 border border-navy-800 rounded-xl relative overflow-hidden p-2">
                        <DashboardSparkline />
                    </div>
                </div>

                {/* Right Panel: Anomalies */}
                <AnomalyPanel />
            </div>
        </div>
    );
};

export default Dashboard;

```

#### frontend\src\views\Dashboard\components\AnomalyPanel.tsx
```typescript
import { Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { Badge } from '../../../components/ui/Badge';

const ANOMALIES = [
    { id: 1, time: '11:22', zone: 'Gate B', type: 'Crowd Compression', severity: 'critical', score: 87, delta: '+150%' },
    { id: 2, time: '11:20', zone: 'Concourse N', type: 'Rapid Movement', severity: 'high', score: 65, delta: '+80%' },
    { id: 3, time: '11:15', zone: 'Field', type: 'Unauthorized Access', severity: 'medium', score: 45, delta: 'N/A' },
    { id: 4, time: '11:10', zone: 'Gate A', type: 'Loitering', severity: 'low', score: 20, delta: '+15%' },
];

export function AnomalyPanel() {
    return (
        <div className="w-full lg:w-[360px] bg-navy-900 border border-navy-800 rounded-2xl flex flex-col h-[600px]">
            {/* Header */}
            <div className="p-4 border-b border-navy-800 flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-bold text-white">Active Anomalies</h3>
                    <div className="text-xs text-slate-400">23 Detected • <span className="text-status-critical">4 Critical</span></div>
                </div>
                <div className="flex gap-2">
                    <Button variant="ghost" size="icon"><Filter className="w-4 h-4" /></Button>
                    <Button variant="ghost" size="icon"><MoreHorizontal className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* List */}
            <div className="flex-1 overflow-y-auto p-3 space-y-3">
                {ANOMALIES.map((item) => (
                    <div
                        key={item.id}
                        className="group bg-navy-800 rounded-xl p-3 border border-navy-700 hover:border-indigo-500/50 hover:bg-navy-800/80 transition-all cursor-pointer relative overflow-hidden"
                    >
                        {/* Severity Indicator Bar */}
                        <div className={`absolute left-0 top-0 bottom-0 w-1 ${item.severity === 'critical' ? 'bg-status-critical' :
                            item.severity === 'high' ? 'bg-status-high' :
                                item.severity === 'medium' ? 'bg-status-medium' : 'bg-status-low'
                            }`} />

                        <div className="pl-3">
                            <div className="flex justify-between items-start mb-1">
                                <Badge variant={item.severity as any} size="sm">{item.severity}</Badge>
                                <span className="text-xs font-mono text-slate-500">{item.time}</span>
                            </div>

                            <h4 className="font-bold text-white text-sm mb-1 group-hover:text-indigo-300 transition-colors">{item.type}</h4>
                            <div className="flex justify-between items-center text-xs">
                                <span className="text-slate-400 uppercase tracking-wide font-semibold">{item.zone}</span>
                                <div className="flex gap-3 text-slate-500">
                                    <span>Risk: <span className={item.score > 80 ? 'text-red-400' : 'text-slate-300'}>{item.score}</span></span>
                                    <span>Δ: {item.delta}</span>
                                </div>
                            </div>
                        </div>

                        {/* Hover Actions Overlay (Simulated) */}
                        <div className="absolute right-2 bottom-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button size="sm" variant="secondary" className="h-7 text-xs px-2">View</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-navy-800 bg-navy-950/50 rounded-b-2xl">
                <Button variant="primary" fullWidth size="md">View All Anomalies</Button>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardControls.tsx
```typescript
import { Calendar, ChevronDown } from 'lucide-react';

export function DashboardControls() {
    return (
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6 bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
            {/* Event Selector */}
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-indigo-500/20 rounded-lg flex items-center justify-center text-indigo-400">
                    <Calendar className="w-5 h-5" />
                </div>
                <div>
                    <div className="text-xs text-slate-400 uppercase font-bold tracking-wide">Current Event</div>
                    <div className="flex items-center gap-2 text-white font-semibold cursor-pointer hover:text-indigo-400 transition-colors">
                        Match Day: Team A vs Team B
                        <ChevronDown className="w-4 h-4" />
                    </div>
                </div>
            </div>

            {/* Time Range Chips */}
            <div className="flex bg-navy-900 rounded-lg p-1 border border-navy-700">
                {['Now', 'Last 30m', 'Last 2h', '24h', 'Custom'].map((range, idx) => (
                    <button
                        key={range}
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${idx === 0
                            ? 'bg-secondary-600 text-white shadow-md'
                            : 'text-slate-400 hover:text-white hover:bg-navy-700'
                            }`}
                    >
                        {range}
                    </button>
                ))}
            </div>

            {/* System Status */}
            <div className="flex items-center gap-2 px-4 py-2 bg-status-success/10 border border-status-success/20 rounded-lg text-status-success">
                <span className="relative flex h-2.5 w-2.5">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
                </span>
                <span className="text-sm font-bold tracking-wide">SYSTEM OPTIMAL</span>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardSparkline.tsx
```typescript
import { Area, AreaChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts';

const generateMockData = () => {
    const data = [];
    for (let i = 0; i < 24; i++) {
        data.push({
            time: `${i}:00`,
            events: Math.floor(Math.random() * 50) + 10,
            anomalies: Math.floor(Math.random() * 5),
        });
    }
    return data;
};

const data = generateMockData();

export function DashboardSparkline() {
    return (
        <div className="w-full h-full">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={data}>
                    <defs>
                        <linearGradient id="colorEvents" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#818cf8" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#818cf8" stopOpacity={0} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis hide />
                    <Tooltip
                        contentStyle={{ backgroundColor: '#1e293b', borderColor: '#334155', color: '#f8fafc' }}
                        itemStyle={{ color: '#818cf8' }}
                        labelStyle={{ color: '#94a3b8' }}
                    />
                    <Area
                        type="monotone"
                        dataKey="events"
                        stroke="#818cf8"
                        fillOpacity={1}
                        fill="url(#colorEvents)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\StadiumMap.tsx
```typescript
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ZONES = [
    { id: 'gate-a', name: 'GATE A', type: 'GATE', status: 'critical', x: '10%', y: '20%' },
    { id: 'gate-b', name: 'GATE B', type: 'GATE', status: 'normal', x: '80%', y: '20%' },
    { id: 'field', name: 'FIELD', type: 'FIELD', status: 'normal', x: '45%', y: '45%' },
    { id: 'concourse-n', name: 'CONCOURSE N', type: 'CONCOURSE', status: 'high', x: '45%', y: '10%' },
    { id: 'concourse-s', name: 'CONCOURSE S', type: 'CONCOURSE', status: 'normal', x: '45%', y: '80%' },
];

export function StadiumMap() {
    return (
        <div className="relative w-full h-[600px] bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden shadow-inner">
            {/* Grid Pattern Background */}
            <div className="absolute inset-0 opacity-10"
                style={{ backgroundImage: 'radial-gradient(circle, #334155 1px, transparent 1px)', backgroundSize: '30px 30px' }}
            />

            {/* Stadium Visual Placeholder - Simple SVG representation */}
            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 600">
                {/* Field */}
                <rect x="250" y="150" width="500" height="300" rx="40" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <circle cx="500" cy="300" r="50" fill="none" stroke="#334155" strokeWidth="2" />
                <line x1="500" y1="150" x2="500" y2="450" stroke="#334155" strokeWidth="2" />

                {/* Zones Outline */}
                <path d="M 150 100 Q 500 0 850 100 L 900 250 L 850 500 Q 500 600 150 500 L 100 250 Z"
                    fill="none" stroke="#4f46e5" strokeWidth="2" strokeDasharray="10 5" opacity="0.3" />
            </svg>

            {/* Zone Cards Overlay */}
            {ZONES.map((zone) => (
                <div
                    key={zone.id}
                    className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer transition-transform hover:scale-105 hover:z-10"
                    style={{ left: zone.x, top: zone.y }}
                >
                    <Card className={`w-48 p-3 bg-navy-800/90 backdrop-blur-sm border-l-4 ${zone.status === 'critical' ? 'border-l-status-critical shadow-[0_0_20px_rgba(220,38,38,0.2)]' :
                            zone.status === 'high' ? 'border-l-status-high' :
                                'border-l-status-success'
                        }`}>
                        <div className="flex justify-between items-start mb-2">
                            <span className="text-xs font-bold text-slate-300 tracking-wider">{zone.name}</span>
                            <Badge variant={zone.status as any} size="sm">{zone.status}</Badge>
                        </div>
                        <div className="space-y-1">
                            <div className="text-xs text-slate-400">Last event: 2m ago</div>
                            <div className="text-xs text-slate-400">Anomalies: <span className="text-white font-mono">3</span></div>
                        </div>
                    </Card>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\AlertPanel.tsx
```typescript
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';

interface Anomaly {
    id: string;
    headline: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    time: string;
}

export const AlertPanel = () => {
    const alerts: Anomaly[] = [
        { id: 'A001', headline: 'Crowd Compression Risk', severity: 'CRITICAL', time: '10:42:05' },
        { id: 'A002', headline: 'Restricted Zone Access', severity: 'HIGH', time: '10:41:55' },
        { id: 'A003', headline: 'Loitering Detected', severity: 'LOW', time: '10:40:12' },
    ];

    return (
        <div className="bg-gray-800 border-l border-gray-700 w-80 flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-red-400" />
                    Active Alerts
                </h3>
            </div>

            <div className="flex-1 overflow-auto p-4 space-y-3">
                {alerts.map(alert => (
                    <div key={alert.id} className="bg-gray-700/50 rounded-lg p-3 border border-gray-600 hover:border-gray-500 transition-colors">
                        <div className="flex justify-between items-start mb-2">
                            <span className={`text-xs font-bold px-1.5 py-0.5 rounded ${alert.severity === 'CRITICAL' ? 'bg-red-500/20 text-red-300' :
                                    alert.severity === 'HIGH' ? 'bg-orange-500/20 text-orange-300' : 'bg-blue-500/20 text-blue-300'
                                }`}>
                                {alert.severity}
                            </span>
                            <span className="text-xs text-gray-400">{alert.time}</span>
                        </div>
                        <h4 className="text-sm font-medium mb-2">{alert.headline}</h4>

                        {/* Triage Actions */}
                        <div className="flex gap-2 mt-2">
                            <button className="flex-1 flex items-center justify-center gap-1 bg-green-900/30 hover:bg-green-900/50 text-green-300 py-1 rounded text-xs transition-colors">
                                <CheckCircle className="h-3 w-3" /> Confirm
                            </button>
                            <button className="flex-1 flex items-center justify-center gap-1 bg-gray-600/30 hover:bg-gray-600/50 text-gray-300 py-1 rounded text-xs transition-colors">
                                <XCircle className="h-3 w-3" /> Dismiss
                            </button>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\CameraGrid.tsx
```typescript

import { Camera } from 'lucide-react';
import { VideoPlaceholder } from './components/VideoPlaceholder';

export const CameraGrid = () => {
    // In a real app, this would fetch active nodes from API
    const cameras = [
        { id: 'CAM_01', name: 'North Gate', status: 'ONLINE' },
        { id: 'CAM_02', name: 'South Gate', status: 'ONLINE' },
        { id: 'CAM_03', name: 'Court A', status: 'ONLINE' },
        { id: 'CAM_04', name: 'Court B', status: 'OFFLINE' },
    ];

    return (
        <div className="grid grid-cols-2 gap-2 h-full">
            {cameras.map(cam => (
                <div key={cam.id} className="relative bg-black rounded overflow-hidden group">
                    <div className="absolute inset-0 flex items-center justify-center text-gray-700">
                        {cam.status === 'ONLINE' ? (
                            <div className="flex-1 bg-black relative">
                                <VideoPlaceholder label={cam.name} />
                            </div>) : (
                            <div className="flex flex-col items-center">
                                <Camera className="h-8 w-8 mb-2 opacity-50" />
                                <span className="text-xs">OFFLINE</span>
                            </div>
                        )}
                    </div>

                    {/* Overlay */}
                    <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white backdrop-blur-sm">
                        {cam.name}
                    </div>
                    <div className={`absolute top-2 right-2 w-2 h-2 rounded-full ${cam.status === 'ONLINE' ? 'bg-green-500' : 'bg-red-500'}`} />
                </div>
            ))}
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\index.tsx
```typescript
import { useEffect } from 'react';
import { MeshView3D } from './MeshView3D';
import { LayerControls } from './components/LayerControls';
import { LiveAlerts } from './components/LiveAlerts';
import { CameraStrip } from './components/CameraStrip';
import { wsService } from '../../services/websocket';
import { Button } from '../../components/ui/Button';
import { Pause, RefreshCw } from 'lucide-react';

export const LiveMonitoring = () => {
    useEffect(() => {
        // Use a safe fallback or window object if import.meta env is an issue in container
        const wsUrl = (import.meta as any).env?.VITE_WS_URL || 'http://localhost:3001';
        wsService.connect(wsUrl);
    }, []);

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] gap-4">
            {/* Top Controls */}
            <div className="flex items-center justify-between pb-2 border-b border-navy-800">
                <div className="flex gap-4 items-center">
                    <h2 className="text-lg font-bold text-white">Zone A: Main Concourse</h2>
                    <div className="flex gap-1">
                        <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span className="text-xs text-green-400 font-mono">LIVE FEED</span>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="icon" variant="ghost"><RefreshCw className="w-4 h-4" /></Button>
                    <Button size="icon" variant="secondary"><Pause className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* Main Content Area */}
            <div className="flex flex-1 gap-4 overflow-hidden">
                {/* Left: Layers */}
                <div className="flex-shrink-0">
                    <LayerControls />
                </div>

                {/* Center: 3D View */}
                <div className="flex-1 bg-black rounded-2xl border border-navy-800 relative overflow-hidden group">
                    <MeshView3D />

                    {/* Camera Strip Overlay */}
                    <div className="translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                        <CameraStrip />
                    </div>
                </div>

                {/* Right: Alerts */}
                <div className="flex-shrink-0">
                    <LiveAlerts />
                </div>
            </div>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\MeshView3D.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, Grid, Text } from '@react-three/drei';
import { useEffect, useState } from 'react';
import { wsService } from '../../services/websocket';

interface Entity {
    id: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    position: { x: number; y: number; z: number };
    velocity?: { x: number; y: number; z: number };
}

const BasketballCourt = () => {
    return (
        <group rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.01, 0]}>
            {/* Main Court Floor */}
            <mesh receiveShadow>
                <planeGeometry args={[28.65, 15.24]} /> {/* NBA Court Dimensions in meters */}
                <meshStandardMaterial color="#d2b48c" />
            </mesh>

            {/* Center Circle */}
            <mesh position={[0, 0, 0.01]}>
                <ringGeometry args={[1.8, 1.9, 64]} />
                <meshBasicMaterial color="#ffffff" />
            </mesh>

            {/* Key Lines (Simplified) */}
            <mesh position={[-11.75, 0, 0.01]}>
                <planeGeometry args={[5.8, 4.9]} />
                <meshBasicMaterial color="#a0522d" />
            </mesh>
            <mesh position={[11.75, 0, 0.01]}>
                <planeGeometry args={[5.8, 4.9]} />
                <meshBasicMaterial color="#a0522d" />
            </mesh>
        </group>
    );
};

const EntityMesh = ({ entity }: { entity: Entity }) => {
    // Determine color/shape based on role/team
    let color = '#cccccc';
    if (entity.role === 'BALL') color = 'orange';
    else if (entity.role === 'OFFICIAL') color = 'black';
    else if (entity.team === 'HOME') color = '#1e3a8a'; // Blue
    else if (entity.team === 'AWAY') color = '#b91c1c'; // Red

    const position: [number, number, number] = [entity.position.x, entity.position.z, entity.position.y]; // Z-up in data to Y-up in Three.js usually

    if (entity.role === 'BALL') {
        return (
            <mesh position={position}>
                <sphereGeometry args={[0.12, 16, 16]} />
                <meshStandardMaterial color={color} />
            </mesh>
        );
    }

    return (
        <group position={position}>
            {/* Body */}
            <mesh position={[0, 0.9, 0]}>
                <capsuleGeometry args={[0.3, 1.2, 4, 8]} />
                <meshStandardMaterial color={color} />
            </mesh>
            {/* Label */}
            <Text
                position={[0, 2.2, 0]}
                fontSize={0.3}
                color="white"
                anchorX="center"
                anchorY="middle"
            >
                {entity.id}
            </Text>
        </group>
    );
};

export const MeshView3D = () => {
    const [entities, setEntities] = useState<Entity[]>([]);

    useEffect(() => {
        const handleTracking = (data: any) => {
            if (data.entities) {
                setEntities(data.entities);
            }
        };

        wsService.subscribeToSession('live'); // Subscribe to live session by default
        wsService.on('entity:tracking', handleTracking);

        return () => {
            wsService.off('entity:tracking', handleTracking);
        };
    }, []);

    return (
        <div className="h-full w-full bg-slate-950">
            <Canvas camera={{ position: [0, 20, 20], fov: 45 }}>
                <ambientLight intensity={0.7} />
                <pointLight position={[10, 20, 10]} intensity={0.8} />
                <directionalLight position={[-10, 20, -10]} intensity={0.5} />

                <OrbitControls />
                <BasketballCourt />

                {entities.map(entity => (
                    <EntityMesh key={entity.id} entity={entity} />
                ))}
            </Canvas>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\components\CameraStrip.tsx
```typescript
export function CameraStrip() {
    return (
        <div className="absolute bottom-4 left-4 right-4 flex gap-4 overflow-x-auto pb-2 scrollbar-hide">
            {[1, 2, 3, 4, 5].map(cam => (
                <div key={cam} className="w-40 h-24 bg-black rounded-lg border border-navy-700 relative flex-shrink-0 group cursor-pointer hover:border-indigo-500 transition-colors">
                    <div className="absolute top-1 left-1 bg-black/50 px-1 rounded text-[10px] text-slate-300">CAM-0{cam}</div>
                    <div className="w-full h-full flex items-center justify-center text-slate-700 text-xs">NO SIGNAL</div>
                    <div className="absolute top-1 right-1 h-2 w-2 bg-green-500 rounded-full shadow-[0_0_5px_rgba(34,197,94,0.5)]"></div>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LayerControls.tsx
```typescript
import { Layers, Eye, Activity, Map, Users, Zap } from 'lucide-react';
import { Card } from '../../../components/ui/Card';

const LAYERS = [
    { id: 'entities', label: 'Entities', icon: Users, default: true },
    { id: 'risk', label: 'Risk Halos', icon: Zap, default: true },
    { id: 'velocity', label: 'Velocity Vectors', icon: Activity, default: false },
    { id: 'trails', label: 'Path Trails', icon: Map, default: false },
    { id: 'social', label: 'Social Radar', icon: Users, default: false },
    { id: 'terrain', label: 'Behavior Terrain', icon: Layers, default: true },
];

export function LayerControls() {
    return (
        <Card className="w-64 bg-navy-900 border-navy-800 flex flex-col gap-4 h-full">
            <div className="flex items-center gap-2 mb-2 pb-2 border-b border-navy-800">
                <Layers className="w-4 h-4 text-indigo-400" />
                <h3 className="font-bold text-white text-sm">View Layers</h3>
            </div>

            <div className="space-y-3">
                {LAYERS.map(layer => (
                    <label key={layer.id} className="flex items-center justify-between group cursor-pointer">
                        <div className="flex items-center gap-3 text-slate-300 group-hover:text-white transition-colors">
                            <layer.icon className="w-4 h-4 text-slate-500 group-hover:text-indigo-400" />
                            <span className="text-sm font-medium">{layer.label}</span>
                        </div>
                        <div className="relative inline-block w-8 h-4 rounded-full cursor-pointer">
                            <input type="checkbox" className="sr-only peer" defaultChecked={layer.default} />
                            <div className="w-8 h-4 bg-navy-800 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-indigo-600"></div>
                        </div>
                    </label>
                ))}
            </div>

            <div className="mt-auto pt-4 border-t border-navy-800">
                <div className="text-xs text-slate-500 mb-2 uppercase font-bold">Camera Overlay</div>
                <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <Eye className="w-4 h-4" /> Show FOV Cones
                    <input type="checkbox" className="ml-auto accent-indigo-500" defaultChecked />
                </label>
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LiveAlerts.tsx
```typescript
import { AlertTriangle, Clock } from 'lucide-react';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ALERTS = [
    { id: 1, type: 'Crowd Crush', risk: 92, time: '10s ago', zone: 'Gate B' },
    { id: 2, type: 'Fight Precursor', risk: 78, time: '32s ago', zone: 'Concourse' },
    { id: 3, type: 'Fallen Object', risk: 45, time: '1m ago', zone: 'Aisle 12' },
];

export function LiveAlerts() {
    return (
        <Card className="w-80 bg-navy-900 border-navy-800 flex flex-col h-full">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-navy-800">
                <div className="flex items-center gap-2">
                    <AlertTriangle className="w-4 h-4 text-status-critical" />
                    <h3 className="font-bold text-white text-sm">Live Alerts</h3>
                </div>
                <Badge variant="critical">3 Active</Badge>
            </div>

            <div className="flex-1 overflow-y-auto space-y-3">
                {ALERTS.map(alert => (
                    <div key={alert.id} className="bg-navy-800 p-3 rounded-lg border border-navy-700 hover:border-red-500/50 transition-colors cursor-pointer group">
                        <div className="flex justify-between items-start mb-1">
                            <span className="text-xs font-bold text-red-300">{alert.type}</span>
                            <span className="text-[10px] text-slate-500 flex items-center gap-1">
                                <Clock className="w-3 h-3" /> {alert.time}
                            </span>
                        </div>
                        <div className="flex justify-between items-end">
                            <div className="text-xs text-slate-400">{alert.zone}</div>
                            <div className="text-sm font-mono font-bold text-white">
                                {alert.risk}% <span className="text-xs font-sans font-normal text-slate-500">Risk</span>
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\VideoPlaceholder.tsx
```typescript
import { useEffect, useRef } from 'react';

export function VideoPlaceholder({ label }: { label: string }) {
    const canvasRef = useRef<HTMLCanvasElement>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId: number;
        let time = 0;

        const draw = () => {
            time += 0.05;
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a'; // bg-slate-900
            ctx.fillRect(0, 0, width, height);

            // Digital Noise / Scanlines
            for (let i = 0; i < height; i += 4) {
                ctx.fillStyle = `rgba(30, 41, 59, ${Math.random() * 0.5})`;
                ctx.fillRect(0, i, width, 1);
            }

            // Moving "Entities" (Simple Blobs)
            const x = (Math.sin(time) * 0.4 + 0.5) * width;
            const y = (Math.cos(time * 0.7) * 0.4 + 0.5) * height;

            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(79, 70, 229, 0.4)'; // Indigo
            ctx.fill();

            // Overlay Text
            ctx.font = '12px monospace';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('REC', width - 40, 20);
            ctx.fillText(new Date().toLocaleTimeString(), 10, height - 10);
            ctx.fillText(label, 10, 20);

            // Recording Dot
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(width - 50, 15, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }

            animationFrameId = window.requestAnimationFrame(draw);
        };

        const resize = () => {
            if (canvas.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        };

        window.addEventListener('resize', resize);
        resize(); // Initial resize
        draw();

        return () => {
            window.removeEventListener('resize', resize);
            window.cancelAnimationFrame(animationFrameId);
        };
    }, [label]);

    return (
        <canvas ref={canvasRef} className="w-full h-full block" />
    );
}

```

#### frontend\src\views\SessionReplay\SessionReplay.tsx
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { useParams } from 'react-router-dom';
import { Api } from '../../services/api';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { Play, Pause, SkipForward, SkipBack } from 'lucide-react';

export default function SessionReplay() {
    const { id } = useParams<{ id: string }>();
    const [session, setSession] = useState<any>(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState(0);
    const [duration, setDuration] = useState(0);
    const [playbackSpeed, setPlaybackSpeed] = useState(1);

    useEffect(() => {
        if (id) {
            Api.getSession(id).then(data => {
                setSession(data);
                setDuration(data.duration || 60); // Mock duration if missing
            });
        }
    }, [id]);

    useEffect(() => {
        let interval: any;
        if (isPlaying) {
            interval = setInterval(() => {
                setCurrentTime(prev => {
                    if (prev >= duration) {
                        setIsPlaying(false);
                        return duration;
                    }
                    return prev + (0.1 * playbackSpeed);
                });
            }, 100);
        }
        return () => clearInterval(interval);
    }, [isPlaying, duration, playbackSpeed]);

    const handleSeek = (e: React.ChangeEvent<HTMLInputElement>) => {
        setCurrentTime(parseFloat(e.target.value));
    };

    if (!session) return <div className="p-8">Loading session...</div>;

    return (
        <div className="p-6 h-full flex flex-col gap-4">
            <h1 className="text-2xl font-bold text-gray-100">Session Replay: {session.name}</h1>

            <div className="flex-1 grid grid-cols-3 gap-6">
                {/* Main Viewport */}
                <Card className="col-span-2 relative min-h-[500px] flex items-center justify-center bg-gray-950">
                    <div className="text-gray-500">
                        [3D Replay Visualization Needed Here]
                        <p className="text-sm mt-2">Time: {currentTime.toFixed(1)}s</p>
                    </div>
                </Card>

                {/* Info Panel */}
                <div className="col-span-1 flex flex-col gap-4">
                    <Card>
                        <h2 className="text-lg font-semibold mb-2">Session Details</h2>
                        <div className="space-y-2 text-sm text-gray-300">
                            <p>Sport: {session.sport}</p>
                            <p>Venue: {session.venue || 'Unknown'}</p>
                            <p>Date: {new Date(session.startedAt).toLocaleString()}</p>
                            <p>Status: {session.status}</p>
                        </div>
                    </Card>

                    <Card>
                        <h2 className="text-lg font-semibold mb-2">Events</h2>
                        <div className="flex flex-col gap-2 overflow-y-auto max-h-[300px]">
                            {/* Mock events */}
                            {[10, 25, 40].map(time => (
                                <div
                                    key={time}
                                    className="p-2 bg-gray-800 rounded cursor-pointer hover:bg-gray-700"
                                    onClick={() => setCurrentTime(time)}
                                >
                                    <span className="text-xs text-primary">{time.toFixed(1)}s</span> Anomaly Detected
                                </div>
                            ))}
                        </div>
                    </Card>
                </div>
            </div>

            {/* Timeline Controls */}
            <Card className="p-4 flex flex-col gap-2">
                <input
                    type="range"
                    min="0"
                    max={duration}
                    step="0.1"
                    value={currentTime}
                    onChange={handleSeek}
                    className="w-full accent-primary"
                />

                <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                        <span className="text-xs font-mono">{currentTime.toFixed(1)}s / {duration.toFixed(1)}s</span>
                    </div>

                    <div className="flex items-center gap-4">
                        <Button variant="ghost" size="sm" onClick={() => setCurrentTime(Math.max(0, currentTime - 5))}>
                            <SkipBack size={16} />
                        </Button>
                        <Button
                            variant="primary"
                            onClick={() => setIsPlaying(!isPlaying)}
                            className="w-12 h-12 rounded-full p-0 flex items-center justify-center"
                        >
                            {isPlaying ? <Pause size={20} /> : <Play size={20} />}
                        </Button>
                        <Button variant="ghost" size="sm" onClick={() => setCurrentTime(Math.min(duration, currentTime + 5))}>
                            <SkipForward size={16} />
                        </Button>
                    </div>

                    <div className="flex items-center gap-2">
                        <select
                            className="bg-gray-800 border-none text-xs rounded p-1"
                            value={playbackSpeed}
                            onChange={(e) => setPlaybackSpeed(parseFloat(e.target.value))}
                        >
                            <option value="0.5">0.5x</option>
                            <option value="1">1x</option>
                            <option value="2">2x</option>
                            <option value="4">4x</option>
                        </select>
                    </div>
                </div>
            </Card>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\SystemConfig.tsx
```typescript
import { useState } from 'react';
import { Network, Activity, Crosshair } from 'lucide-react';
import { Button } from '../../components/ui/Button';
import { NodeTopology } from './components/NodeTopology';
import { SensorHealth } from './components/SensorHealth';
import { CalibrationWizard } from './components/CalibrationWizard';

type Tab = 'topology' | 'health' | 'calibration';

const SystemConfig = () => {
    const [activeTab, setActiveTab] = useState<Tab>('topology');

    return (
        <div className="space-y-6">
            {/* Top Bar Actions */}
            <div className="flex justify-between items-center bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
                <div className="flex gap-2">
                    <Button
                        variant={activeTab === 'topology' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('topology')}
                        className="gap-2"
                    >
                        <Network className="w-4 h-4" /> Node Topology
                    </Button>
                    <Button
                        variant={activeTab === 'health' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('health')}
                        className="gap-2"
                    >
                        <Activity className="w-4 h-4" /> Sensor Health
                    </Button>
                    <Button
                        variant={activeTab === 'calibration' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('calibration')}
                        className="gap-2"
                    >
                        <Crosshair className="w-4 h-4" /> Calibration
                    </Button>
                </div>
                <div className="flex gap-2">
                    <Button variant="secondary" size="sm">Export Config</Button>
                    <Button variant="primary" size="sm">Save Changes</Button>
                </div>
            </div>

            {/* Tab Content */}
            <div className="min-h-[600px]">
                {activeTab === 'topology' && <NodeTopology />}
                {activeTab === 'health' && <SensorHealth />}
                {activeTab === 'calibration' && <CalibrationWizard />}
            </div>
        </div>
    );
};

export default SystemConfig;

```

#### frontend\src\views\SystemConfig\components\CalibrationWizard.tsx
```typescript
import { useState, useEffect } from 'react';
import { Button } from '../../../components/ui/Button';
import { Camera, CheckCircle, RefreshCw, AlertTriangle } from 'lucide-react';

type Step = 'SELECT' | 'CAPTURE' | 'VERIFY' | 'COMPLETE';

export function CalibrationWizard() {
    const [step, setStep] = useState<Step>('SELECT');
    const [progress, setProgress] = useState(0);
    const [selectedNode, setSelectedNode] = useState<string | null>(null);

    // Simulate capture process
    useEffect(() => {
        if (step === 'CAPTURE') {
            const interval = setInterval(() => {
                setProgress(prev => {
                    if (prev >= 100) {
                        clearInterval(interval);
                        setStep('VERIFY');
                        return 100;
                    }
                    return prev + 2;
                });
            }, 50);
            return () => clearInterval(interval);
        }
    }, [step]);

    const reset = () => {
        setStep('SELECT');
        setProgress(0);
        setSelectedNode(null);
    };

    return (
        <div className="h-[500px] bg-navy-900 border border-navy-800 rounded-xl p-6 flex flex-col">
            <div className="mb-6">
                <h3 className="text-xl font-bold text-white mb-2">Sensor Calibration</h3>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <span className={step === 'SELECT' ? 'text-indigo-400 font-bold' : ''}>1. Select Node</span>
                    <span>→</span>
                    <span className={step === 'CAPTURE' ? 'text-indigo-400 font-bold' : ''}>2. Capture</span>
                    <span>→</span>
                    <span className={step === 'VERIFY' ? 'text-indigo-400 font-bold' : ''}>3. Verify</span>
                </div>
            </div>

            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-navy-700 rounded-xl bg-navy-800/30 p-8">
                {step === 'SELECT' && (
                    <div className="text-center space-y-4">
                        <div className="bg-navy-700 p-4 rounded-full inline-block">
                            <Camera className="w-8 h-8 text-indigo-400" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Select a Node to Calibrate</h4>
                        <div className="grid grid-cols-2 gap-3 w-full max-w-md">
                            {['Cam-01', 'Cam-02', 'Lidar-01', 'Lidar-02'].map(node => (
                                <button
                                    key={node}
                                    onClick={() => setSelectedNode(node)}
                                    className={`p-3 rounded border ${selectedNode === node ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node}
                                </button>
                            ))}
                        </div>
                        <Button
                            variant="primary"
                            disabled={!selectedNode}
                            onClick={() => setStep('CAPTURE')}
                        >
                            Start Calibration
                        </Button>
                    </div>
                )}

                {step === 'CAPTURE' && (
                    <div className="text-center space-y-6 w-full max-w-md">
                        <RefreshCw className="w-12 h-12 text-indigo-400 animate-spin mx-auto" />
                        <div>
                            <h4 className="text-lg font-medium text-white mb-1">Calibrating {selectedNode}...</h4>
                            <p className="text-sm text-slate-400">Capturing extrinsic parameters and aligning with point cloud.</p>
                        </div>
                        <div className="w-full bg-navy-950 rounded-full h-2.5 overflow-hidden">
                            <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-100" style={{ width: `${progress}%` }}></div>
                        </div>
                        <p className="text-xs text-slate-500 font-mono">{progress}% Complete</p>
                    </div>
                )}

                {step === 'VERIFY' && (
                    <div className="text-center space-y-4">
                        <AlertTriangle className="w-12 h-12 text-amber-400 mx-auto" />
                        <h4 className="text-lg font-medium text-white">Verification Required</h4>
                        <p className="text-sm text-slate-400 max-w-xs mx-auto">
                            The calculated transform has a reprojection error of <span className="text-white font-mono">0.04m</span>. This is within acceptable limits.
                        </p>
                        <div className="flex gap-3 justify-center">
                            <Button variant="secondary" onClick={reset}>Discard</Button>
                            <Button variant="primary" onClick={() => setStep('COMPLETE')}>Apply Transform</Button>
                        </div>
                    </div>
                )}

                {step === 'COMPLETE' && (
                    <div className="text-center space-y-4">
                        <div className="bg-emerald-500/10 p-4 rounded-full inline-block">
                            <CheckCircle className="w-12 h-12 text-emerald-500" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Calibration Successful</h4>
                        <p className="text-sm text-slate-400">Node {selectedNode} is now active and aligned.</p>
                        <Button variant="ghost" onClick={reset}>Calibrate Another Node</Button>
                    </div>
                )}
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\NodeTopology.tsx
```typescript
import { Plus } from 'lucide-react';
import { TopologyCanvas } from './TopologyCanvas';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const NODES = [
    { id: 'NODE_001', name: 'Gate B Cam 1', status: 'online', type: 'Camera' },
    { id: 'NODE_002', name: 'Gate B LIDAR', status: 'offline', type: 'LIDAR' },
    { id: 'NODE_003', name: 'Field Cam Main', status: 'online', type: 'Camera' },
];

export function NodeTopology() {
    return (
        <div className="flex flex-col lg:flex-row gap-6 h-[700px]">
            {/* Left Panel: Node List */}
            <div className="w-full lg:w-[300px] flex flex-col gap-4">
                <Card className="flex-1 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-white">Nodes</h3>
                        <Button size="icon" variant="ghost"><Plus className="w-4 h-4" /></Button>
                    </div>

                    <div className="space-y-3 flex-1 overflow-y-auto">
                        {NODES.map(node => (
                            <div key={node.id} className="p-3 bg-navy-900 rounded-lg border border-navy-700 hover:border-indigo-500 cursor-pointer transition-colors">
                                <div className="flex justify-between items-start mb-1">
                                    <div className="font-mono text-xs text-slate-500">{node.id}</div>
                                    <Badge variant={node.status === 'online' ? 'success' : 'critical'} size="sm" className="h-2 w-2 p-0 rounded-full"> </Badge>
                                </div>
                                <div className="font-bold text-sm text-slate-200">{node.name}</div>
                                <div className="text-xs text-indigo-400 mt-1">{node.type}</div>
                            </div>
                        ))}
                    </div>

                    <Button variant="secondary" fullWidth className="mt-4">Add New Node</Button>
                </Card>
            </div>

            {/* Right Panel: 3D View */}
            <div className="flex-1 bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden relative">
                <TopologyCanvas />
                <div className="absolute top-4 right-4 bg-navy-800/80 p-2 rounded text-xs text-slate-400">
                    <p>Left Click: Rotate</p>
                    <p>Right Click: Pan</p>
                    <p>Scroll: Zoom</p>
                </div>

                {/* Overlay Controls */}
                <div className="absolute top-4 right-4 bg-navy-800/80 backdrop-blur p-3 rounded-lg border border-navy-700 space-y-2">
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show Frustums
                    </label>
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show LIDAR
                    </label>
                </div>
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\SensorHealth.tsx
```typescript
import { Badge } from '../../../components/ui/Badge';

export function SensorHealth() {
    return (
        <div className="bg-navy-800 rounded-xl border border-navy-700 overflow-hidden">
            <table className="w-full text-left text-sm">
                <thead className="bg-navy-900 text-slate-400 font-medium">
                    <tr>
                        <th className="p-4">Node ID</th>
                        <th className="p-4">Sensor</th>
                        <th className="p-4">Status</th>
                        <th className="p-4">FPS (Target)</th>
                        <th className="p-4">Latency</th>
                        <th className="p-4">Last Update</th>
                        <th className="p-4 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-navy-700">
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_001</td>
                        <td className="p-4">Camera</td>
                        <td className="p-4"><Badge variant="success">ONLINE</Badge></td>
                        <td className="p-4">30/30</td>
                        <td className="p-4 text-green-400">12ms</td>
                        <td className="p-4 text-slate-400">Just now</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_002</td>
                        <td className="p-4">LIDAR</td>
                        <td className="p-4"><Badge variant="critical">OFFLINE</Badge></td>
                        <td className="p-4 text-red-400">0/10</td>
                        <td className="p-4 text-slate-500">--</td>
                        <td className="p-4 text-red-400">5m ago</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\TopologyCanvas.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Grid, Center, Text } from '@react-three/drei';

const Node = ({ position, color, label }: { position: [number, number, number], color: string, label: string }) => {
    return (
        <group position={position}>
            {/* Node visual */}
            <mesh>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* Frustum Visual (Cone) */}
            <mesh position={[0, 0, 2]} rotation={[Math.PI / 2, 0, 0]}>
                <coneGeometry args={[1, 4, 32, 1, true]} />
                <meshStandardMaterial color={color} wireframe opacity={0.3} transparent />
            </mesh>

            {/* Label */}
            <Text position={[0, 1.2, 0]} fontSize={0.5} color="white" anchorX="center" anchorY="middle">
                {label}
            </Text>
        </group>
    );
};

export function TopologyCanvas() {
    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden">
            <Canvas>
                <PerspectiveCamera makeDefault position={[10, 10, 10]} fov={50} />
                <OrbitControls makeDefault />

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} />

                <Grid infiniteGrid fadeDistance={50} sectionColor="#4f46e5" cellColor="#4f46e5" sectionSize={5} cellSize={1} />

                <Center>
                    <Node position={[0, 2, 0]} color="#10b981" label="Cam-01" />
                    <Node position={[-5, 2, 5]} color="#3b82f6" label="Lidar-01" />
                    <Node position={[5, 2, 5]} color="#3b82f6" label="Lidar-02" />
                </Center>
            </Canvas>
        </div>
    );
}

```

## 1. Root

#### deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting deployment for Motion Intelligence Grid..."

# 1. Build and Push Containers
Write-Host "Building and Pushing Containers..."
gcloud builds submit --config cloudbuild.yaml . --project $ProjectId

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# 2. Apply Terraform
Write-Host "Applying Terraform..."
cd infrastructure
terraform init
terraform apply -var="project_id=$ProjectId" -var="region=$Region" -auto-approve

if ($LASTEXITCODE -ne 0) {
    Write-Error "Terraform failed!"
    exit 1
}

Write-Host "Deployment Complete!"

```

#### cloudbuild.yaml
```yaml
steps:
  # Build API
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-api:latest', './server']
    
  # Build Simulation
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest', './simulation']
    
  # Build Frontend
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest', './frontend']

  # Push Images
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-api:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest']


options:
  machineType: 'N1_HIGHCPU_8'

```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # MongoDB database
  mongodb:
    image: mongo:6
    container_name: motiongrid-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: devpassword123
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - motiongrid-network
    command: --wiredTigerCacheSizeGB 1.5

  # Redis (optional, for caching)
  redis:
    image: redis:7-alpine
    container_name: motiongrid-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - motiongrid-network
    command: redis-server --appendonly yes

  # API Gateway (Node.js + Express + Socket.io)
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-api
    restart: unless-stopped
    environment:
      NODE_ENV: development
      PORT: 3001
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
      REDIS_URL: redis://redis:6379
      JWT_SECRET: dev-secret-key
      SIMULATION_API_URL: http://simulation:8000
    ports:
      - "3001:3001"
    volumes:
      - ./server/src:/app/src
    depends_on:
      - mongodb
      - redis
    networks:
      - motiongrid-network
    command: npm run dev

  # Simulation Engine (Python + FastAPI)
  simulation:
    build:
      context: ./simulation
      dockerfile: Dockerfile
    container_name: motiongrid-simulation
    restart: unless-stopped
    environment:
      PYTHONUNBUFFERED: 1
      API_PORT: 8000
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
    ports:
      - "8000:8000"
    volumes:
      - ./simulation/src:/app/src
    depends_on:
      - mongodb
    networks:
      - motiongrid-network
    command: uvicorn src.api.server:app --host 0.0.0.0 --port 8000 --reload

  # Frontend (React SPA)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_WS_URL: ws://localhost:3001
    ports:
      - "5173:5173"
    volumes:
      - ./frontend/src:/app/src
    networks:
      - motiongrid-network
    command: npm run dev

volumes:
  mongodb_data:
  redis_data:


networks:
  motiongrid-network:
    driver: bridge

```

#### .gcloudignore
```
node_modules/
.git/
.github/
infrastructure/.terraform/
.DS_Store
*.log
coverage/
dist/
tmp/
gcloud_temp/

```

## 2. Infrastructure

#### infrastructure\main.tf
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

resource "google_cloud_run_service" "api" {
  name     = "motiongrid-api"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-api:latest"
        ports {
            container_port = 3001
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "1Gi"
          }
        }
        env {
          name  = "NODE_ENV"
          value = "production"
        }
        env {
            name = "MONGODB_URI"
            value = var.mongodb_uri
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

resource "google_cloud_run_service" "simulation" {
  name     = "motiongrid-simulation"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-simulation:latest"
        ports {
            container_port = 8000
        }
        resources {
          limits = {
            cpu    = "2000m"
            memory = "2Gi"
          }
        }
        env {
            name = "MONGODB_URI"
            value = var.mongodb_uri
        }
      }
    }
  }
}

resource "google_cloud_run_service" "frontend" {
  name     = "motiongrid-frontend"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-frontend:latest"
        ports {
            container_port = 80
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        env {
            name = "VITE_API_URL"
            value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service_iam_member" "public_access_frontend" {
  service  = google_cloud_run_service.frontend.name
  location = google_cloud_run_service.frontend.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

# Storage Bucket for Session Recordings
resource "google_storage_bucket" "sessions" {
  name     = "${var.project_id}-sessions"
  location = var.region
  
  uniform_bucket_level_access = true
  
  lifecycle_rule {
    action { type = "Delete" }
    condition { age = 180 }  # Keep recordings 6 months
  }
}

resource "google_cloud_run_service_iam_member" "public_access_api" {
  service  = google_cloud_run_service.api.name
  location = google_cloud_run_service.api.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_simulation" {
  service  = google_cloud_run_service.simulation.name
  location = google_cloud_run_service.simulation.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "frontend_url" {
  value = google_cloud_run_service.frontend.status[0].url
}

```

#### infrastructure\variables.tf
```hcl
variable "project_id" {
  description = "GCP Project ID"
  type        = string
  default     = "freeforge-481415"
}

variable "region" {
  description = "GCP Region"
  type        = string
  default     = "us-central1"
}

variable "mongodb_uri" {
    description = "MongoDB Connection String"
    type = string
    sensitive = true
    default = "memory"
}

```

## 3. Server

#### server\Dockerfile
```
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

# Stage: Development/Build dependencies
FROM base AS deps
RUN npm install

# Stage: Production dependencies
FROM base AS production-deps
RUN npm install --only=production

# Stage: Development
FROM deps AS development
COPY . .
CMD ["npm", "run", "dev"]



# Stage: Production
FROM deps AS production
ENV NODE_ENV=production
COPY . .
EXPOSE 3001
CMD ["npx", "ts-node", "src/index.ts"]

```

#### server\package.json
```json
{
  "name": "motiongrid-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.2",
    "mongoose": "^8.0.3",
    "redis": "^4.6.11",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "axios": "^1.6.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/express": "^4.17.21",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "typescript": "^5.3.3",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11"
  }
}
```

#### server\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2016",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": false,
        "noImplicitAny": false,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts"
    ]
}
```

#### server\src\database.ts
```typescript
import mongoose from 'mongoose';

export const connectDB = async () => {
    try {
        if (!uri || uri === 'memory') {
            console.warn('⚠️ MONGODB_URI is missing or set to "memory". Database connection skipped. Application will run without persistence.');
            return;
        }

        await mongoose.connect(uri);
        console.log('MongoDB connected successfully');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        // Don't exit process, just log error for robustness in deployment
        console.warn('Continuing without database connection...');
    }
};

```

#### server\src\index.ts
```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import { connectDB } from './database';
import { socketService } from './services/SocketService';
import nodesRouter from './routes/nodes';
import sessionsRouter from './routes/sessions';
import anomaliesRouter from './routes/anomalies';
import entitiesRouter from './routes/entities';
import simulationRouter from './routes/simulation';
import analyticsRouter from './routes/analytics';


dotenv.config();

const app = express();
const httpServer = createServer(app);

// Initialize Socket.io via Service
socketService.initialize(httpServer);

app.use(helmet());
app.use(cors());
app.use(express.json());

// Register routes
app.use('/api/nodes', nodesRouter);
app.use('/api/sessions', sessionsRouter);
app.use('/api/anomalies', anomaliesRouter);
app.use('/api/entities', entitiesRouter);
app.use('/api/simulation', simulationRouter);
app.use('/api/analytics', analyticsRouter);

// Internal Endpoints for Simulation Bridge
// These allow the Python simulation to push updates to the Node.js WebSocket server

app.post('/internal/entity-update', (req, res) => {
    // Broadcast entity positions to all connected clients in the session room or global
    // Data flow: Simulation -> API (POST) -> Frontend (WS)
    const { sessionId, entities } = req.body;

    // In a real scenario, we might want to validate or store this state
    // For live view, we just emit immediately
    socketService.emit('entity:tracking', { entities }, sessionId ? `session:${sessionId}` : undefined);

    res.json({ status: 'ok' });
});

app.post('/internal/anomaly', async (req, res) => {
    // Broadcast detected anomalies
    const { sessionId, anomaly } = req.body;

    // In the future: Save to database here

    // Emit to frontend
    socketService.emit('anomaly:detected', anomaly, sessionId ? `session:${sessionId}` : undefined);

    res.json({ status: 'ok' });
});

// Basic health check
app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date() });
});



const PORT = process.env.PORT || 3001;

const startServer = async () => {
    try {
        await connectDB();
        httpServer.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
            console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
        });
    } catch (error) {
        console.error('Failed to start server:', error);
        process.exit(1);
    }
};

startServer();

```

#### server\src\middleware\validate.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

export const validateBody = (schema: Joi.Schema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({ error: error.details[0].message });
        }
        next();
    };
};

```

#### server\src\models\Anomaly.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IAnomaly extends Document {
    anomalyId: string;
    sessionId: mongoose.Types.ObjectId;
    entityIds: mongoose.Types.ObjectId[];
    nodeIds: string[];
    occurredAt: Date;
    duration: number;
    type: 'GEOGRAPHICS' | 'KINETICS' | 'PROXEMICS' | 'ATMOSPHERICS';
    subtype: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    scenario?: string;
    headline: string;
    description: string;
    baselineText: string;
    anomalyText: string;
    metrics: {
        baselineDelta: number;
        confidence: number;
        riskScore: number;
    };
    ruleOfThreeHit: boolean;
    relatedAnomalies: mongoose.Types.ObjectId[];
    zone: string;
    location: { x: number; y: number; z: number };
    triage: {
        status: 'UNREVIEWED' | 'CONFIRMED' | 'DOWNGRADED' | 'FALSE_POSITIVE';
        notes?: string;
    };
    tags: string[];
    createdAt: Date;
    updatedAt: Date;
}

const AnomalySchema: Schema = new Schema({
    anomalyId: { type: String, required: true, unique: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    entityIds: [{ type: Schema.Types.ObjectId, ref: 'Entity' }],
    nodeIds: [String],
    occurredAt: { type: Date, default: Date.now },
    duration: { type: Number, default: 0 },
    type: { type: String, enum: ['GEOGRAPHICS', 'KINETICS', 'PROXEMICS', 'ATMOSPHERICS'], required: true },
    subtype: String,
    severity: { type: String, enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'], default: 'LOW' },
    scenario: String,
    headline: String,
    description: String,
    baselineText: String,
    anomalyText: String,
    metrics: {
        baselineDelta: Number,
        confidence: Number,
        riskScore: Number
    },
    ruleOfThreeHit: { type: Boolean, default: false },
    relatedAnomalies: [{ type: Schema.Types.ObjectId, ref: 'Anomaly' }],
    zone: String,
    location: {
        x: Number,
        y: Number,
        z: Number
    },
    triage: {
        status: { type: String, enum: ['UNREVIEWED', 'CONFIRMED', 'DOWNGRADED', 'FALSE_POSITIVE'], default: 'UNREVIEWED' },
        notes: String
    },
    tags: [String]
}, { timestamps: true });

export const Anomaly = mongoose.model<IAnomaly>('Anomaly', AnomalySchema);

```

#### server\src\models\Entity.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IEntity extends Document {
    entityId: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    name?: string;
    lastPosition: { x: number; y: number; z: number };
    lastVelocity: { x: number; y: number; z: number };
    lastSeenAt: Date;
    sessionId?: string;
}

const EntitySchema: Schema = new Schema({
    entityId: { type: String, required: true, unique: true },
    type: { type: String, enum: ['PERSON', 'OBJECT'], required: true },
    role: { type: String, enum: ['PLAYER', 'OFFICIAL', 'SPECTATOR', 'BALL'], default: 'SPECTATOR' },
    team: { type: String, enum: ['HOME', 'AWAY'] },
    name: String,
    lastPosition: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastVelocity: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastSeenAt: { type: Date, default: Date.now },
    sessionId: String
}, { timestamps: true });

export const Entity = mongoose.model<IEntity>('Entity', EntitySchema);

```

#### server\src\models\Node.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INode extends Document {
    nodeId: string;
    name: string;
    type: 'EDGE_NODE';
    status: 'ONLINE' | 'OFFLINE' | 'DEGRADED';
    position: { x: number; y: number; z: number };
    orientation: { pitch: number; yaw: number; roll: number };
    sensors: {
        camera: {
            enabled: boolean;
            resolution: { width: number; height: number };
            fps: number;
            fov: number;
            exposure: number;
            gain: number;
        };
        lidar: {
            enabled: boolean;
            model: string;
            channels: number;
            pointsPerSecond: number;
            range: number;
            accuracy: number;
        };
        imu: {
            enabled: boolean;
            sampleRate: number;
            accelRange: number;
            gyroRange: number;
        };
    };
    calibration: {
        intrinsic: {
            cameraMatrix: number[][];
            distortion: number[];
        };
        extrinsic: {
            rotationMatrix: number[][];
            translationVector: number[];
        };
        lidarToCameraTransform: number[][];
        calibrationQuality: number;
        calibratedAt: Date;
    };
    network: {
        ipAddress: string;
        port: number;
        ptpDomain: number;
        clockOffset: number;
        lastSyncAt: Date;
    };
    sessionId?: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const NodeSchema: Schema = new Schema({
    nodeId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    type: { type: String, default: 'EDGE_NODE' },
    status: { type: String, enum: ['ONLINE', 'OFFLINE', 'DEGRADED'], default: 'OFFLINE' },
    position: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    orientation: {
        pitch: { type: Number, default: 0 },
        yaw: { type: Number, default: 0 },
        roll: { type: Number, default: 0 }
    },
    sensors: {
        camera: {
            enabled: { type: Boolean, default: true },
            resolution: {
                width: { type: Number, default: 1920 },
                height: { type: Number, default: 1080 }
            },
            fps: { type: Number, default: 30 },
            fov: { type: Number, default: 90 },
            exposure: { type: Number, default: 50 },
            gain: { type: Number, default: 0 }
        },
        lidar: {
            enabled: { type: Boolean, default: true },
            model: { type: String, default: 'VLP-16' },
            channels: { type: Number, default: 16 },
            pointsPerSecond: { type: Number, default: 300000 },
            range: { type: Number, default: 100 },
            accuracy: { type: Number, default: 0.03 }
        },
        imu: {
            enabled: { type: Boolean, default: true },
            sampleRate: { type: Number, default: 100 },
            accelRange: { type: Number, default: 16 },
            gyroRange: { type: Number, default: 2000 }
        }
    },
    calibration: {
        intrinsic: {
            cameraMatrix: [[Number]],
            distortion: [Number]
        },
        extrinsic: {
            rotationMatrix: [[Number]],
            translationVector: [Number]
        },
        lidarToCameraTransform: [[Number]],
        calibrationQuality: { type: Number, default: 0 },
        calibratedAt: Date
    },
    network: {
        ipAddress: String,
        port: Number,
        ptpDomain: { type: Number, default: 0 },
        clockOffset: { type: Number, default: 0 },
        lastSyncAt: Date
    },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session' }
}, { timestamps: true });

export const Node = mongoose.model<INode>('Node', NodeSchema);

```

#### server\src\models\SensorFrame.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISensorFrame extends Document {
    frameId: string;
    sessionId: mongoose.Types.ObjectId;
    nodeId: string;
    timestamp: Date;
    frameNumber: number;
    camera?: {
        imagePath: string;
        resolution: { width: number; height: number };
    };
    lidar?: {
        pointCloudPath: string;
        pointCount: number;
    };
    fusion?: {
        detectedEntities: any[];
        processingTime: number;
    };
    createdAt: Date;
}

const SensorFrameSchema: Schema = new Schema({
    frameId: { type: String, required: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    nodeId: { type: String, required: true },
    timestamp: { type: Date, required: true },
    frameNumber: Number,
    camera: {
        imagePath: String,
        resolution: { width: Number, height: Number }
    },
    lidar: {
        pointCloudPath: String,
        pointCount: Number
    },
    fusion: {
        detectedEntities: [],
        processingTime: Number
    }
}, {
    timeseries: {
        timeField: 'timestamp',
        metaField: 'nodeId',
        granularity: 'seconds'
    },
    expireAfterSeconds: 86400 * 7 // 7 days retention
});

export const SensorFrame = mongoose.model<ISensorFrame>('SensorFrame', SensorFrameSchema);

```

#### server\src\models\Session.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISession extends Document {
    sessionId: string;
    name: string;
    sport: 'BASKETBALL' | 'SOCCER' | 'COMBAT' | 'CUSTOM';
    venue: string;
    startedAt: Date;
    endedAt?: Date;
    duration: number;
    status: 'RECORDING' | 'STOPPED' | 'PROCESSING' | 'READY';
    nodeIds: string[];
    stats: {
        totalFrames: number;
        totalEntities: number;
        totalAnomalies: number;
        anomalyBreakdown: {
            critical: number;
            high: number;
            medium: number;
            low: number;
        };
        avgOccupancy: number;
        peakOccupancy: number;
        avgActivityIndex: number;
    };
    scenario: {
        entityCount: number;
        crowdDensity: number;
        anomalyRate: number;
        environmentConfig: {
            lighting: 'BRIGHT' | 'DIM' | 'VARIABLE';
            weather?: 'CLEAR' | 'RAIN' | 'SNOW';
        };
    };
    dataPath: string;
    thumbnailPath?: string;
    createdAt: Date;
    updatedAt: Date;
}

const SessionSchema: Schema = new Schema({
    sessionId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    sport: { type: String, enum: ['BASKETBALL', 'SOCCER', 'COMBAT', 'CUSTOM'], required: true },
    venue: String,
    startedAt: { type: Date, default: Date.now },
    endedAt: Date,
    duration: { type: Number, default: 0 },
    status: { type: String, enum: ['RECORDING', 'STOPPED', 'PROCESSING', 'READY'], default: 'RECORDING' },
    nodeIds: [String],
    stats: {
        totalFrames: { type: Number, default: 0 },
        totalEntities: { type: Number, default: 0 },
        totalAnomalies: { type: Number, default: 0 },
        anomalyBreakdown: {
            critical: { type: Number, default: 0 },
            high: { type: Number, default: 0 },
            medium: { type: Number, default: 0 },
            low: { type: Number, default: 0 }
        },
        avgOccupancy: { type: Number, default: 0 },
        peakOccupancy: { type: Number, default: 0 },
        avgActivityIndex: { type: Number, default: 0 }
    },
    scenario: {
        entityCount: { type: Number, default: 0 },
        crowdDensity: { type: Number, default: 0 },
        anomalyRate: { type: Number, default: 0 },
        environmentConfig: {
            lighting: { type: String, default: 'BRIGHT' },
            weather: String
        }
    },
    dataPath: String,
    thumbnailPath: String
}, { timestamps: true });

export const Session = mongoose.model<ISession>('Session', SessionSchema);

```

#### server\src\models\User.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
    username: string;
    email: string;
    passwordHash: string;
    role: 'OPERATOR' | 'ANALYST' | 'ADMIN';
    permissions: string[];
    preferences: {
        theme: 'DARK' | 'LIGHT';
    };
    createdAt: Date;
    updatedAt: Date;
}

const UserSchema: Schema = new Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['OPERATOR', 'ANALYST', 'ADMIN'], default: 'OPERATOR' },
    permissions: [String],
    preferences: {
        theme: { type: String, default: 'DARK' }
    }
}, { timestamps: true });

export const User = mongoose.model<IUser>('User', UserSchema);

```

#### server\src\routes\analytics.ts
```typescript
import express from 'express';

const router = express.Router();

router.get('/stats', (req, res) => {
    // Return aggregated stats
    res.json({
        totalAnomalies: 42,
        activeEntities: 15,
        systemHealth: 98.6,
        uptimeSeconds: 3600
    });
});

router.get('/performance', (req, res) => {
    // Return system performance metrics (FPS, Latency)
    res.json({
        simulationFps: 29.8,
        networkLatencyMs: 12,
        processingTimeMs: 4
    });
});

export default router;

```

#### server\src\routes\anomalies.ts
```typescript
import express from 'express';
import { Anomaly } from '../models/Anomaly';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, severity, status } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (severity) query.severity = severity;
        if (status) query['triage.status'] = status;

        const anomalies = await Anomaly.find(query).sort({ occurredAt: -1 }).limit(100);
        res.json({ anomalies, count: anomalies.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id/triage', async (req, res) => {
    try {
        const { status, notes } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            {
                'triage.status': status,
                'triage.notes': notes,
                'triage.triageAt': new Date()
            },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\entities.ts
```typescript
import express from 'express';
// In a real scenario, this might query the database or the simulation state
// For now, we'll return mock data or proxy to simulation if needed
const router = express.Router();

router.get('/', (req, res) => {
    // Return list of active entities
    // Could proxy to simulation: SimulationClient.getEntities()
    res.json([
        { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME' },
        { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY' }
    ]);
});

router.get('/:id/track', (req, res) => {
    const { id } = req.params;
    // Return history/track for entity
    res.json({
        entityId: id,
        path: []
    });
});

export default router;

```

#### server\src\routes\nodes.ts
```typescript
import express from 'express';
import { NodeService } from '../services/NodeService';

const router = express.Router();
const nodeService = new NodeService();

router.post('/', async (req, res) => {
    try {
        const node = await nodeService.createNode(req.body);
        res.status(201).json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const nodes = await nodeService.getNodes(req.query);
        res.json({ nodes, count: nodes.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const node = await nodeService.getNode(req.params.id);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
}
});

router.patch('/:id', async (req, res) => {
    try {
        const node = await nodeService.updateNode(req.params.id, req.body);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await nodeService.deleteNode(req.params.id);
        if (!success) return res.status(404).json({ error: 'Node not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\sessions.ts
```typescript
import express from 'express';
import { SessionService } from '../services/SessionService';

const router = express.Router();
const sessionService = new SessionService();

router.post('/', async (req, res) => {
    try {
        const session = await sessionService.createSession(req.body);
        res.status(201).json(session);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const sessions = await sessionService.getSessions(req.query);
        res.json({ sessions, count: sessions.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/start', async (req, res) => {
    try {
        const session = await sessionService.startSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/stop', async (req, res) => {
    try {
        const session = await sessionService.stopSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
}
});

router.patch('/:id', async (req, res) => {
    try {
        const session = await sessionService.updateSession(req.params.id, req.body);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json(session);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await sessionService.deleteSession(req.params.id);
        if (!success) return res.status(404).json({ error: 'Session not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\simulation.ts
```typescript
import express from 'express';
import { SimulationClient } from '../services/simulation_client';

const router = express.Router();

router.post('/start', async (req, res) => {
    const config = req.body;
    const success = await SimulationClient.startSimulation(config);
    if (success) {
        res.json({ message: 'Simulation started' });
    } else {
        res.status(500).json({ error: 'Failed to start simulation' });
    }
});

router.post('/stop', async (req, res) => {
    const success = await SimulationClient.stopSimulation();
    if (success) {
        res.json({ message: 'Simulation stopped' });
    } else {
        res.status(500).json({ error: 'Failed to stop simulation' });
    }
});

router.get('/status', async (req, res) => {
    const isHealthy = await SimulationClient.healthCheck();
    res.json({
        status: isHealthy ? 'running' : 'stopped',
        service: 'python-engine'
    });
});

export default router;

```

#### server\src\services\AnalyticsService.ts
```typescript
import { Session } from '../models/Session';
import { Anomaly } from '../models/Anomaly';

export class AnalyticsService {
    async getSessionStats(sessionId: string) {
        const session = await Session.findOne({ sessionId });
        if (!session) throw new Error('Session not found');

        const anomalyCount = await Anomaly.countDocuments({ sessionId: session._id });
        const criticalAnomalies = await Anomaly.countDocuments({ sessionId: session._id, severity: 'CRITICAL' });

        return {
            ...session.toJSON().stats,
            anomalyCount,
            criticalAnomalies
        };
    }

    async getGlobalStats() {
        const totalSessions = await Session.countDocuments();
        const totalAnomalies = await Anomaly.countDocuments();

        return {
            totalSessions,
            totalAnomalies,
            systemHealth: 'HEALTHY' // Placeholder
        };
    }
}

```

#### server\src\services\NodeService.ts
```typescript
import { Node, INode } from '../models/Node';

export class NodeService {
    async createNode(data: Partial<INode>): Promise<INode> {
        // Validation: Check if nodeId exists
        const existing = await Node.findOne({ nodeId: data.nodeId });
        if (existing) {
            throw new Error('Node ID already exists');
        }

        const node = new Node(data);
        return await node.save();
    }

    async getNodes(filter: any = {}): Promise<INode[]> {
        return await Node.find(filter);
    }

    async getNode(nodeId: string): Promise<INode | null> {
        return await Node.findOne({ nodeId });
    }

    async updateNode(nodeId: string, data: Partial<INode>): Promise<INode | null> {
        return await Node.findOneAndUpdate({ nodeId }, data, { new: true });
    }

    async deleteNode(nodeId: string): Promise<boolean> {
        const result = await Node.deleteOne({ nodeId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\SessionService.ts
```typescript
import { Session, ISession } from '../models/Session';
import mongoose from 'mongoose';

export class SessionService {
    async createSession(data: Partial<ISession>): Promise<ISession> {
        const session = new Session({
            ...data,
            sessionId: `SES_${Date.now()}`
        });
        return await session.save();
    }

    async getSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOne({ sessionId });
    }

    async getSessions(filter: any = {}): Promise<ISession[]> {
        return await Session.find(filter).sort({ createdAt: -1 });
    }

    async startSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'RECORDING',
                startedAt: new Date()
            },
            { new: true }
        );
    }

    async stopSession(sessionId: string): Promise<ISession | null> {
        const session = await Session.findOne({ sessionId });
        if (!session) return null;

        const endedAt = new Date();
        const duration = (endedAt.getTime() - session.startedAt.getTime()) / 1000;

        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'STOPPED',
                endedAt,
                duration
            },
            { new: true }
        );
    }


    async updateSession(sessionId: string, data: Partial<ISession>): Promise<ISession | null> {
        return await Session.findOneAndUpdate({ sessionId }, data, { new: true });
    }

    async deleteSession(sessionId: string): Promise<boolean> {
        const result = await Session.deleteOne({ sessionId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\simulation_client.ts
```typescript
import axios from 'axios';

const SIMULATION_API_URL = process.env.SIMULATION_API_URL || 'http://localhost:8000';

export class SimulationClient {

    static async healthCheck(): Promise<boolean> {
        try {
            const response = await axios.get(`${SIMULATION_API_URL}/health`);
            return response.data.status === 'ok';
        } catch (error) {
            console.error('Simulation API unhealthy:', error.message);
            return false;
        }
    }

    static async startSimulation(config: any): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/start`, config);
            return response.data.status === 'started';
        } catch (error) {
            console.error('Failed to start simulation:', error.message);
            return false;
        }
    }

    static async stopSimulation(): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/stop`);
            return response.data.status === 'stopped';
        } catch (error) {
            console.error('Failed to stop simulation:', error.message);
            return false;
        }
    }
}

```

#### server\src\services\SocketService.ts
```typescript
import { Server, Socket } from 'socket.io';

class SocketService {
    private io: Server | null = null;

    initialize(server: any) {
        this.io = new Server(server, {
            cors: {
                origin: "*", // Configure properly in production
                methods: ["GET", "POST"]
            }
        });

        this.io.on('connection', (socket: Socket) => {
            console.log('Client connected:', socket.id);

            socket.on('disconnect', () => {
                console.log('Client disconnected:', socket.id);
            });

            // Handle subscriptions
            socket.on('subscribe:session', (data) => {
                console.log(`Client ${socket.id} subscribed to session ${data.sessionId}`);
                socket.join(`session:${data.sessionId}`);
            });

            socket.on('subscribe:node', (data) => {
                console.log(`Client ${socket.id} subscribed to node ${data.nodeId}`);
                socket.join(`node:${data.nodeId}`);
            });
        });
    }

    emit(event: string, data: any, room?: string) {
        if (!this.io) {
            console.warn('SocketService not initialized');
            return;
        }

        if (room) {
            this.io.to(room).emit(event, data);
        } else {
            this.io.emit(event, data);
        }
    }
}

export const socketService = new SocketService();

```

#### server\src\__tests__\integration\session-flow.test.ts
```typescript
import request from 'supertest';
// Mocking app import since we might not export it correctly for testing in index.ts
// In a real setup, we'd export `app` from app.ts and import it in index.ts
// For now, pseudo-integration test or need to refactor index.ts
// Refactoring index.ts to export app is best practice.

describe('Session Flow Integration', () => {
    it('placeholder for integration test', async () => {
        expect(true).toBe(true);
    });
});

```

#### server\src\__tests__\services\NodeService.test.ts
```typescript
import { NodeService } from '../../services/NodeService';
import { Node } from '../../models/Node';

// Mock the Mongoose Model
jest.mock('../../models/Node');

describe('NodeService', () => {
    let nodeService: NodeService;

    beforeEach(() => {
        nodeService = new NodeService();
        jest.clearAllMocks();
    });

    it('should create a node successfully', async () => {
        const mockNodeData = {
            nodeId: 'TEST_001',
            name: 'Test Node',
            position: { x: 0, y: 0, z: 0 },
            status: 'active'
        };

        // Mock findOne to return null (not found)
        (Node.findOne as jest.Mock).mockResolvedValue(null);

        // Mock create
        (Node.create as jest.Mock).mockResolvedValue(mockNodeData);

        const result = await nodeService.createNode(mockNodeData);

        expect(Node.findOne).toHaveBeenCalledWith({ nodeId: 'TEST_001' });
        expect(Node.create).toHaveBeenCalledWith(mockNodeData);
        expect(result).toEqual(mockNodeData);
    });

    it('should throw error if node already exists', async () => {
        const mockNodeData = { nodeId: 'DUPLICATE_001', name: 'Dup' };

        // Mock findOne to return existing doc
        (Node.findOne as jest.Mock).mockResolvedValue({ nodeId: 'DUPLICATE_001' });

        await expect(nodeService.createNode(mockNodeData))
            .rejects
            .toThrow('Node with this ID already exists');
    });

    it('should get all nodes', async () => {
        const mockNodes = [{ nodeId: 'N1' }, { nodeId: 'N2' }];
        (Node.find as jest.Mock).mockResolvedValue(mockNodes);

        const result = await nodeService.getAllNodes();

        expect(Node.find).toHaveBeenCalled();
        expect(result).toHaveLength(2);
    });
});

```

## 4. Simulation

#### simulation\Dockerfile
```
FROM python:3.10-slim AS base

WORKDIR /app

# System dependencies removed as we use opencv-headless

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM base AS development
COPY . .
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

FROM base AS production
COPY src ./src
ENV PYTHONUNBUFFERED=1
EXPOSE 8000
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]

```

#### simulation\requirements.txt
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
numpy==1.24.3
scipy==1.11.4
opencv-python-headless==4.8.1.78
open3d==0.17.0
pymongo==4.6.0
motor==3.3.2
python-dateutil==2.8.2
pytz==2023.3

```

#### simulation\src\anomalies\detector.py
```python
from typing import List

class AnomalyDetector:
    def detect(self, entities: List[dict]) -> List[dict]:
        anomalies = []
        
        # 1. Check Crowd Compression
        # Radius check -> if many entities in small area
        
        # 2. Check Speed
        for e in entities:
             if abs(e.get('velocity', {}).get('x', 0)) > 10: # >10m/s
                 anomalies.append({
                     'id': f"SPEED_{e['id']}",
                     'type': 'KINETICS',
                     'headline': f"High Speed Detected: {e['id']}",
                     'severity': 'MEDIUM'
                 })
                 
        return anomalies

```

#### simulation\src\anomalies\generator.py
```python
import numpy as np
from typing import List, Dict, Optional
import uuid
from datetime import datetime

class AnomalyGenerator:
    """
    Generates realistic anomalies based on entity behavior and scenario context.
    """
    
    def __init__(self):
        self.baselines = {}  # Zone -> baseline metrics
        self.anomaly_rate = 2.0  # anomalies per minute (configurable)
        self.last_anomaly_time = 0
        self.min_anomaly_interval = 5.0  # seconds between anomalies
        
    def detect(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """
        Check for anomalies based on entity behavior.
        Returns list of anomaly dicts.
        """
        anomalies = []
        
        # Update baselines
        self._update_baselines(entities, scenario)
        
        # 1. Crowd Compression (Geographics + Proxemics)
        for zone in scenario.zones:
            compression = self._check_crowd_compression(entities, zone, timestamp)
            if compression:
                anomalies.append(compression)
        
        # 2. Speed Violations (Kinetics)
        speed_anomalies = self._check_speed_anomalies(entities, timestamp)
        anomalies.extend(speed_anomalies)
        
        # 3. Loitering (Atmospherics)
        loitering = self._check_loitering(entities, timestamp)
        anomalies.extend(loitering)
        
        # 4. Restricted Zone Entry (Geographics)
        trespass = self._check_restricted_zones(entities, scenario, timestamp)
        anomalies.extend(trespass)
        
        # Apply Rule of Three
        anomalies = self._apply_rule_of_three(anomalies, timestamp)
        
        return anomalies
    
    def _check_crowd_compression(self, entities: List[Dict], zone, timestamp: float) -> Optional[Dict]:
        """Detect crowd compression/crush risk."""
        # Filter entities in this zone
        entities_in_zone = [
            e for e in entities 
            if self._entity_in_zone(e, zone)
        ]
        
        if not entities_in_zone:
            return None
        
        # Calculate density
        area = zone.area
        density = len(entities_in_zone) / area
        
        # Get baseline
        baseline_key = f"{zone.name}_density"
        baseline_density = self.baselines.get(baseline_key, 0.5)
        
        # Threshold: 2.5× baseline or >4 people/m² (crowd crush risk)
        threshold = max(baseline_density * 2.5, 4.0)
        
        if density > threshold:
            severity = 'CRITICAL' if density > 6.0 else 'HIGH'
            
            return {
                'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                'type': 'GEOGRAPHICS',
                'subtype': 'CROWD_COMPRESSION',
                'severity': severity,
                'scenario': 'CRUSH',
                'headline': f'{zone.name} Crowd Compression Risk',
                'description': f'Density {density:.1f} people/m², {density/baseline_density:.1f}× baseline',
                'baselineText': f'Normal density: {baseline_density:.1f} people/m²',
                'anomalyText': f'Current density: {density:.1f} people/m² ({len(entities_in_zone)} in {area:.0f}m²)',
                'zone': zone.name,
                'location': zone.center if hasattr(zone, 'center') else {'x': 0, 'y': 0, 'z': 0},
                'entityIds': [e['id'] for e in entities_in_zone],
                'metrics': {
                    'baselineDelta': ((density / baseline_density) - 1) * 100,
                    'confidence': 0.95,
                    'riskScore': min(density * 15, 100)
                },
                'occurredAt': datetime.fromtimestamp(timestamp),
                'ruleOfThreeHit': False
            }
        
        return None
    
    def _check_speed_anomalies(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect excessive speed violations."""
        anomalies = []
        
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            vel = entity.get('velocity', {'x': 0, 'y': 0, 'z': 0})
            speed = np.sqrt(vel['x']**2 + vel['y']**2)  # Horizontal speed
            
            # Thresholds based on role
            role = entity.get('role', 'SPECTATOR')
            if role == 'PLAYER':
                max_speed = 10.0  # m/s (fast sprinting)
            elif role == 'OFFICIAL':
                max_speed = 5.0   # m/s
            else:
                max_speed = 2.0   # m/s (walking speed for spectators)
            
            if speed > max_speed * 1.5:  # 1.5× threshold
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'KINETICS',
                    'subtype': 'SPEED_VIOLATION',
                    'severity': 'MEDIUM',
                    'headline': f'Excessive Speed: {entity["id"]}',
                    'description': f'Entity moving at {speed:.1f} m/s, {(speed/max_speed):.1f}× expected',
                    'baselineText': f'Expected max speed: {max_speed:.1f} m/s for {role}',
                    'anomalyText': f'Current speed: {speed:.1f} m/s',
                    'zone': 'UNKNOWN',  # TODO: Determine zone from position
                    'location': entity['position'],
                    'entityIds': [entity['id']],
                    'metrics': {
                        'baselineDelta': ((speed / max_speed) - 1) * 100,
                        'confidence': 0.88,
                        'riskScore': min(speed * 8, 100)
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp),
                    'ruleOfThreeHit': False
                })
        
        return anomalies
    
    def _check_loitering(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect loitering patterns (entities moving very slowly in same area)."""
        # TODO: Implement with entity history tracking
        return []
    
    def _check_restricted_zones(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """Detect entities entering restricted zones."""
        anomalies = []
        
        restricted_zones = [z for z in scenario.zones if z.type == 'RESTRICTED']
        
        for zone in restricted_zones:
            for entity in entities:
                if entity.get('role') == 'PLAYER':
                    continue  # Players allowed in restricted zones
                    
                if self._entity_in_zone(entity, zone):
                    anomalies.append({
                        'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                        'type': 'GEOGRAPHICS',
                        'subtype': 'RESTRICTED_ZONE_ENTRY',
                        'severity': 'HIGH',
                        'headline': f'Unauthorized Entry: {zone.name}',
                        'description': f'{entity["id"]} entered restricted zone',
                        'baselineText': f'Zone {zone.name} is restricted',
                        'anomalyText': f'{entity["role"]} entity detected in zone',
                        'zone': zone.name,
                        'location': entity['position'],
                        'entityIds': [entity['id']],
                        'metrics': {
                            'baselineDelta': 100,
                            'confidence': 0.92,
                            'riskScore': 75
                        },
                        'occurredAt': datetime.fromtimestamp(timestamp),
                        'ruleOfThreeHit': False
                    })
        
        return anomalies
    
    def _apply_rule_of_three(self, anomalies: List[Dict], timestamp: float) -> List[Dict]:
        """
        Apply Rule of Three: flag when 3+ independent anomaly types
        converge in same space-time.
        """
        # Group anomalies by proximity
        spatial_threshold = 10.0  # meters
        temporal_threshold = 30.0  # seconds
        
        groups = []
        for anomaly in anomalies:
            placed = False
            for group in groups:
                # Check if anomaly belongs to this group
                representative = group[0]
                
                # Spatial proximity
                loc1 = anomaly['location']
                loc2 = representative['location']
                dist = np.sqrt(
                    (loc1['x'] - loc2['x'])**2 + 
                    (loc1['y'] - loc2['y'])**2
                )
                
                # Temporal proximity
                time_diff = abs(
                    anomaly['occurredAt'].timestamp() - 
                    representative['occurredAt'].timestamp()
                )
                
                if dist < spatial_threshold and time_diff < temporal_threshold:
                    group.append(anomaly)
                    placed = True
                    break
            
            if not placed:
                groups.append([anomaly])
        
        # Check each group for Rule of Three
        for group in groups:
            distinct_types = set(a['type'] for a in group)
            
            if len(distinct_types) >= 3:
                # Mark all anomalies in group
                for anomaly in group:
                    anomaly['ruleOfThreeHit'] = True
                    anomaly['severity'] = 'CRITICAL'  # Escalate
                    anomaly['relatedAnomalies'] = [
                        a['anomalyId'] for a in group if a != anomaly
                    ]
        
        return anomalies
    
    def _update_baselines(self, entities: List[Dict], scenario):
        """Update baseline metrics using exponential moving average."""
        # TODO: Implement proper baseline learning
        # For now, use static baselines
        for zone in scenario.zones:
            baseline_key = f"{zone.name}_density"
            if baseline_key not in self.baselines:
                self.baselines[baseline_key] = 1.0  # 1 person/m² default
    
    def _entity_in_zone(self, entity: Dict, zone) -> bool:
        """Check if entity is inside zone bounds."""
        pos = entity['position']
        bounds = zone.bounds  # (x_min, y_min, x_max, y_max)
        
        return (
            bounds[0] <= pos['x'] <= bounds[2] and
            bounds[1] <= pos['y'] <= bounds[3]
        )

```

#### simulation\src\api\server.py
```python
from fastapi import FastAPI
from contextlib import asynccontextmanager
import os
import uvicorn

from .core.orchestrator import SimulationOrchestrator

orchestrator = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global orchestrator
    # Initialize with default config
    orchestrator = SimulationOrchestrator({})
    print("Simulation Engine Starting...")
    yield
    # Shutdown
    if orchestrator:
        orchestrator.stop()
    print("Simulation Engine Stopping...")

app = FastAPI(lifespan=lifespan)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "simulation-engine"}

@app.post("/simulation/start")
async def start_simulation(config: dict):
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.load_scenario(config.get('sport', 'BASKETBALL'), config)
    orchestrator.start()
    return {"status": "started"}

@app.post("/simulation/stop")
async def stop_simulation():
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.stop()
    return {"status": "stopped"}

@app.get("/")
async def root():
    return {"message": "Motion Intelligence Simulation Engine v1.0"}

if __name__ == "__main__":
    uvicorn.run("src.api.server:app", host="0.0.0.0", port=8000, reload=True)

```

#### simulation\src\calibration\utils.py
```python
import numpy as np

def generate_default_calibration():
    # Intrinsic (Camera)
    # 1920x1080, FOV ~90 deg
    fx = 1000
    fy = 1000
    cx = 960
    cy = 540
    camera_matrix = [
        [fx, 0, cx],
        [0, fy, cy],
        [0, 0, 1]
    ]
    
    # Extrinsic (Identity for now)
    rotation = np.eye(3).tolist()
    translation = [0, 0, 0]
    
    # Lidar to Camera (Example: Camera is 10cm above LIDAR)
    lidar_to_camera = np.eye(4)
    lidar_to_camera[1, 3] = -0.1 # y-axis translation
    
    return {
        'intrinsic': {
            'cameraMatrix': camera_matrix,
            'distortion': [0, 0, 0, 0, 0]
        },
        'extrinsic': {
            'rotationMatrix': rotation,
            'translationVector': translation
        },
        'lidarToCameraTransform': lidar_to_camera.tolist(),
        'calibrationQuality': 100,
        'calibratedAt': '2025-12-16T12:00:00Z'
    }

```

#### simulation\src\core\orchestrator.py
```python
import os
import time
import threading
from typing import List, Optional, Dict
import numpy as np

from .physics_engine import PhysicsEngine
from .scenario_manager import ScenarioManager
from ..nodes.edge_node import EdgeNode
from ..anomalies.generator import AnomalyGenerator
from ..utils.ptp_sync import PTPClock

class SimulationOrchestrator:
    def __init__(self, config: dict):
        self.config = config
        self.running = False
        self.paused = False
        self.thread = None
        
        # Core components
        self.physics_engine = PhysicsEngine()
        self.scenario = None
        self.anomaly_generator = AnomalyGenerator()
        self.clock = PTPClock(is_master=True)
        
        # State
        self.nodes: List[EdgeNode] = []
        self.entities: List[Dict] = []
        self.current_time = 0.0
        self.frame_count = 0
        self.target_fps = 30
        self.actual_fps = 0.0
        
    def load_scenario(self, sport: str, config: dict):
        """Load sport-specific scenario."""
        self.scenario = ScenarioManager.create_scenario(sport, config)
        self.scenario.initialize(self.entities)
        print(f"Loaded scenario: {sport} with {len(self.entities)} entities")
        
    def add_node(self, node_config: dict) -> EdgeNode:
        """Add a sensor node to the simulation."""
        node = EdgeNode(
            node_id=node_config['nodeId'],
            position=np.array([
                node_config['position']['x'],
                node_config['position']['y'],
                node_config['position']['z']
            ]),
            orientation=np.array([
                node_config['orientation']['pitch'],
                node_config['orientation']['yaw'],
                node_config['orientation']['roll']
            ]),
            sensors=node_config['sensors'],
            calibration=node_config.get('calibration', {})
        )
        self.nodes.append(node)
        print(f"Added node: {node_config['nodeId']}")
        return node
        
    def start(self):
        """Start the simulation loop."""
        if self.running:
            return
            
        if not self.scenario:
            # Fallback for empty start
            try:
                self.load_scenario('BASKETBALL', {})
            except:
                print("Failed to load default scenario")
            
        self.running = True
        self.paused = False
        self.thread = threading.Thread(target=self._loop, daemon=True)
        self.thread.start()
        print("Simulation started")
        
    def stop(self):
        """Stop the simulation."""
        self.running = False
        if self.thread:
            self.thread.join()
        print("Simulation stopped")
        
    def pause(self):
        """Pause the simulation."""
        self.paused = True
        
    def resume(self):
        """Resume the simulation."""
        self.paused = False
        
    def _loop(self):
        """Main simulation loop - runs at 30 FPS."""
        target_dt = 1.0 / self.target_fps
        last_fps_check = time.time()
        fps_frame_count = 0
        
        while self.running:
            if self.paused:
                time.sleep(0.1)
                continue
                
            loop_start = time.time()
            
            # 1. Update simulation time (PTP clock)
            self.current_time = self.clock.get_time() / 1e9  # Convert ns to seconds
            
            # 2. Update entity behaviors (scenario-specific)
            if self.scenario:
                self.scenario.update(self.entities, target_dt)
            
            # 3. Update physics (entity movement)
            self.physics_engine.step(self.entities, target_dt)
            
            # 4. Generate sensor data from all nodes
            # For this MVP, we just generate generating logs or frames
            # Logic to publish via WebSocket would go here
            """
            for node in self.nodes:
                frame = node.generate_frame(
                    entities=self.entities,
                    timestamp=self.current_time
                )
                self._publish_frame(frame)
            """
            
            # 5. Detect anomalies
            if self.scenario:
                anomalies = self.anomaly_generator.detect(
                    entities=self.entities,
                    scenario=self.scenario,
                    timestamp=self.current_time
                )
                for anomaly in anomalies:
                    self._publish_anomaly(anomaly)
            
            # 6. Update frame counter
            self.frame_count += 1
            fps_frame_count += 1
            
            # 7. Calculate actual FPS every second
            now = time.time()
            if now - last_fps_check >= 1.0:
                self.actual_fps = fps_frame_count / (now - last_fps_check)
                fps_frame_count = 0
                last_fps_check = now
                # print(f"Simulation FPS: {self.actual_fps:.1f} | Entities: {len(self.entities)}")
            
            # 8. Sleep to maintain frame rate
            elapsed = time.time() - loop_start
            if elapsed < target_dt:
                time.sleep(target_dt - elapsed)
                
            # Broadcast updates (Every 3 frames approx 10Hz)
            if self.frame_count % 3 == 0:
                self._publish_entities()

    def _publish_entities(self):
        """Send entity positions to API."""
        try:
            # Basic validation
            if not self.entities:
                return

            payload = {
                'sessionId': None, # TODO: Pass session ID if managed
                'entities': [
                    {
                        'id': e.get('id'),
                        'type': e.get('type'),
                        'role': e.get('role'),
                        'team': e.get('team'),
                        'position': e.get('position'),
                        'velocity': e.get('velocity'),
                        'color': e.get('color'),
                        'radius': e.get('radius')
                    }
                    for e in self.entities
                ]
            }
            
            # Fire and forget POST
            # Using threads or async here would be better for performance, 
            # but for this simulation loop strictness, a short timeout is acceptable logic 
            # if we assume local network.
            try:
                import requests
                requests.post(
                    f"{os.getenv('API_URL', 'http://api:3001')}/internal/entity-update",
                    json=payload,
                    timeout=0.05 
                )
            except ImportError:
                print("requests module not found")
            except Exception:
                pass # Suppress connection errors to avoid crashing sim
                
        except Exception as e:
            print(f"Error publishing entities: {e}")

    def _publish_anomaly(self, anomaly):
        """Publish detected anomaly."""
        try:
            import requests
            requests.post(
                f"{os.getenv('API_URL', 'http://api:3001')}/internal/anomaly",
                json={
                    'sessionId': None,
                    'anomaly': anomaly
                },
                timeout=0.1
            )
        except Exception as e:
            print(f"Failed to publish anomaly: {e}")



```

#### simulation\src\core\physics_engine.py
```python
import numpy as np
from typing import List

class PhysicsEngine:
    def __init__(self):
        self.gravity = -9.81
        self.friction_coeff = 0.5

    def step(self, entities: List[dict], dt: float):
        """
        Update entity positions based on velocity and forces.
        """
        for entity in entities:
            # Simple Euler integration
            vel = np.array(entity.get('velocity', [0, 0, 0]), dtype=float)
            pos = np.array(entity.get('position', [0, 0, 0]), dtype=float)
            
            # Apply friction (damping)
            vel = vel * (1.0 - self.friction_coeff * dt)
            
            # Update position
            pos += vel * dt
            
            # Floor constraint (z >= 0)
            if pos[2] < 0:
                pos[2] = 0
                vel[2] = 0
            
            # Update entity state
            entity['position'] = {
                'x': float(pos[0]),
                'y': float(pos[1]),
                'z': float(pos[2])
            }
            entity['velocity'] = {
                'x': float(vel[0]),
                'y': float(vel[1]),
                'z': float(vel[2])
            }

```

#### simulation\src\core\scenario_manager.py
```python
from typing import List, Dict, Optional
import numpy as np

class Zone:
    def __init__(self, name: str, bounds: tuple, area: float, type: str):
        self.name = name
        self.bounds = bounds # (x_min, y_min, x_max, y_max)
        self.area = area
        self.type = type
        self.center = {
            'x': (bounds[0] + bounds[2]) / 2,
            'y': (bounds[1] + bounds[3]) / 2,
            'z': 0
        }

class Scenario:
    def __init__(self):
        self.zones: List[Zone] = []
        self.entities: List[dict] = []
        self.sport = 'UNKNOWN'

    def initialize(self, entities: List[dict]):
        """Populate initial entities"""
        pass

    def update(self, entities: List[dict], dt: float):
        """Update entity behaviors"""
        pass

class ScenarioManager:
    @staticmethod
    def create_scenario(sport: str, config: dict) -> Scenario:
        if sport == 'BASKETBALL':
            from ..sports.basketball import BasketballScenario
            return BasketballScenario(config)
        else:
            raise ValueError(f"Unknown sport: {sport}")

```

#### simulation\src\nodes\camera_simulator.py
```python
import numpy as np
import cv2
import time
from typing import List, Tuple

class CameraSimulator:
    def __init__(self, resolution: dict, fps: int, fov: float):
        self.width = resolution['width']
        self.height = resolution['height']
        self.fps = fps
        self.fov = fov
        self.last_frame_time = 0
        self.frame_interval = 1.0 / fps

    def render(self, entities: List[dict], timestamp: float) -> Optional[bytes]:
        """
        Render a frame if enough time has passed.
        Returns JPEG bytes or None.
        """
        # Simple frame rate control
        if timestamp - self.last_frame_time < self.frame_interval:
            return None
            
        self.last_frame_time = timestamp
        
        # Create blank image (dark gray background)
        image = np.full((self.height, self.width, 3), 30, dtype=np.uint8)
        
        # Draw entities (simplified 2D projection for now)
        for entity in entities:
             # Basic projection logic (placeholder)
             # In a real 3D sim, we'd use a projection matrix
             pos = entity.get('position', {'x':0, 'y':0, 'z':0})
             
             # Map x/y to screen coordinates (very rough approx)
             cx = int(self.width / 2 + pos['x'] * 50) 
             cy = int(self.height / 2 + pos['y'] * 50)
             
             if 0 <= cx < self.width and 0 <= cy < self.height:
                 cv2.circle(image, (cx, cy), 10, (0, 255, 0), -1)
                 cv2.putText(image, entity.get('id', '?'), (cx+15, cy), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        # Add noise
        noise = np.random.normal(0, 5, image.shape).astype(np.uint8)
        image = cv2.add(image, noise)
        
        # Encode to JPEG
        _, encoded = cv2.imencode('.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 80])
        return encoded.tobytes()

```

#### simulation\src\nodes\edge_node.py
```python
from typing import List, Dict, Any
import numpy as np
from .camera_simulator import CameraSimulator
from .lidar_simulator import LidarSimulator
from .imu_simulator import ImuSimulator

class EdgeNode:
    def __init__(self, node_id: str, position: np.ndarray, orientation: np.ndarray, sensors: dict, calibration: dict):
        self.node_id = node_id
        self.position = position
        self.orientation = orientation
        self.calibration = calibration
        
        # Initialize Sensors
        self.camera = None
        if sensors.get('camera', {}).get('enabled'):
            cam_config = sensors['camera']
            self.camera = CameraSimulator(
                resolution=cam_config.get('resolution', {'width': 1920, 'height': 1080}),
                fps=cam_config.get('fps', 30),
                fov=cam_config.get('fov', 90)
            )
            
        self.lidar = None
        if sensors.get('lidar', {}).get('enabled'):
            lid_config = sensors['lidar']
            self.lidar = LidarSimulator(
                model=lid_config.get('model', 'VLP-16'),
                channels=lid_config.get('channels', 16),
                range_m=lid_config.get('range', 100)
            )
            
        self.imu = None
        if sensors.get('imu', {}).get('enabled'):
            self.imu = ImuSimulator(
                sample_rate=sensors['imu'].get('sampleRate', 100)
            )

    def generate_frame(self, entities: List[dict], timestamp: float) -> Dict[str, Any]:
        """Generate a synchronized frame from all enabled sensors."""
        frame = {
            'nodeId': self.node_id,
            'timestamp': timestamp,
            'sensors': {}
        }
        
        # Transform entities to node-local coordinates if needed
        # For now, simulators handle global entities
        
        if self.camera:
            image_data = self.camera.render(entities, timestamp)
            if image_data:
                frame['sensors']['camera'] = image_data # In real app, this would be a path or heavy blob
        
        if self.lidar:
            point_cloud = self.lidar.scan(entities, timestamp)
            frame['sensors']['lidar'] = point_cloud # Numpy array
            
        if self.imu:
            imu_data = self.imu.read(timestamp, self.position) # Simplified IMU read
            frame['sensors']['imu'] = imu_data
            
        return frame

```

#### simulation\src\nodes\fusion_engine.py
```python
import numpy as np
from typing import List, Dict

class FusionEngine:
    """
    Fuses camera + LIDAR data at edge node.
    Core learning objective: demonstrates sensor fusion concepts.
    """
    
    def __init__(self, camera_matrix=None, lidar_to_camera_transform=None):
        # Defaults if not provided
        self.camera_matrix = camera_matrix if camera_matrix is not None else np.eye(3)
        self.transform = lidar_to_camera_transform if lidar_to_camera_transform is not None else np.eye(4)
        
    def fuse(self, camera_image, lidar_points, entities):
        """
        Perform early fusion of camera and LIDAR data.
        Returns: List of detected entities with 3D positions.
        """
        detections = []
        
        # 1. Project LIDAR points to camera image (Simulated)
        if len(lidar_points) > 0:
            projected_points = self._project_lidar_to_image(lidar_points)
        else:
            projected_points = np.array([])
        
        # 2. Run 2D object detection on camera (simulated YOLO)
        bboxes = self._detect_objects_2d(camera_image, entities)
        
        # 3. Cluster LIDAR points within each bbox
        for bbox in bboxes:
            # Logic: If we had real points, we'd filter them here.
            # For simulation, we cheat and use the entity's true position + noise
            # but structurally this represents the fusion pipeline.
            
            # 4. Estimate 3D position (Simulated fusion result)
            # In a real engine we'd use np.mean(points_in_bbox)
            
            detections.append({
                'entityId': bbox['entity_id'],
                'position3d': [0, 0, 0], # Placeholder, would be calculated from points
                'velocity': [0, 0, 0],
                'confidence': 0.9,
                'bbox2d': bbox['bbox']
            })
        
        return detections
    
    def _project_lidar_to_image(self, points):
        """Project 3D LIDAR points to 2D camera coordinates."""
        # Simple pinhole projection
        return points[:, :2] # Dummy projection
    
    def _detect_objects_2d(self, image, entities):
        """Simulate YOLO detection - project known entities to image."""
        bboxes = []
        for entity in entities:
            # Project entity position to image
            pos_3d = np.array([
                entity['position']['x'],
                entity['position']['y'],
                entity['position']['z'] + entity.get('height', 1.7) / 2
            ])
            
            # Create mock bbox
            # In reality: multiply by ViewProjection matrix
            x_2d, y_2d = pos_3d[0], pos_3d[1] 
            
            radius = 50  # pixels
            bboxes.append({
                'entity_id': entity['id'],
                'bbox': [x_2d - radius, y_2d - radius, x_2d + radius, y_2d + radius],
                'confidence': 0.95
            })
        
        return bboxes

```

#### simulation\src\nodes\imu_simulator.py
```python
import numpy as np

class IMUSimulator:
    def __init__(self, sample_rate: int):
        self.sample_rate = sample_rate
        self.accel_bias = np.random.normal(0, 0.01, 3)
        self.gyro_bias = np.random.normal(0, 0.001, 3)

    def sample(self, timestamp: float, motion: dict) -> dict:
        """
        Generate IMU reading based on actual motion.
        """
        true_accel = motion.get('acceleration', np.zeros(3))
        true_gyro = motion.get('angular_velocity', np.zeros(3))
        
        # Add noise and bias
        accel_noise = np.random.normal(0, 0.01, 3)
        gyro_noise = np.random.normal(0, 0.001, 3)
        
        accel = true_accel + self.accel_bias + accel_noise
        gyro = true_gyro + self.gyro_bias + gyro_noise
        
        # Add gravity (assuming z is up)
        accel[2] += 9.81
        
        return {
            'acceleration': accel.tolist(),
            'gyroscope': gyro.tolist(),
            'temperature': 45.0 + np.random.normal(0, 0.1)
        }

```

#### simulation\src\nodes\lidar_simulator.py
```python
import numpy as np
from typing import List, Tuple

class LidarSimulator:
    def __init__(self, model: str, channels: int, range_m: float):
        self.model = model
        self.channels = channels
        self.range = range_m
        self.points_per_second = 300000

    def scan(self, entities: List[dict], timestamp: float) -> np.ndarray:
        """
        Generate a point cloud.
        Returns numpy array of (x, y, z, intensity).
        """
        # Generate background points (ground plane)
        # Simplified: Grid of points
        x = np.linspace(-20, 20, 100)
        y = np.linspace(-20, 20, 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X) # Ground is at z=0
        
        # Flatten
        ground_points = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1)
        
        entity_points = []
        for entity in entities:
            pos = entity.get('position', {'x':0, 'y':0, 'z':0})
            # Generate a cluster of points for the entity
            num_points = 50
            # Gaussian distribution around entity position
            ep = np.random.normal([pos['x'], pos['y'], pos['z']], 0.2, (num_points, 3))
            entity_points.append(ep)
            
        if entity_points:
            all_entity_points = np.vstack(entity_points)
            points = np.vstack([ground_points, all_entity_points])
        else:
            points = ground_points

        # Add intensity (random for now)
        intensities = np.random.rand(len(points), 1)
        
        return np.hstack([points, intensities]).astype(np.float32)

```

#### simulation\src\sports\basketball.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class BasketballScenario(Scenario):
    """NBA-style basketball simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'BASKETBALL'
        
        # Court dimensions (NBA standard in meters)
        self.court_length = 28.65
        self.court_width = 15.24
        
        # Zones
        self.zones = [
            Zone(
                name='COURT',
                bounds=self._court_bounds(),
                area=self.court_length * self.court_width,
                type='FIELD'
            ),
            Zone(
                name='HOME_BENCH',
                bounds=(0, 0, 5, 2),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='AWAY_BENCH',
                bounds=(0, self.court_width - 2, 5, self.court_width),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='PAINT_HOME',
                bounds=(0, self.court_width/2 - 2.44, 5.8, self.court_width/2 + 2.44),
                area=28.3,
                type='RESTRICTED'
            )
        ]
        
        self.crowd_count = config.get('crowdCount', 5000) if config else 5000
        
    def initialize(self, entities: List[Dict]):
        """Set up players, refs, ball, crowd."""
        
        # Home team (5 players)
        for i in range(5):
            pos = self._get_formation_position('HOME', i)
            entity = {
                'id': f'HOME_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'HOME',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (255, 0, 0),  # Red
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Away team (5 players)
        for i in range(5):
            pos = self._get_formation_position('AWAY', i)
            entity = {
                'id': f'AWAY_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'AWAY',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (0, 0, 255),  # Blue
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Referees (3)
        for i in range(3):
            entity = {
                'id': f'REF_{i+1}',
                'type': 'PERSON',
                'role': 'OFFICIAL',
                'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 1.8,
                'color': (128, 128, 128),  # Gray
                'reflectance': 0.4,
                'behavior': 'referee'
            }
            entities.append(entity)
        
        # Basketball
        entity = {
            'id': 'BALL',
            'type': 'OBJECT',
            'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 1.5},
            'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
            'radius': 0.12,
            'color': (255, 165, 0),  # Orange
            'reflectance': 0.6
        }
        entities.append(entity)
        
        # Crowd (simplified - grouped entities)
        self._generate_crowd(entities, self.crowd_count)
        
        print(f"Basketball scenario initialized: {len(entities)} entities")
        
    def update(self, entities: List[Dict], dt: float):
        """Update entity behaviors each frame."""
        for entity in entities:
            behavior = entity.get('behavior')
            
            if behavior == 'basketball_player':
                self._update_player_behavior(entity, entities, dt)
            elif behavior == 'referee':
                self._update_referee_behavior(entity, entities, dt)
        
        # Update ball physics (bouncing, possession)
        self._update_ball(entities, dt)
        
    def _get_formation_position(self, team: str, index: int) -> tuple:
        """Get initial position for player in formation."""
        # Simple positioning - half court
        if team == 'HOME':
            x_base = self.court_length * 0.25
        else:
            x_base = self.court_length * 0.75
            
        # Spread players across court width
        y = (self.court_width / 6) * (index + 1)
        
        return (x_base, y)
        
    def _update_player_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Basic basketball player AI."""
        # Find ball
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Move towards ball (simplified)
        dx = ball['position']['x'] - entity['position']['x']
        dy = ball['position']['y'] - entity['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 0.5:  # Not at ball
            # Move towards ball
            speed = 3.0  # m/s
            entity['velocity']['x'] = (dx / dist) * speed
            entity['velocity']['y'] = (dy / dist) * speed
        else:
            # At ball - slow down
            entity['velocity']['x'] *= 0.5
            entity['velocity']['y'] *= 0.5
            
    def _update_referee_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Referee follows play."""
        # Similar to player but slower
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if ball:
            dx = ball['position']['x'] - entity['position']['x']
            dy = ball['position']['y'] - entity['position']['y']
            dist = np.sqrt(dx**2 + dy**2)
            
            if dist > 3.0:
                speed = 2.0
                entity['velocity']['x'] = (dx / dist) * speed
                entity['velocity']['y'] = (dy / dist) * speed
                
    def _update_ball(self, entities: List[Dict], dt: float):
        """Update ball physics."""
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Gravity
        ball['velocity']['z'] -= 9.81 * dt
        
        # Bounce on floor
        if ball['position']['z'] <= 0.12:  # Ball radius
            ball['position']['z'] = 0.12
            ball['velocity']['z'] = -ball['velocity']['z'] * 0.7  # Bounce with loss
            
    def _court_bounds(self) -> tuple:
        """Return (x_min, y_min, x_max, y_max)."""
        return (0, 0, self.court_length, self.court_width)
        
    def _generate_crowd(self, entities: List[Dict], count: int):
        """Generate crowd entities (simplified grouping)."""
        # Stands are outside court boundaries
        # Create grouped "crowd sections" rather than individual spectators
        num_sections = 8
        people_per_section = count // num_sections
        
        for i in range(num_sections):
            entity = {
                'id': f'CROWD_SECTION_{i+1}',
                'type': 'GROUP',
                'role': 'SPECTATOR',
                'count': people_per_section,
                'position': {
                    'x': np.random.uniform(-5, self.court_length + 5),
                    'y': np.random.uniform(-5, self.court_width + 5),
                    'z': 0.0
                },
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 2.0,  # Group radius
                'color': (100, 100, 200),
                'reflectance': 0.3
            }
            entities.append(entity)

```

#### simulation\src\sports\combat.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class CombatScenario(Scenario):
    """MMA/Boxing style simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'COMBAT'
        self.ring_size = 9.0 # meters
        
        self.zones = [
            Zone(name='RING', bounds=(0,0,self.ring_size,self.ring_size), area=81, type='RING'),
            Zone(name='RINGSIDE', bounds=(-2,-2,self.ring_size+2,self.ring_size+2), area=150, type='RESTRICTED')
        ]

    def initialize(self, entities: List[Dict]):
        # Fighter 1
        entities.append({
            'id': 'FIGHTER_1', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (255, 0, 0)
        })
        
        # Fighter 2
        entities.append({
            'id': 'FIGHTER_2', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size*2/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (0, 0, 255)
        })
        
        # Referee
        entities.append({
            'id': 'REF', 'type': 'PERSON', 'role': 'OFFICIAL',
            'position': {'x': self.ring_size/2, 'y': self.ring_size/4, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.75, 'color': (200, 200, 200)
        })

    def update(self, entities: List[Dict], dt: float):
        f1 = next(e for e in entities if e['id'] == 'FIGHTER_1')
        f2 = next(e for e in entities if e['id'] == 'FIGHTER_2')
        
        # Circle each other
        center_x = (f1['position']['x'] + f2['position']['x']) / 2
        center_y = (f1['position']['y'] + f2['position']['y']) / 2
        
        for f in [f1, f2]:
            dx = center_x - f['position']['x']
            dy = center_y - f['position']['y']
            # Add orbit logic here... simplified
            f['velocity']['x'] += (np.random.rand()-0.5) * 2.0
            f['velocity']['y'] += (np.random.rand()-0.5) * 2.0

```

#### simulation\src\sports\soccer.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class SoccerScenario(Scenario):
    """FIFA-style soccer simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'SOCCER'
        
        # Field dimensions (Standard 105m x 68m)
        self.field_length = 105.0
        self.field_width = 68.0
        
        # Zones
        self.zones = [
            Zone(
                name='FIELD',
                bounds=(0, 0, self.field_length, self.field_width),
                area=self.field_length * self.field_width,
                type='FIELD'
            ),
             Zone(
                name='PENALTY_AREA_HOME',
                bounds=(0, self.field_width/2 - 20.15, 16.5, self.field_width/2 + 20.15),
                area=665.0, # Approx
                type='RESTRICTED'
            ),
             Zone(
                name='PENALTY_AREA_AWAY',
                bounds=(self.field_length - 16.5, self.field_width/2 - 20.15, self.field_length, self.field_width/2 + 20.15),
                area=665.0,
                type='RESTRICTED'
            )
        ]
        
    def initialize(self, entities: List[Dict]):
        # Home Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('HOME', i)
            entities.append(self._create_player(f'HOME_{i+1}', 'HOME', pos, (255, 0, 0)))

        # Away Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('AWAY', i)
            entities.append(self._create_player(f'AWAY_{i+1}', 'AWAY', pos, (0, 0, 255)))
            
        # Ball
        entities.append({
            'id': 'BALL', 'type': 'OBJECT', 
            'position': {'x': self.field_length/2, 'y': self.field_width/2, 'z': 0.11},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.11, 'color': (255, 255, 255)
        })

    def update(self, entities: List[Dict], dt: float):
        # Very simple AI: chase ball
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball: return
        
        for e in entities:
            if e.get('role') == 'PLAYER':
                self._update_player(e, ball, dt)

    def _create_player(self, pid, team, pos, color):
        return {
            'id': pid, 'type': 'PERSON', 'role': 'PLAYER', 'team': team,
            'position': {'x': pos[0], 'y': pos[1], 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.8, 'color': color, 'behavior': 'soccer_player'
        }

    def _get_formation_position(self, team, index):
        # 4-4-2 Formation stub
        base_x = 10 if team == 'HOME' else self.field_length - 10
        direction = 1 if team == 'HOME' else -1
        
        if index == 0: # GK
            return (base_x, self.field_width/2)
        elif index < 5: # Defenders
            return (base_x + 15*direction, self.field_width * (index/5))
        elif index < 9: # Midfielders
            return (base_x + 35*direction, self.field_width * ((index-4)/5))
        else: # Forwards
            return (base_x + 55*direction, self.field_width * ((index-8)/3))

    def _update_player(self, player, ball, dt):
        # Chase ball logic similar to basketball
        dx = ball['position']['x'] - player['position']['x']
        dy = ball['position']['y'] - player['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 1.0:
            speed = 4.0
            player['velocity']['x'] = (dx/dist) * speed
            player['velocity']['y'] = (dy/dist) * speed

```

#### simulation\src\utils\ptp_sync.py
```python
import time
import numpy as np

class PTPClock:
    """
    IEEE 1588 Precision Time Protocol simulation.
    Simulates clock drift and offset correction.
    """
    
    def __init__(self, is_master: bool = True):
        self.is_master = is_master
        self.epoch = time.time_ns()
        self.crystal_frequency = 1e9  # 1 GHz nominal
        # Simulate hardware clock drift (parts per million)
        self.ppm_drift = np.random.uniform(-30, 30) if not is_master else 0.0
        self.offset_ns = 0
        
    def get_time(self) -> int:
        """Get current PTP time in nanoseconds."""
        elapsed = time.time_ns() - self.epoch
        # Apply simulated drift
        drift_factor = 1.0 + (self.ppm_drift / 1e6)
        
        return int(elapsed * drift_factor) + self.offset_ns + self.epoch
    
    def get_time_sec(self) -> float:
        """Get current PTP time in seconds."""
        return self.get_time() / 1e9
    
    def sync_with_master(self, master_time: int):
        """Synchronize slave clock with master time sample."""
        if self.is_master:
            return
            
        current_time = self.get_time()
        offset = master_time - current_time
        
        # Simple PI controller for smooth clock discipline
        # In a real PTP stack this is much more complex
        self.offset_ns += int(offset * 0.5)

```

#### simulation\tests\test_camera_simulator.py
```python
import unittest
import numpy as np
from src.nodes.camera_simulator import CameraSimulator

class TestCameraSimulator(unittest.TestCase):
    def setUp(self):
        self.camera = CameraSimulator(
            resolution={'width': 1920, 'height': 1080},
            fps=30,
            fov=90
        )
    
    def test_render_returns_bytes_when_due(self):
        # Timestamp 0.0 -> should render
        # Timestamp 0.001 -> should NOT render (too soon for 30fps)
        
        entities = [{'id': 'E1', 'position': {'x': 0, 'y': 0, 'z': 5}}]
        
        # First frame
        frame1 = self.camera.render(entities, timestamp=1.0)
        self.assertIsNotNone(frame1)
        self.assertIsInstance(frame1, bytes)
        
        # Too soon
        frame2 = self.camera.render(entities, timestamp=1.01)
        self.assertIsNone(frame2)
        
        # Next frame due (approx 33ms later)
        frame3 = self.camera.render(entities, timestamp=1.04)
        self.assertIsNotNone(frame3)

if __name__ == '__main__':
    unittest.main()

```

#### simulation\tests\test_performance.py
```python
import time
import unittest
from src.core.orchestrator import SimulationOrchestrator

class TestPerformance(unittest.TestCase):
    def test_fps_stability(self):
        # This test ensures the loop runs at ~30 FPS
        # We'll just run a few iter and check time
        
        # Mock orchestrator behavior without threading for test
        orch = SimulationOrchestrator()
        
        start_time = time.time()
        frames = 30
        
        for i in range(frames):
            orch._generate_sensor_data()
            orch._detect_anomalies()
            time.sleep(1/30) # Simulate loop wait
            
        elapsed = time.time() - start_time
        fps = frames / elapsed
        
        print(f"Measured FPS: {fps}")
        self.assertTrue(25 < fps < 35, f"FPS {fps} out of range")

if __name__ == '__main__':
    unittest.main()

```

## 5. Frontend

#### frontend\Dockerfile
```
# Build Stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
# Skip type check based on previous tsconfig relaxation, but run build
RUN npm run build

# Serve Stage
FROM node:18-alpine
WORKDIR /app
RUN npm install -g serve
COPY --from=builder /app/dist ./dist
EXPOSE 80
CMD ["serve", "-s", "dist", "-l", "80"]

```

#### frontend\index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motion Intelligence Grid</title>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

#### frontend\package.json
```json
{
    "name": "motiongrid-frontend",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.1",
        "three": "^0.160.0",
        "@react-three/fiber": "^8.15.12",
        "@react-three/drei": "^9.92.4",
        "socket.io-client": "^4.6.2",
        "recharts": "^2.10.3",
        "axios": "^1.6.2",
        "date-fns": "^2.30.0",
        "zustand": "^4.4.7",
        "clsx": "^2.0.0",
        "tailwind-merge": "^2.1.0",
        "lucide-react": "^0.294.0",
        "class-variance-authority": "^0.7.0"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@types/three": "^0.160.0",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.3.6",
        "typescript": "^5.2.2",
        "vite": "^5.0.8"
    }
}
```

#### frontend\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "module": "ESNext",
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        /* Linting */
        "strict": false,
        "noImplicitAny": false,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": [
        "src"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
```

#### frontend\tsconfig.node.json
```json
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "vite.config.ts"
    ]
}
```

#### frontend\vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        host: true,
        allowedHosts: true, // Allow Cloud Run domains
        port: 5173,
        proxy: {
            '/api': {
                target: 'http://localhost:3001',
                changeOrigin: true
            }
        }
    }
})

```

#### frontend\src\App.tsx
```typescript
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AppShell } from './components/layout/AppShell';


import Dashboard from './views/Dashboard/Dashboard';
import SystemConfig from './views/SystemConfig/SystemConfig';

import { LiveMonitoring } from './views/LiveMonitoring';
import SessionReplay from './views/SessionReplay/SessionReplay';
import AnalyticsDashboard from './views/Analytics/AnalyticsDashboard';

import { PlaceholderView } from './components/common/PlaceholderView';

import { SessionsList } from './views/Sessions/SessionsList';
import { AnomalyTriage } from './views/Triage/AnomalyTriage';
import { EntityProfile } from './views/Entities/EntityProfile';

function App() {
    return (
        <Router>
            <AppShell>
                <Routes>
                    <Route path="/" element={<Dashboard />} />
                    <Route path="/live" element={<LiveMonitoring />} />
                    <Route path="/replay/:id" element={<SessionReplay />} />
                    <Route path="/analytics" element={<AnalyticsDashboard />} />
                    <Route path="/config" element={<SystemConfig />} />

                    {/* New Features - No Longer Placeholders */}
                    <Route path="/sessions" element={<SessionsList />} />
                    <Route path="/sessions/:id" element={<SessionReplay />} />
                    <Route path="/triage" element={<AnomalyTriage />} />
                    <Route path="/entities" element={<PlaceholderView title="Entity Directory" />} />
                    <Route path="/entities/:id" element={<EntityProfile />} />

                    <Route path="/automation" element={<PlaceholderView title="Automation Rules" />} />

                    {/* Fallback */}
                    <Route path="*" element={<PlaceholderView title="404: Page Not Found" description="The page you are looking for does not exist." />} />
                </Routes>
            </AppShell>
        </Router>
    )
}

export default App

```

#### frontend\src\index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  background-color: #020617;
  /* navy-950 */
  color: #f8fafc;
  /* light text */
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
```

#### frontend\src\main.tsx
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

```

#### frontend\src\vite-env.d.ts
```typescript
/// <reference types="vite/client" />

```

#### frontend\src\components\common\PlaceholderView.tsx
```typescript
import React from 'react';
import { Construction } from 'lucide-react';
import { Card } from '../ui/Card';

interface PlaceholderViewProps {
    title: string;
    description?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
    title,
    description = "This feature is currently under development. Check back soon for updates."
}) => {
    return (
        <div className="p-6 h-full flex items-center justify-center">
            <Card className="max-w-md w-full p-8 text-center flex flex-col items-center gap-4 bg-navy-800 border-navy-700">
                <div className="w-16 h-16 bg-navy-900 rounded-full flex items-center justify-center border border-navy-700 shadow-inner">
                    <Construction className="w-8 h-8 text-primary-400" />
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white mb-2">{title}</h2>
                    <p className="text-slate-400 leading-relaxed">
                        {description}
                    </p>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\components\layout\AppShell.tsx
```typescript
import { Sidebar } from './Sidebar';
import { TopBar } from './TopBar';

interface AppShellProps {
    children: React.ReactNode;
}

export function AppShell({ children }: AppShellProps) {
    return (
        <div className="min-h-screen bg-navy-950 text-slate-200 font-sans selection:bg-secondary-500/30">
            <TopBar />
            <Sidebar />

            <main className="pl-[260px] pt-[80px] min-h-screen transition-all duration-300">
                <div className="max-w-[1920px] mx-auto p-6 animate-in fade-in duration-500 slide-in-from-bottom-4">
                    {children}
                </div>
            </main>
        </div>
    );
}

```

#### frontend\src\components\layout\Sidebar.tsx
```typescript
import {
    LayoutDashboard,
    Radio,
    Server,
    Settings,
    Bell,
    Search,
    Menu,
    Play,
    LayoutGrid,
    Activity,
    Video,
    BarChart3,
    Zap,
    AlertTriangle,
    Users,
    HelpCircle,
    LogOut
} from 'lucide-react';
import { NavLink } from 'react-router-dom';
import { cn } from '../../utils/cn';

const NAV_ITEMS = [
    { label: 'Overview', path: '/', icon: LayoutGrid },
    { label: 'Live Intelligence', path: '/live', icon: Activity },
    { label: 'Session Replay', path: '/replay/mock-session-1', icon: Play }, // Added for easy access
    { label: 'System Config', path: '/config', icon: Settings },
    { label: 'Sessions', path: '/sessions', icon: Video },
    { label: 'Analytics', path: '/analytics', icon: BarChart3 },
    { label: 'Automation', path: '/automation', icon: Zap },
    { label: 'Triage', path: '/triage', icon: AlertTriangle },
    { label: 'Entities', path: '/entities', icon: Users },
];

export function Sidebar() {
    return (
        <aside className="w-[260px] bg-navy-900 border-r border-navy-800 fixed left-0 top-0 bottom-0 pt-[80px] flex flex-col z-40">
            <div className="flex-1 overflow-y-auto py-6 px-3 space-y-1">
                <div className="text-xs font-bold text-slate-500 uppercase px-4 mb-2 tracking-wider">Menu</div>
                {NAV_ITEMS.map((item) => (
                    <NavLink
                        key={item.path}
                        to={item.path}
                        className={({ isActive }) => cn(
                            "flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200",
                            isActive
                                ? "bg-secondary-600/10 text-secondary-400 border border-secondary-600/20 shadow-[0_0_15px_rgba(99,102,241,0.1)]"
                                : "text-slate-400 hover:bg-navy-800 hover:text-slate-200"
                        )}
                    >
                        <item.icon className="w-5 h-5" />
                        {item.label}
                    </NavLink>
                ))}
            </div>

            <div className="p-4 border-t border-navy-800 space-y-1">
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-navy-800 hover:text-slate-200 transition-colors">
                    <HelpCircle className="w-5 h-5" />
                    Help & Docs
                </button>
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-red-900/20 hover:text-red-400 transition-colors">
                    <LogOut className="w-5 h-5" />
                    Logout
                </button>
            </div>
        </aside>
    );
}

```

#### frontend\src\components\layout\TopBar.tsx
```typescript
import { Bell, Settings, User, Search } from 'lucide-react';
import { Button } from '../ui/Button';

export function TopBar() {
    return (
        <header className="h-[80px] bg-navy-950 border-b border-navy-800 flex items-center justify-between px-6 fixed top-0 left-0 right-0 z-50">
            {/* Left: Logo & Context */}
            <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-lg flex items-center justify-center shadow-lg shadow-primary-500/20">
                        <svg className="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <span className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-400 to-secondary-400">
                        MotionGrid
                    </span>
                </div>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div className="flex items-center gap-2 text-slate-400 bg-navy-900 py-2 px-4 rounded-lg border border-navy-800">
                    <Search className="w-4 h-4" />
                    <span className="text-sm">Global Search...</span>
                </div>
            </div>

            {/* Right: Actions & Profile */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" className="relative" onClick={() => alert("Notifications coming soon!")}>
                    <Bell className="w-5 h-5 text-slate-400" />
                    <span className="absolute top-2 right-2 w-2 h-2 bg-status-critical rounded-full animate-pulse" />
                </Button>
                <Button variant="ghost" size="icon" onClick={() => alert("Settings panel coming soon!")}>
                    <Settings className="w-5 h-5 text-slate-400" />
                </Button>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div
                    className="flex items-center gap-3 pl-2 cursor-pointer hover:bg-navy-900 p-2 rounded-lg transition-colors"
                    onClick={() => alert("User profile management coming soon!")}
                >
                    <div className="text-right hidden md:block">
                        <div className="text-sm font-semibold text-white">Admin User</div>
                        <div className="text-xs text-primary-400">OPERATOR</div>
                    </div>
                    <div className="w-10 h-10 bg-navy-800 rounded-full flex items-center justify-center border border-navy-700">
                        <User className="w-5 h-5 text-slate-300" />
                    </div>
                </div>
            </div>
        </header>
    );
}

```

#### frontend\src\components\ui\Badge.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const badgeVariants = cva(
    "inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide transition-colors",
    {
        variants: {
            variant: {
                default: "bg-navy-700 text-white",
                critical: "bg-status-critical text-white shadow-[0_0_10px_rgba(220,38,38,0.4)]",
                high: "bg-status-high text-white",
                medium: "bg-status-medium text-white",
                low: "bg-status-low text-white",
                success: "bg-status-success text-white",
                outline: "border border-navy-700 text-slate-400 bg-transparent",
            },
            size: {
                sm: "text-[10px] px-2 py-0.5",
                md: "text-xs px-3 py-1",
                lg: "text-sm px-4 py-1.5",
            }
        },
        defaultVariants: {
            variant: "default",
            size: "md",
        }
    }
);

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof badgeVariants> { }

export function Badge({ className, variant, size, ...props }: BadgeProps) {
    return (
        <span className={badgeVariants({ variant, size, className })} {...props} />
    );
}

```

#### frontend\src\components\ui\Button.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';
import React from 'react';

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-lg text-sm font-semibold transition-all focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none active:scale-95",
    {
        variants: {
            variant: {
                primary: "bg-secondary-600 text-white hover:bg-secondary-500 shadow-lg shadow-secondary-900/20",
                secondary: "border border-navy-700 bg-transparent text-slate-300 hover:bg-navy-800",
                danger: "bg-status-critical text-white hover:bg-red-700",
                ghost: "bg-transparent text-slate-400 hover:text-white hover:bg-navy-800",
                icon: "p-2 bg-transparent text-slate-400 hover:bg-navy-800 hover:text-white rounded-md",
            },
            size: {
                sm: "px-3 py-1.5 text-xs",
                md: "px-4 py-2",
                lg: "px-6 py-3 text-base",
                icon: "h-9 w-9 p-0",
            },
            fullWidth: {
                true: "w-full",
            }
        },
        defaultVariants: {
            variant: "primary",
            size: "md",
            fullWidth: false,
        }
    }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, fullWidth, ...props }, ref) => {
        return (
            <button
                ref={ref}
                className={buttonVariants({ variant, size, fullWidth, className })}
                {...props}
            />
        );
    }
);
Button.displayName = "Button";

```

#### frontend\src\components\ui\Card.tsx
```typescript
import { cn } from '../../utils/cn';
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    hover?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
    ({ className, hover = true, children, ...props }, ref) => {
        return (
            <div
                ref={ref}
                className={cn(
                    "bg-navy-800 border border-navy-700 rounded-xl shadow-md p-5",
                    "transition-all duration-200 ease-out",
                    hover && "hover:-translate-y-0.5 hover:shadow-lg hover:shadow-black/20 hover:border-navy-600",
                    className
                )}
                {...props}
            >
                {children}
            </div>
        );
    }
);
Card.displayName = "Card";

export function CardHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("mb-4 flex items-center justify-between", className)} {...props}>
            {children}
        </div>
    );
}

export function CardTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
    return (
        <h3 className={cn("text-lg font-bold text-white", className)} {...props}>
            {children}
        </h3>
    );
}

export function CardContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("text-sm text-slate-300 leading-relaxed", className)} {...props}>
            {children}
        </div>
    );
}

```

#### frontend\src\services\api.ts
```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';

const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

export const Api = {
    // Nodes
    getNodes: async () => (await api.get('/nodes')).data,
    getNode: async (id: string) => (await api.get(`/nodes/${id}`)).data,
    createNode: async (data: any) => (await api.post('/nodes', data)).data,
    updateNode: async (id: string, data: any) => (await api.patch(`/nodes/${id}`, data)).data,
    deleteNode: async (id: string) => (await api.delete(`/nodes/${id}`)).data,

    // Sessions
    getSessions: async () => (await api.get('/sessions')).data,
    getSession: async (id: string) => (await api.get(`/sessions/${id}`)).data,
    createSession: async (data: any) => (await api.post('/sessions', data)).data,
    updateSession: async (id: string, data: any) => (await api.patch(`/sessions/${id}`, data)).data,
    deleteSession: async (id: string) => (await api.delete(`/sessions/${id}`)).data,
    startSession: async (id: string) => (await api.post(`/sessions/${id}/start`)).data,
    stopSession: async (id: string) => (await api.post(`/sessions/${id}/stop`)).data,

    // Simulation
    startSimulation: async (config: any) => (await api.post('/simulation/start', config)).data,
    stopSimulation: async () => (await api.post('/simulation/stop')).data,
    getSimulationStatus: async () => (await api.get('/simulation/status')).data,

    // Entities
    getEntities: async () => (await api.get('/entities')).data,

    // Analytics
    getStats: async () => (await api.get('/analytics/stats')).data
};

```

#### frontend\src\services\websocket.ts
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketService {
    private socket: Socket | null = null;
    private callbacks: Map<string, Function[]> = new Map();

    connect(url: string) {
        this.socket = io(url, {
            transports: ['websocket'],
            reconnection: true
        });

        this.socket.on('connect', () => {
            console.log('WebSocket connected');
            // Re-subscribe if we had active subscriptions? 
            // For now, simpler to leave it to the components.
        });

        this.socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        // Register for all expected events
        ['sensor:frame', 'anomaly:detected', 'entity:tracking', 'session:stats', 'node:status']
            .forEach(event => {
                this.socket!.on(event, (data: any) => {
                    const cbs = this.callbacks.get(event) || [];
                    cbs.forEach(cb => cb(data));
                });
            });
    }

    subscribeToSession(sessionId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:session', { sessionId });
    }

    subscribeToNode(nodeId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:node', { nodeId });
    }

    on(event: string, callback: Function) {
        if (!this.callbacks.has(event)) {
            this.callbacks.set(event, []);
        }
        this.callbacks.get(event)!.push(callback);
    }

    off(event: string, callback: Function) {
        if (!this.callbacks.has(event)) return;
        const cbs = this.callbacks.get(event) || [];
        this.callbacks.set(event, cbs.filter(cb => cb !== callback));
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
}

export const wsService = new WebSocketService();

```

#### frontend\src\utils\cn.ts
```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

```

#### frontend\src\views\Analytics\AnalyticsDashboard.tsx
```typescript
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';

export const AnalyticsDashboard = () => {
    return (
        <div className="p-6 space-y-6 text-white h-full overflow-y-auto">
            <h1 className="text-2xl font-bold mb-4">System Analytics</h1>

            {/* KPI Grid */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <KPICard title="Total Sessions" value="1,284" trend="+12%" />
                <KPICard title="Avg. Anomaly Rate" value="0.4/hr" trend="-5%" trendGood />
                <KPICard title="Active Nodes" value="24/24" trend="100%" />
                <KPICard title="Data Throughput" value="1.2 GB/s" trend="+8%" />
            </div>

            {/* Charts Section */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">Anomaly Distribution by Type</h3>
                    <div className="flex items-end justify-around h-60 gap-4 pb-2 border-b border-slate-700">
                        <Bar height="30%" label="Speed" color="bg-blue-500" />
                        <Bar height="60%" label="Crowd" color="bg-purple-500" />
                        <Bar height="15%" label="Zone" color="bg-yellow-500" />
                        <Bar height="45%" label="Formation" color="bg-green-500" />
                    </div>
                </Card>

                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">System Load (24h)</h3>
                    {/* Simple SVG Line Chart */}
                    <div className="h-60 w-full relative">
                        <svg className="w-full h-full overflow-visible">
                            <defs>
                                <linearGradient id="grad" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="#0ea5e9" stopOpacity="0.5" />
                                    <stop offset="100%" stopColor="#0ea5e9" stopOpacity="0" />
                                </linearGradient>
                            </defs>
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20 V150 H0 Z"
                                fill="url(#grad)"
                            />
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20"
                                fill="none"
                                stroke="#0ea5e9"
                                strokeWidth="3"
                            />
                        </svg>
                        <div className="absolute bottom-0 w-full text-xs text-slate-500 flex justify-between">
                            <span>00:00</span>
                            <span>06:00</span>
                            <span>12:00</span>
                            <span>18:00</span>
                            <span>24:00</span>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const KPICard = ({ title, value, trend, trendGood = false }: any) => (
    <Card className="p-4">
        <div className="text-slate-400 text-sm">{title}</div>
        <div className="text-2xl font-bold mt-1">{value}</div>
        <div className={`text-xs mt-2 ${trendGood || trend.startsWith('+') ? 'text-green-400' : 'text-slate-500'}`}>
            {trend} vs last week
        </div>
    </Card>
);

const Bar = ({ height, label, color }: any) => (
    <div className="flex flex-col items-center flex-1 h-full justify-end group">
        <div className={`w-full max-w-[40px] rounded-t-sm ${color} transition-all duration-500`} style={{ height }}></div>
        <div className="text-xs text-slate-400 mt-2">{label}</div>
    </div>
);

```

#### frontend\src\views\Dashboard\Dashboard.tsx
```typescript
import { AnomalyPanel } from './components/AnomalyPanel';
import { DashboardControls } from './components/DashboardControls';
import { StadiumMap } from './components/StadiumMap';
import { DashboardSparkline } from './components/DashboardSparkline';

const Dashboard = () => {
    return (
        <div className="space-y-6">
            <DashboardControls />

            <div className="flex flex-col lg:flex-row gap-6">
                {/* Main View: Stadium Map */}
                <div className="flex-1">
                    <StadiumMap />

                    {/* Bottom Sparkline */}
                    <div className="mt-6 h-[100px] bg-navy-900 border border-navy-800 rounded-xl relative overflow-hidden p-2">
                        <DashboardSparkline />
                    </div>
                </div>

                {/* Right Panel: Anomalies */}
                <AnomalyPanel />
            </div>
        </div>
    );
};

export default Dashboard;

```

#### frontend\src\views\Dashboard\components\AnomalyPanel.tsx
```typescript
import { Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { Badge } from '../../../components/ui/Badge';

const ANOMALIES = [
    { id: 1, time: '11:22', zone: 'Gate B', type: 'Crowd Compression', severity: 'critical', score: 87, delta: '+150%' },
    { id: 2, time: '11:20', zone: 'Concourse N', type: 'Rapid Movement', severity: 'high', score: 65, delta: '+80%' },
    { id: 3, time: '11:15', zone: 'Field', type: 'Unauthorized Access', severity: 'medium', score: 45, delta: 'N/A' },
    { id: 4, time: '11:10', zone: 'Gate A', type: 'Loitering', severity: 'low', score: 20, delta: '+15%' },
];

export function AnomalyPanel() {
    return (
        <div className="w-full lg:w-[360px] bg-navy-900 border border-navy-800 rounded-2xl flex flex-col h-[600px]">
            {/* Header */}
            <div className="p-4 border-b border-navy-800 flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-bold text-white">Active Anomalies</h3>
                    <div className="text-xs text-slate-400">23 Detected • <span className="text-status-critical">4 Critical</span></div>
                </div>
                <div className="flex gap-2">
                    <Button variant="ghost" size="icon"><Filter className="w-4 h-4" /></Button>
                    <Button variant="ghost" size="icon"><MoreHorizontal className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* List */}
            <div className="flex-1 overflow-y-auto p-3 space-y-3">
                {ANOMALIES.map((item) => (
                    <div
                        key={item.id}
                        className="group bg-navy-800 rounded-xl p-3 border border-navy-700 hover:border-indigo-500/50 hover:bg-navy-800/80 transition-all cursor-pointer relative overflow-hidden"
                    >
                        {/* Severity Indicator Bar */}
                        <div className={`absolute left-0 top-0 bottom-0 w-1 ${item.severity === 'critical' ? 'bg-status-critical' :
                            item.severity === 'high' ? 'bg-status-high' :
                                item.severity === 'medium' ? 'bg-status-medium' : 'bg-status-low'
                            }`} />

                        <div className="pl-3">
                            <div className="flex justify-between items-start mb-1">
                                <Badge variant={item.severity as any} size="sm">{item.severity}</Badge>
                                <span className="text-xs font-mono text-slate-500">{item.time}</span>
                            </div>

                            <h4 className="font-bold text-white text-sm mb-1 group-hover:text-indigo-300 transition-colors">{item.type}</h4>
                            <div className="flex justify-between items-center text-xs">
                                <span className="text-slate-400 uppercase tracking-wide font-semibold">{item.zone}</span>
                                <div className="flex gap-3 text-slate-500">
                                    <span>Risk: <span className={item.score > 80 ? 'text-red-400' : 'text-slate-300'}>{item.score}</span></span>
                                    <span>Δ: {item.delta}</span>
                                </div>
                            </div>
                        </div>

                        {/* Hover Actions Overlay (Simulated) */}
                        <div className="absolute right-2 bottom-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button size="sm" variant="secondary" className="h-7 text-xs px-2">View</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-navy-800 bg-navy-950/50 rounded-b-2xl">
                <Button variant="primary" fullWidth size="md">View All Anomalies</Button>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardControls.tsx
```typescript
import { Calendar, ChevronDown } from 'lucide-react';

export function DashboardControls() {
    return (
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6 bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
            {/* Event Selector */}
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-indigo-500/20 rounded-lg flex items-center justify-center text-indigo-400">
                    <Calendar className="w-5 h-5" />
                </div>
                <div>
                    <div className="text-xs text-slate-400 uppercase font-bold tracking-wide">Current Event</div>
                    <div className="flex items-center gap-2 text-white font-semibold cursor-pointer hover:text-indigo-400 transition-colors">
                        Match Day: Team A vs Team B
                        <ChevronDown className="w-4 h-4" />
                    </div>
                </div>
            </div>

            {/* Time Range Chips */}
            <div className="flex bg-navy-900 rounded-lg p-1 border border-navy-700">
                {['Now', 'Last 30m', 'Last 2h', '24h', 'Custom'].map((range, idx) => (
                    <button
                        key={range}
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${idx === 0
                            ? 'bg-secondary-600 text-white shadow-md'
                            : 'text-slate-400 hover:text-white hover:bg-navy-700'
                            }`}
                    >
                        {range}
                    </button>
                ))}
            </div>

            {/* System Status */}
            <div className="flex items-center gap-2 px-4 py-2 bg-status-success/10 border border-status-success/20 rounded-lg text-status-success">
                <span className="relative flex h-2.5 w-2.5">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
                </span>
                <span className="text-sm font-bold tracking-wide">SYSTEM OPTIMAL</span>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardSparkline.tsx
```typescript
import { Area, AreaChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts';

const generateMockData = () => {
    const data = [];
    for (let i = 0; i < 24; i++) {
        data.push({
            time: `${i}:00`,
            events: Math.floor(Math.random() * 50) + 10,
            anomalies: Math.floor(Math.random() * 5),
        });
    }
    return data;
};

const data = generateMockData();

export function DashboardSparkline() {
    return (
        <div className="w-full h-full">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={data}>
                    <defs>
                        <linearGradient id="colorEvents" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#818cf8" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#818cf8" stopOpacity={0} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis hide />
                    <Tooltip
                        contentStyle={{ backgroundColor: '#1e293b', borderColor: '#334155', color: '#f8fafc' }}
                        itemStyle={{ color: '#818cf8' }}
                        labelStyle={{ color: '#94a3b8' }}
                    />
                    <Area
                        type="monotone"
                        dataKey="events"
                        stroke="#818cf8"
                        fillOpacity={1}
                        fill="url(#colorEvents)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\StadiumMap.tsx
```typescript
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ZONES = [
    { id: 'gate-a', name: 'GATE A', type: 'GATE', status: 'critical', x: '10%', y: '20%' },
    { id: 'gate-b', name: 'GATE B', type: 'GATE', status: 'normal', x: '80%', y: '20%' },
    { id: 'field', name: 'FIELD', type: 'FIELD', status: 'normal', x: '45%', y: '45%' },
    { id: 'concourse-n', name: 'CONCOURSE N', type: 'CONCOURSE', status: 'high', x: '45%', y: '10%' },
    { id: 'concourse-s', name: 'CONCOURSE S', type: 'CONCOURSE', status: 'normal', x: '45%', y: '80%' },
];

export function StadiumMap() {
    return (
        <div className="relative w-full h-[600px] bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden shadow-inner">
            {/* Grid Pattern Background */}
            <div className="absolute inset-0 opacity-10"
                style={{ backgroundImage: 'radial-gradient(circle, #334155 1px, transparent 1px)', backgroundSize: '30px 30px' }}
            />

            {/* Stadium Visual Placeholder - Simple SVG representation */}
            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 600">
                {/* Field */}
                <rect x="250" y="150" width="500" height="300" rx="40" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <circle cx="500" cy="300" r="50" fill="none" stroke="#334155" strokeWidth="2" />
                <line x1="500" y1="150" x2="500" y2="450" stroke="#334155" strokeWidth="2" />

                {/* Zones Outline */}
                <path d="M 150 100 Q 500 0 850 100 L 900 250 L 850 500 Q 500 600 150 500 L 100 250 Z"
                    fill="none" stroke="#4f46e5" strokeWidth="2" strokeDasharray="10 5" opacity="0.3" />
            </svg>

            {/* Zone Cards Overlay */}
            {ZONES.map((zone) => (
                <div
                    key={zone.id}
                    className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer transition-transform hover:scale-105 hover:z-10"
                    style={{ left: zone.x, top: zone.y }}
                >
                    <Card className={`w-48 p-3 bg-navy-800/90 backdrop-blur-sm border-l-4 ${zone.status === 'critical' ? 'border-l-status-critical shadow-[0_0_20px_rgba(220,38,38,0.2)]' :
                            zone.status === 'high' ? 'border-l-status-high' :
                                'border-l-status-success'
                        }`}>
                        <div className="flex justify-between items-start mb-2">
                            <span className="text-xs font-bold text-slate-300 tracking-wider">{zone.name}</span>
                            <Badge variant={zone.status as any} size="sm">{zone.status}</Badge>
                        </div>
                        <div className="space-y-1">
                            <div className="text-xs text-slate-400">Last event: 2m ago</div>
                            <div className="text-xs text-slate-400">Anomalies: <span className="text-white font-mono">3</span></div>
                        </div>
                    </Card>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\Entities\EntityProfile.tsx
```typescript
import { useParams, useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { ArrowLeft, Activity, Shield, MapPin } from 'lucide-react';

export const EntityProfile = () => {
    const { id } = useParams();
    const navigate = useNavigate();

    return (
        <div className="p-6 text-white max-w-5xl mx-auto">
            <Button variant="ghost" size="sm" onClick={() => navigate(-1)} className="mb-4">
                <ArrowLeft className="w-4 h-4 mr-2" /> Back
            </Button>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Profile Header */}
                <Card className="md:col-span-3 p-6 flex items-center gap-6">
                    <div className="w-24 h-24 rounded-full bg-slate-800 flex items-center justify-center text-3xl font-bold text-blue-400">
                        {id?.substring(0, 2).toUpperCase() || 'E'}
                    </div>
                    <div>
                        <h1 className="text-3xl font-bold">{id || 'Unknown Entity'}</h1>
                        <div className="text-slate-400 flex gap-4 mt-2">
                            <span className="flex items-center gap-1"><Shield className="w-4 h-4" /> Security Staff</span>
                            <span className="flex items-center gap-1"><MapPin className="w-4 h-4" /> Zone B</span>
                            <span className="flex items-center gap-1 text-green-400"><Activity className="w-4 h-4" /> Active</span>
                        </div>
                    </div>
                </Card>

                {/* Stats */}
                <Card className="p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Movement Stats</h3>
                    <div className="space-y-4">
                        <Stat label="Avg Speed" value="1.4 m/s" />
                        <Stat label="Distance" value="4.2 km" />
                        <Stat label="Zone Violations" value="0" />
                    </div>
                </Card>

                {/* Recent Activity */}
                <Card className="md:col-span-2 p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Recent Activity Timeline</h3>
                    <div className="space-y-4">
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:45</div>
                            <div>Entered Zone B (North Gate)</div>
                        </div>
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:30</div>
                            <div>Shift Started</div>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const Stat = ({ label, value }: any) => (
    <div className="flex justify-between items-center border-b border-slate-800 pb-2">
        <span className="text-slate-400 text-sm">{label}</span>
        <span className="font-mono">{value}</span>
    </div>
);

```

#### frontend\src\views\LiveMonitoring\AlertPanel.tsx
```typescript
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';

interface Anomaly {
    id: string;
    headline: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    time: string;
}

export const AlertPanel = () => {
    const alerts: Anomaly[] = [
        { id: 'A001', headline: 'Crowd Compression Risk', severity: 'CRITICAL', time: '10:42:05' },
        { id: 'A002', headline: 'Restricted Zone Access', severity: 'HIGH', time: '10:41:55' },
        { id: 'A003', headline: 'Loitering Detected', severity: 'LOW', time: '10:40:12' },
    ];

    return (
        <div className="bg-gray-800 border-l border-gray-700 w-80 flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-red-400" />
                    Active Alerts
                </h3>
            </div>

            <div className="flex-1 overflow-auto p-4 space-y-3">
                {alerts.map(alert => (
                    <div key={alert.id} className="bg-gray-700/50 rounded-lg p-3 border border-gray-600 hover:border-gray-500 transition-colors">
                        <div className="flex justify-between items-start mb-2">
                            <span className={`text-xs font-bold px-1.5 py-0.5 rounded ${alert.severity === 'CRITICAL' ? 'bg-red-500/20 text-red-300' :
                                    alert.severity === 'HIGH' ? 'bg-orange-500/20 text-orange-300' : 'bg-blue-500/20 text-blue-300'
                                }`}>
                                {alert.severity}
                            </span>
                            <span className="text-xs text-gray-400">{alert.time}</span>
                        </div>
                        <h4 className="text-sm font-medium mb-2">{alert.headline}</h4>

                        {/* Triage Actions */}
                        <div className="flex gap-2 mt-2">
                            <button className="flex-1 flex items-center justify-center gap-1 bg-green-900/30 hover:bg-green-900/50 text-green-300 py-1 rounded text-xs transition-colors">
                                <CheckCircle className="h-3 w-3" /> Confirm
                            </button>
                            <button className="flex-1 flex items-center justify-center gap-1 bg-gray-600/30 hover:bg-gray-600/50 text-gray-300 py-1 rounded text-xs transition-colors">
                                <XCircle className="h-3 w-3" /> Dismiss
                            </button>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\CameraGrid.tsx
```typescript

import { Camera } from 'lucide-react';
import { VideoPlaceholder } from './components/VideoPlaceholder';

export const CameraGrid = () => {
    // In a real app, this would fetch active nodes from API
    const cameras = [
        { id: 'CAM_01', name: 'North Gate', status: 'ONLINE' },
        { id: 'CAM_02', name: 'South Gate', status: 'ONLINE' },
        { id: 'CAM_03', name: 'Court A', status: 'ONLINE' },
        { id: 'CAM_04', name: 'Court B', status: 'OFFLINE' },
    ];

    return (
        <div className="grid grid-cols-2 gap-2 h-full">
            {cameras.map(cam => (
                <div key={cam.id} className="relative bg-black rounded overflow-hidden group">
                    <div className="absolute inset-0 flex items-center justify-center text-gray-700">
                        {cam.status === 'ONLINE' ? (
                            <div className="flex-1 bg-black relative">
                                <VideoPlaceholder label={cam.name} />
                            </div>) : (
                            <div className="flex flex-col items-center">
                                <Camera className="h-8 w-8 mb-2 opacity-50" />
                                <span className="text-xs">OFFLINE</span>
                            </div>
                        )}
                    </div>

                    {/* Overlay */}
                    <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white backdrop-blur-sm">
                        {cam.name}
                    </div>
                    <div className={`absolute top-2 right-2 w-2 h-2 rounded-full ${cam.status === 'ONLINE' ? 'bg-green-500' : 'bg-red-500'}`} />
                </div>
            ))}
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\index.tsx
```typescript
import { useEffect } from 'react';
import { MeshView3D } from './MeshView3D';
import { LayerControls } from './components/LayerControls';
import { LiveAlerts } from './components/LiveAlerts';
import { CameraStrip } from './components/CameraStrip';
import { wsService } from '../../services/websocket';
import { Button } from '../../components/ui/Button';
import { Pause, RefreshCw } from 'lucide-react';

export const LiveMonitoring = () => {
    useEffect(() => {
        // Use a safe fallback or window object if import.meta env is an issue in container
        const wsUrl = (import.meta as any).env?.VITE_WS_URL || 'http://localhost:3001';
        wsService.connect(wsUrl);
    }, []);

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] gap-4">
            {/* Top Controls */}
            <div className="flex items-center justify-between pb-2 border-b border-navy-800">
                <div className="flex gap-4 items-center">
                    <h2 className="text-lg font-bold text-white">Zone A: Main Concourse</h2>
                    <div className="flex gap-1">
                        <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span className="text-xs text-green-400 font-mono">LIVE FEED</span>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="icon" variant="ghost"><RefreshCw className="w-4 h-4" /></Button>
                    <Button size="icon" variant="secondary"><Pause className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* Main Content Area */}
            <div className="flex flex-1 gap-4 overflow-hidden">
                {/* Left: Layers */}
                <div className="flex-shrink-0">
                    <LayerControls />
                </div>

                {/* Center: 3D View */}
                <div className="flex-1 bg-black rounded-2xl border border-navy-800 relative overflow-hidden group">
                    <MeshView3D />

                    {/* Camera Strip Overlay */}
                    <div className="translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                        <CameraStrip />
                    </div>
                </div>

                {/* Right: Alerts */}
                <div className="flex-shrink-0">
                    <LiveAlerts />
                </div>
            </div>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\MeshView3D.tsx
```typescript
import { useEffect, useState, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text, Html } from '@react-three/drei';
import * as THREE from 'three';
import { wsService } from '../../services/websocket';

interface Entity {
    id: string;
    type: string;
    position: { x: number; y: number; z: number };
    velocity: { x: number; y: number; z: number };
    radius?: number;
    color?: number[];
    severity?: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
}

const EntityMesh = ({ entity }: { entity: Entity }) => {
    // Convert array color or hex to THREE.Color
    const color = useMemo(() => {
        if (Array.isArray(entity.color)) {
            return new THREE.Color(entity.color[0] / 255, entity.color[1] / 255, entity.color[2] / 255);
        }
        return new THREE.Color(entity.color || 'white');
    }, [entity.color]);

    return (
        <group position={[entity.position.x, entity.position.y, entity.position.z]}>
            {/* Entity Body */}
            <mesh>
                <capsuleGeometry args={[entity.radius || 0.3, 1.8, 4, 8]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* ID Tag */}
            <Html position={[0, 2, 0]} center>
                <div className="bg-black/50 text-white text-xs px-1 rounded backdrop-blur-sm whitespace-nowrap">
                    {entity.id}
                </div>
            </Html>

            {/* Velocity Vector */}
            {/* (Optional arrow helper could go here) */}
        </group>
    );
};

const ConnectingLines = () => {
    return (
        <line>
            <bufferGeometry />
            <lineBasicMaterial color="gray" />
        </line>
    )
}

export const MeshView3D = () => {
    const [entities, setEntities] = useState<Entity[]>([]);

    useEffect(() => {
        // Ensure WS is connected
        wsService.connect(import.meta.env.VITE_WS_URL || 'http://localhost:3001');

        // Subscribe to updates
        const unsubscribe = wsService.on('entity:tracking', (data: { entities: Entity[] }) => {
            if (data && data.entities) {
                setEntities(data.entities);
            }
        });

        return () => {
            // wsService.disconnect(); // Keep connection alive for other views in a real app
        };
    }, []);

    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden border border-slate-800 relative">
            <div className="absolute top-4 left-4 z-10 bg-slate-900/80 p-2 rounded text-xs text-slate-300">
                Live Entities: {entities.length}
            </div>

            <Canvas camera={{ position: [0, -40, 30], fov: 45 }}>
                <ambientLight intensity={0.5} />
                <directionalLight position={[10, 10, 20]} intensity={1} />
                <pointLight position={[-10, -10, 10]} intensity={0.5} />

                <OrbitControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2.2} />

                {/* Court/Field Grid */}
                <gridHelper args={[100, 100, 0x1e293b, 0x0f172a]} rotation={[Math.PI / 2, 0, 0]} />
                <axesHelper args={[5]} />

                {entities.map(e => (
                    <EntityMesh key={e.id} entity={e} />
                ))}
            </Canvas>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\components\CameraStrip.tsx
```typescript
export function CameraStrip() {
    return (
        <div className="absolute bottom-4 left-4 right-4 flex gap-4 overflow-x-auto pb-2 scrollbar-hide">
            {[1, 2, 3, 4, 5].map(cam => (
                <div key={cam} className="w-40 h-24 bg-black rounded-lg border border-navy-700 relative flex-shrink-0 group cursor-pointer hover:border-indigo-500 transition-colors">
                    <div className="absolute top-1 left-1 bg-black/50 px-1 rounded text-[10px] text-slate-300">CAM-0{cam}</div>
                    <div className="w-full h-full flex items-center justify-center text-slate-700 text-xs">NO SIGNAL</div>
                    <div className="absolute top-1 right-1 h-2 w-2 bg-green-500 rounded-full shadow-[0_0_5px_rgba(34,197,94,0.5)]"></div>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LayerControls.tsx
```typescript
import { Layers, Eye, Activity, Map, Users, Zap } from 'lucide-react';
import { Card } from '../../../components/ui/Card';

const LAYERS = [
    { id: 'entities', label: 'Entities', icon: Users, default: true },
    { id: 'risk', label: 'Risk Halos', icon: Zap, default: true },
    { id: 'velocity', label: 'Velocity Vectors', icon: Activity, default: false },
    { id: 'trails', label: 'Path Trails', icon: Map, default: false },
    { id: 'social', label: 'Social Radar', icon: Users, default: false },
    { id: 'terrain', label: 'Behavior Terrain', icon: Layers, default: true },
];

export function LayerControls() {
    return (
        <Card className="w-64 bg-navy-900 border-navy-800 flex flex-col gap-4 h-full">
            <div className="flex items-center gap-2 mb-2 pb-2 border-b border-navy-800">
                <Layers className="w-4 h-4 text-indigo-400" />
                <h3 className="font-bold text-white text-sm">View Layers</h3>
            </div>

            <div className="space-y-3">
                {LAYERS.map(layer => (
                    <label key={layer.id} className="flex items-center justify-between group cursor-pointer">
                        <div className="flex items-center gap-3 text-slate-300 group-hover:text-white transition-colors">
                            <layer.icon className="w-4 h-4 text-slate-500 group-hover:text-indigo-400" />
                            <span className="text-sm font-medium">{layer.label}</span>
                        </div>
                        <div className="relative inline-block w-8 h-4 rounded-full cursor-pointer">
                            <input type="checkbox" className="sr-only peer" defaultChecked={layer.default} />
                            <div className="w-8 h-4 bg-navy-800 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-indigo-600"></div>
                        </div>
                    </label>
                ))}
            </div>

            <div className="mt-auto pt-4 border-t border-navy-800">
                <div className="text-xs text-slate-500 mb-2 uppercase font-bold">Camera Overlay</div>
                <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <Eye className="w-4 h-4" /> Show FOV Cones
                    <input type="checkbox" className="ml-auto accent-indigo-500" defaultChecked />
                </label>
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LiveAlerts.tsx
```typescript
import { AlertTriangle, Clock } from 'lucide-react';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ALERTS = [
    { id: 1, type: 'Crowd Crush', risk: 92, time: '10s ago', zone: 'Gate B' },
    { id: 2, type: 'Fight Precursor', risk: 78, time: '32s ago', zone: 'Concourse' },
    { id: 3, type: 'Fallen Object', risk: 45, time: '1m ago', zone: 'Aisle 12' },
];

export function LiveAlerts() {
    return (
        <Card className="w-80 bg-navy-900 border-navy-800 flex flex-col h-full">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-navy-800">
                <div className="flex items-center gap-2">
                    <AlertTriangle className="w-4 h-4 text-status-critical" />
                    <h3 className="font-bold text-white text-sm">Live Alerts</h3>
                </div>
                <Badge variant="critical">3 Active</Badge>
            </div>

            <div className="flex-1 overflow-y-auto space-y-3">
                {ALERTS.map(alert => (
                    <div key={alert.id} className="bg-navy-800 p-3 rounded-lg border border-navy-700 hover:border-red-500/50 transition-colors cursor-pointer group">
                        <div className="flex justify-between items-start mb-1">
                            <span className="text-xs font-bold text-red-300">{alert.type}</span>
                            <span className="text-[10px] text-slate-500 flex items-center gap-1">
                                <Clock className="w-3 h-3" /> {alert.time}
                            </span>
                        </div>
                        <div className="flex justify-between items-end">
                            <div className="text-xs text-slate-400">{alert.zone}</div>
                            <div className="text-sm font-mono font-bold text-white">
                                {alert.risk}% <span className="text-xs font-sans font-normal text-slate-500">Risk</span>
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\VideoPlaceholder.tsx
```typescript
import { useEffect, useRef } from 'react';

export function VideoPlaceholder({ label }: { label: string }) {
    const canvasRef = useRef<HTMLCanvasElement>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId: number;
        let time = 0;

        const draw = () => {
            time += 0.05;
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a'; // bg-slate-900
            ctx.fillRect(0, 0, width, height);

            // Digital Noise / Scanlines
            for (let i = 0; i < height; i += 4) {
                ctx.fillStyle = `rgba(30, 41, 59, ${Math.random() * 0.5})`;
                ctx.fillRect(0, i, width, 1);
            }

            // Moving "Entities" (Simple Blobs)
            const x = (Math.sin(time) * 0.4 + 0.5) * width;
            const y = (Math.cos(time * 0.7) * 0.4 + 0.5) * height;

            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(79, 70, 229, 0.4)'; // Indigo
            ctx.fill();

            // Overlay Text
            ctx.font = '12px monospace';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('REC', width - 40, 20);
            ctx.fillText(new Date().toLocaleTimeString(), 10, height - 10);
            ctx.fillText(label, 10, 20);

            // Recording Dot
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(width - 50, 15, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }

            animationFrameId = window.requestAnimationFrame(draw);
        };

        const resize = () => {
            if (canvas.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        };

        window.addEventListener('resize', resize);
        resize(); // Initial resize
        draw();

        return () => {
            window.removeEventListener('resize', resize);
            window.cancelAnimationFrame(animationFrameId);
        };
    }, [label]);

    return (
        <canvas ref={canvasRef} className="w-full h-full block" />
    );
}

```

#### frontend\src\views\SessionReplay\SessionReplay.tsx
```typescript
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button } from '../../components/ui/Button';
import { Card } from '../../components/ui/Card';
import { Play, Pause, SkipBack, SkipForward, ArrowLeft } from 'lucide-react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';

interface SessionData {
    id: string;
    name: string;
    sport: string;
    startTime: string;
    duration: number;
    status: string;
}

export const SessionReplay = () => {
    const { id } = useParams();
    const navigate = useNavigate();
    const [session, setSession] = useState<SessionData | null>(null);
    const [currentTime, setCurrentTime] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const playbackRef = useRef<number>();

    // Mock fetch session details
    useEffect(() => {
        // In real app: fetch(`/api/sessions/${id}`)
        setSession({
            id: id || '1',
            name: 'Championship Final Game 3',
            sport: 'BASKETBALL',
            startTime: new Date().toISOString(),
            duration: 1200, // 20 mins
            status: 'COMPLETED'
        });
    }, [id]);

    // Playback loop
    useEffect(() => {
        if (isPlaying) {
            playbackRef.current = window.setInterval(() => {
                setCurrentTime(prev => {
                    if (prev >= (session?.duration || 0)) {
                        setIsPlaying(false);
                        return prev;
                    }
                    return prev + 1;
                });
            }, 1000); // 1x Speed
        } else {
            clearInterval(playbackRef.current);
        }
        return () => clearInterval(playbackRef.current);
    }, [isPlaying, session]);

    const formatTime = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    return (
        <div className="flex flex-col h-full gap-4 p-4 text-white">
            {/* Header */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="sm" onClick={() => navigate('/sessions')}>
                    <ArrowLeft className="w-4 h-4 mr-2" /> Back
                </Button>
                <div>
                    <h1 className="text-xl font-bold">{session?.name || 'Loading...'}</h1>
                    <div className="text-sm text-slate-400">
                        {session?.sport} • {new Date(session?.startTime || '').toLocaleDateString()}
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 flex gap-4 min-h-0">
                {/* 3D Replay Viewport */}
                <div className="flex-1 bg-slate-950 rounded-xl overflow-hidden relative border border-slate-800">
                    <div className="absolute top-4 left-4 z-10 bg-black/50 px-2 py-1 rounded text-xs">
                        REPLAY MODE
                    </div>
                    <Canvas camera={{ position: [0, -40, 30] }}>
                        <ambientLight intensity={0.5} />
                        <gridHelper args={[100, 100, 0x334155, 0x0f172a]} rotation={[Math.PI / 2, 0, 0]} />
                        <OrbitControls />
                        {/* Placeholder for entities at currentTime */}
                        <mesh position={[Math.sin(currentTime * 0.1) * 5, Math.cos(currentTime * 0.1) * 5, 1]}>
                            <sphereGeometry args={[0.5]} />
                            <meshStandardMaterial color="orange" />
                        </mesh>
                    </Canvas>
                </div>

                {/* Sidebar Stats */}
                <div className="w-80 flex flex-col gap-4">
                    <Card className="flex-1">
                        <div className="p-4">
                            <h3 className="font-semibold mb-4">Events Log</h3>
                            <div className="space-y-2 text-sm text-slate-400">
                                <div className="flex justify-between">
                                    <span>Sync Start</span>
                                    <span>0:00</span>
                                </div>
                                <div className="flex justify-between text-yellow-400">
                                    <span>Anomaly Detected</span>
                                    <span>0:45</span>
                                </div>
                                <div className="flex justify-between text-red-400">
                                    <span>Speed Violation</span>
                                    <span>1:20</span>
                                </div>
                            </div>
                        </div>
                    </Card>
                </div>
            </div>

            {/* Controls Bar */}
            <Card className="p-4 bg-slate-900 border-t border-slate-800">
                <div className="flex flex-col gap-2">
                    {/* Scrubber */}
                    <div className="flex items-center gap-4 text-xs text-slate-400">
                        <span className="w-12 text-right">{formatTime(currentTime)}</span>
                        <input
                            type="range"
                            min="0"
                            max={session?.duration || 100}
                            value={currentTime}
                            onChange={(e) => setCurrentTime(Number(e.target.value))}
                            className="flex-1 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="w-12">{formatTime(session?.duration || 0)}</span>
                    </div>

                    {/* Buttons */}
                    <div className="flex items-center justify-center gap-4">
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.max(0, currentTime - 10))}>
                            <SkipBack className="w-5 h-5" />
                        </Button>
                        <Button
                            variant="primary"
                            size="icon"
                            className="w-12 h-12 rounded-full"
                            onClick={() => setIsPlaying(!isPlaying)}
                        >
                            {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6 ml-1" />}
                        </Button>
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.min(session?.duration || 0, currentTime + 10))}>
                            <SkipForward className="w-5 h-5" />
                        </Button>
                    </div>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\views\Sessions\SessionsList.tsx
```typescript
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Play } from 'lucide-react';

const SESSIONS = [
    { id: '1', name: 'Game 5: Warriors vs Lakers', date: '2024-12-10', duration: '2:15:00', anomalies: 12, status: 'COMPLETED' },
    { id: '2', name: 'Practice Session A', date: '2024-12-11', duration: '0:45:00', anomalies: 2, status: 'REVIEWED' },
    { id: '3', name: 'Live Simulation Test', date: '2024-12-17', duration: '1:20:00', anomalies: 5, status: 'LIVE' },
];

export const SessionsList = () => {
    const navigate = useNavigate();

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Recorded Sessions</h1>
                <Button variant="primary">Export All</Button>
            </div>

            <Card className="overflow-hidden">
                <table className="w-full text-left text-sm">
                    <thead className="bg-slate-900 uppercase text-slate-400 font-semibold">
                        <tr>
                            <th className="p-4">Session Name</th>
                            <th className="p-4">Date</th>
                            <th className="p-4">Duration</th>
                            <th className="p-4">Anomalies</th>
                            <th className="p-4">Status</th>
                            <th className="p-4">Actions</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-800">
                        {SESSIONS.map((session) => (
                            <tr key={session.id} className="hover:bg-slate-800/50 transition-colors">
                                <td className="p-4 font-medium">{session.name}</td>
                                <td className="p-4 text-slate-400">{session.date}</td>
                                <td className="p-4 text-slate-400">{session.duration}</td>
                                <td className="p-4">
                                    <Badge variant={session.anomalies > 10 ? 'critical' : 'warning'}>
                                        {session.anomalies} Detected
                                    </Badge>
                                </td>
                                <td className="p-4">
                                    <Badge variant="outline">{session.status}</Badge>
                                </td>
                                <td className="p-4">
                                    <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={() => navigate(`/sessions/${session.id}`)}
                                    >
                                        <Play className="w-4 h-4 mr-2" /> Replay
                                    </Button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </Card>
        </div>
    );
};

```

#### frontend\src\views\SystemConfig\SystemConfig.tsx
```typescript
import { useState } from 'react';
import { Network, Activity, Crosshair } from 'lucide-react';
import { Button } from '../../components/ui/Button';
import { NodeTopology } from './components/NodeTopology';
import { SensorHealth } from './components/SensorHealth';
import { CalibrationWizard } from './components/CalibrationWizard';

type Tab = 'topology' | 'health' | 'calibration';

const SystemConfig = () => {
    const [activeTab, setActiveTab] = useState<Tab>('topology');

    return (
        <div className="space-y-6">
            {/* Top Bar Actions */}
            <div className="flex justify-between items-center bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
                <div className="flex gap-2">
                    <Button
                        variant={activeTab === 'topology' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('topology')}
                        className="gap-2"
                    >
                        <Network className="w-4 h-4" /> Node Topology
                    </Button>
                    <Button
                        variant={activeTab === 'health' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('health')}
                        className="gap-2"
                    >
                        <Activity className="w-4 h-4" /> Sensor Health
                    </Button>
                    <Button
                        variant={activeTab === 'calibration' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('calibration')}
                        className="gap-2"
                    >
                        <Crosshair className="w-4 h-4" /> Calibration
                    </Button>
                </div>
                <div className="flex gap-2">
                    <Button variant="secondary" size="sm">Export Config</Button>
                    <Button variant="primary" size="sm">Save Changes</Button>
                </div>
            </div>

            {/* Tab Content */}
            <div className="min-h-[600px]">
                {activeTab === 'topology' && <NodeTopology />}
                {activeTab === 'health' && <SensorHealth />}
                {activeTab === 'calibration' && <CalibrationWizard />}
            </div>
        </div>
    );
};

export default SystemConfig;

```

#### frontend\src\views\SystemConfig\components\CalibrationWizard.tsx
```typescript
import { useState, useEffect } from 'react';
import { Button } from '../../../components/ui/Button';
import { Camera, CheckCircle, RefreshCw, AlertTriangle } from 'lucide-react';

type Step = 'SELECT' | 'CAPTURE' | 'VERIFY' | 'COMPLETE';

export function CalibrationWizard() {
    const [step, setStep] = useState<Step>('SELECT');
    const [progress, setProgress] = useState(0);
    const [selectedNode, setSelectedNode] = useState<string | null>(null);

    // Simulate capture process
    useEffect(() => {
        if (step === 'CAPTURE') {
            const interval = setInterval(() => {
                setProgress(prev => {
                    if (prev >= 100) {
                        clearInterval(interval);
                        setStep('VERIFY');
                        return 100;
                    }
                    return prev + 2;
                });
            }, 50);
            return () => clearInterval(interval);
        }
    }, [step]);

    const reset = () => {
        setStep('SELECT');
        setProgress(0);
        setSelectedNode(null);
    };

    return (
        <div className="h-[500px] bg-navy-900 border border-navy-800 rounded-xl p-6 flex flex-col">
            <div className="mb-6">
                <h3 className="text-xl font-bold text-white mb-2">Sensor Calibration</h3>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <span className={step === 'SELECT' ? 'text-indigo-400 font-bold' : ''}>1. Select Node</span>
                    <span>→</span>
                    <span className={step === 'CAPTURE' ? 'text-indigo-400 font-bold' : ''}>2. Capture</span>
                    <span>→</span>
                    <span className={step === 'VERIFY' ? 'text-indigo-400 font-bold' : ''}>3. Verify</span>
                </div>
            </div>

            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-navy-700 rounded-xl bg-navy-800/30 p-8">
                {step === 'SELECT' && (
                    <div className="text-center space-y-4">
                        <div className="bg-navy-700 p-4 rounded-full inline-block">
                            <Camera className="w-8 h-8 text-indigo-400" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Select a Node to Calibrate</h4>
                        <div className="grid grid-cols-2 gap-3 w-full max-w-md">
                            {['Cam-01', 'Cam-02', 'Lidar-01', 'Lidar-02'].map(node => (
                                <button
                                    key={node}
                                    onClick={() => setSelectedNode(node)}
                                    className={`p-3 rounded border ${selectedNode === node ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node}
                                </button>
                            ))}
                        </div>
                        <Button
                            variant="primary"
                            disabled={!selectedNode}
                            onClick={() => setStep('CAPTURE')}
                        >
                            Start Calibration
                        </Button>
                    </div>
                )}

                {step === 'CAPTURE' && (
                    <div className="text-center space-y-6 w-full max-w-md">
                        <RefreshCw className="w-12 h-12 text-indigo-400 animate-spin mx-auto" />
                        <div>
                            <h4 className="text-lg font-medium text-white mb-1">Calibrating {selectedNode}...</h4>
                            <p className="text-sm text-slate-400">Capturing extrinsic parameters and aligning with point cloud.</p>
                        </div>
                        <div className="w-full bg-navy-950 rounded-full h-2.5 overflow-hidden">
                            <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-100" style={{ width: `${progress}%` }}></div>
                        </div>
                        <p className="text-xs text-slate-500 font-mono">{progress}% Complete</p>
                    </div>
                )}

                {step === 'VERIFY' && (
                    <div className="text-center space-y-4">
                        <AlertTriangle className="w-12 h-12 text-amber-400 mx-auto" />
                        <h4 className="text-lg font-medium text-white">Verification Required</h4>
                        <p className="text-sm text-slate-400 max-w-xs mx-auto">
                            The calculated transform has a reprojection error of <span className="text-white font-mono">0.04m</span>. This is within acceptable limits.
                        </p>
                        <div className="flex gap-3 justify-center">
                            <Button variant="secondary" onClick={reset}>Discard</Button>
                            <Button variant="primary" onClick={() => setStep('COMPLETE')}>Apply Transform</Button>
                        </div>
                    </div>
                )}

                {step === 'COMPLETE' && (
                    <div className="text-center space-y-4">
                        <div className="bg-emerald-500/10 p-4 rounded-full inline-block">
                            <CheckCircle className="w-12 h-12 text-emerald-500" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Calibration Successful</h4>
                        <p className="text-sm text-slate-400">Node {selectedNode} is now active and aligned.</p>
                        <Button variant="ghost" onClick={reset}>Calibrate Another Node</Button>
                    </div>
                )}
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\NodeTopology.tsx
```typescript
import { Plus } from 'lucide-react';
import { TopologyCanvas } from './TopologyCanvas';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const NODES = [
    { id: 'NODE_001', name: 'Gate B Cam 1', status: 'online', type: 'Camera' },
    { id: 'NODE_002', name: 'Gate B LIDAR', status: 'offline', type: 'LIDAR' },
    { id: 'NODE_003', name: 'Field Cam Main', status: 'online', type: 'Camera' },
];

export function NodeTopology() {
    return (
        <div className="flex flex-col lg:flex-row gap-6 h-[700px]">
            {/* Left Panel: Node List */}
            <div className="w-full lg:w-[300px] flex flex-col gap-4">
                <Card className="flex-1 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-white">Nodes</h3>
                        <Button size="icon" variant="ghost"><Plus className="w-4 h-4" /></Button>
                    </div>

                    <div className="space-y-3 flex-1 overflow-y-auto">
                        {NODES.map(node => (
                            <div key={node.id} className="p-3 bg-navy-900 rounded-lg border border-navy-700 hover:border-indigo-500 cursor-pointer transition-colors">
                                <div className="flex justify-between items-start mb-1">
                                    <div className="font-mono text-xs text-slate-500">{node.id}</div>
                                    <Badge variant={node.status === 'online' ? 'success' : 'critical'} size="sm" className="h-2 w-2 p-0 rounded-full"> </Badge>
                                </div>
                                <div className="font-bold text-sm text-slate-200">{node.name}</div>
                                <div className="text-xs text-indigo-400 mt-1">{node.type}</div>
                            </div>
                        ))}
                    </div>

                    <Button variant="secondary" fullWidth className="mt-4">Add New Node</Button>
                </Card>
            </div>

            {/* Right Panel: 3D View */}
            <div className="flex-1 bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden relative">
                <TopologyCanvas />
                <div className="absolute top-4 right-4 bg-navy-800/80 p-2 rounded text-xs text-slate-400">
                    <p>Left Click: Rotate</p>
                    <p>Right Click: Pan</p>
                    <p>Scroll: Zoom</p>
                </div>

                {/* Overlay Controls */}
                <div className="absolute top-4 right-4 bg-navy-800/80 backdrop-blur p-3 rounded-lg border border-navy-700 space-y-2">
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show Frustums
                    </label>
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show LIDAR
                    </label>
                </div>
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\SensorHealth.tsx
```typescript
import { Badge } from '../../../components/ui/Badge';

export function SensorHealth() {
    return (
        <div className="bg-navy-800 rounded-xl border border-navy-700 overflow-hidden">
            <table className="w-full text-left text-sm">
                <thead className="bg-navy-900 text-slate-400 font-medium">
                    <tr>
                        <th className="p-4">Node ID</th>
                        <th className="p-4">Sensor</th>
                        <th className="p-4">Status</th>
                        <th className="p-4">FPS (Target)</th>
                        <th className="p-4">Latency</th>
                        <th className="p-4">Last Update</th>
                        <th className="p-4 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-navy-700">
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_001</td>
                        <td className="p-4">Camera</td>
                        <td className="p-4"><Badge variant="success">ONLINE</Badge></td>
                        <td className="p-4">30/30</td>
                        <td className="p-4 text-green-400">12ms</td>
                        <td className="p-4 text-slate-400">Just now</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_002</td>
                        <td className="p-4">LIDAR</td>
                        <td className="p-4"><Badge variant="critical">OFFLINE</Badge></td>
                        <td className="p-4 text-red-400">0/10</td>
                        <td className="p-4 text-slate-500">--</td>
                        <td className="p-4 text-red-400">5m ago</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\TopologyCanvas.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Grid, Center, Text } from '@react-three/drei';

const Node = ({ position, color, label }: { position: [number, number, number], color: string, label: string }) => {
    return (
        <group position={position}>
            {/* Node visual */}
            <mesh>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* Frustum Visual (Cone) */}
            <mesh position={[0, 0, 2]} rotation={[Math.PI / 2, 0, 0]}>
                <coneGeometry args={[1, 4, 32, 1, true]} />
                <meshStandardMaterial color={color} wireframe opacity={0.3} transparent />
            </mesh>

            {/* Label */}
            <Text position={[0, 1.2, 0]} fontSize={0.5} color="white" anchorX="center" anchorY="middle">
                {label}
            </Text>
        </group>
    );
};

export function TopologyCanvas() {
    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden">
            <Canvas>
                <PerspectiveCamera makeDefault position={[10, 10, 10]} fov={50} />
                <OrbitControls makeDefault />

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} />

                <Grid infiniteGrid fadeDistance={50} sectionColor="#4f46e5" cellColor="#4f46e5" sectionSize={5} cellSize={1} />

                <Center>
                    <Node position={[0, 2, 0]} color="#10b981" label="Cam-01" />
                    <Node position={[-5, 2, 5]} color="#3b82f6" label="Lidar-01" />
                    <Node position={[5, 2, 5]} color="#3b82f6" label="Lidar-02" />
                </Center>
            </Canvas>
        </div>
    );
}

```

#### frontend\src\views\Triage\AnomalyTriage.tsx
```typescript
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';

const TASKS = {
    NEW: [
        { id: 'A-101', title: 'Speed Violation in Zone A', time: '10:42 AM', severity: 'CRITICAL' },
        { id: 'A-104', title: 'Unauthorized Entry', time: '10:45 AM', severity: 'HIGH' },
    ],
    INVESTIGATING: [
        { id: 'A-099', title: 'Crowd Density Warning', time: '09:30 AM', severity: 'MEDIUM' },
    ],
    RESOLVED: [
        { id: 'A-055', title: 'Sensor Dropout', time: 'Yesterday', severity: 'LOW' },
    ]
};

export const AnomalyTriage = () => {
    return (
        <div className="p-6 h-full text-white overflow-hidden flex flex-col">
            <h1 className="text-2xl font-bold mb-6">Anomaly Triage</h1>

            <div className="flex-1 flex gap-6 min-h-0 overflow-x-auto">
                <Column title="New Incidents" color="border-red-500" items={TASKS.NEW} />
                <Column title="Investigating" color="border-yellow-500" items={TASKS.INVESTIGATING} />
                <Column title="Resolved" color="border-green-500" items={TASKS.RESOLVED} />
            </div>
        </div>
    );
};

const Column = ({ title, color, items }: any) => (
    <div className="flex-1 flex flex-col gap-4 min-w-[300px]">
        <div className={`font-semibold pb-2 border-b-2 ${color} flex justify-between`}>
            {title}
            <span className="text-slate-500 text-sm">{items.length}</span>
        </div>
        <div className="flex-1 bg-slate-900/50 rounded-lg p-2 space-y-3 overflow-y-auto">
            {items.map((item: any) => (
                <Card key={item.id} className="p-3 cursor-move hover:bg-slate-800 transition-colors">
                    <div className="flex justify-between items-start mb-2">
                        <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                        <Badge variant={item.severity.toLowerCase()}>{item.severity}</Badge>
                    </div>
                    <div className="font-medium text-sm mb-2">{item.title}</div>
                    <div className="text-xs text-slate-400">{item.time}</div>
                </Card>
            ))}
        </div>
    </div>
);

```

## 1. Root

#### deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting deployment for Motion Intelligence Grid..."

# 1. Build and Push Containers
Write-Host "Building and Pushing Containers..."
gcloud builds submit --config cloudbuild.yaml . --project $ProjectId

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# 2. Apply Terraform
Write-Host "Applying Terraform..."
cd infrastructure
terraform init
terraform apply `
    -var="project_id=$ProjectId" `
    -var="region=$Region" `
    -var="mongodb_uri=$env:MONGODB_URI" `
    -var="jwt_secret=$env:JWT_SECRET" `
    -var="admin_password=$env:ADMIN_PASSWORD" `
    -auto-approve

if ($LASTEXITCODE -ne 0) {
    Write-Error "Terraform failed!"
    exit 1
}

Write-Host "Deployment Complete!"

```

#### manual_deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting Robust Deployment for Motion Intelligence Grid..." -ForegroundColor Cyan

# Function to Build and Push
function Build-And-Push {
    param(
        [string]$ServiceName,
        [string]$Path
    )
    $ImageName = "gcr.io/$ProjectId/motiongrid-$ServiceName`:latest"
    Write-Host "Processing $ServiceName..." -ForegroundColor Yellow
    
    # Build
    Write-Host "  Building $ImageName..."
    docker build -t $ImageName $Path
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Build Failed"; exit 1 }
    
    # Push
    Write-Host "  Pushing $ImageName..."
    docker push $ImageName
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Push Failed"; exit 1 }
    
    Write-Host "  $ServiceName Done." -ForegroundColor Green
}

# 1. Server
Build-And-Push "api" "./server"

# 2. Simulation
Build-And-Push "simulation" "./simulation"

# 3. Frontend
Build-And-Push "frontend" "./frontend"

# 4. Terraform
Write-Host "Applying Infrastructure Updates..." -ForegroundColor Yellow
Set-Location "./infrastructure"
terraform init
terraform apply -var="project_id=$ProjectId" -var="region=$Region" -auto-approve -lock=false

if ($LASTEXITCODE -ne 0) { 
    Write-Error "Terraform Failed"
    exit 1 
}

Write-Host "Deployment Complete! 🚀" -ForegroundColor Green
Set-Location ..

```

#### cloudbuild.yaml
```yaml
steps:
  # Build API
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-api:latest', './server']
    
  # Build Simulation
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest', './simulation']
    
  # Build Frontend
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest', './frontend']

  # Push Images
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-api:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest']


options:
  machineType: 'N1_HIGHCPU_8'

```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # MongoDB database
  mongodb:
    image: mongo:6
    container_name: motiongrid-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: devpassword123
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - motiongrid-network
    command: --wiredTigerCacheSizeGB 1.5

  # Redis (optional, for caching)
  redis:
    image: redis:7-alpine
    container_name: motiongrid-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - motiongrid-network
    command: redis-server --appendonly yes

  # API Gateway (Node.js + Express + Socket.io)
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-api
    restart: unless-stopped
    environment:
      NODE_ENV: development
      PORT: 3001
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
      REDIS_URL: redis://redis:6379
      JWT_SECRET: dev-secret-key
      SIMULATION_API_URL: http://simulation:8000
    ports:
      - "3001:3001"
    volumes:
      - ./server/src:/app/src
    depends_on:
      - mongodb
      - redis
    networks:
      - motiongrid-network
    command: npm run dev

  # Simulation Engine (Python + FastAPI)
  simulation:
    build:
      context: ./simulation
      dockerfile: Dockerfile
    container_name: motiongrid-simulation
    restart: unless-stopped
    environment:
      PYTHONUNBUFFERED: 1
      API_PORT: 8000
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
    ports:
      - "8000:8000"
    volumes:
      - ./simulation/src:/app/src
    depends_on:
      - mongodb
    networks:
      - motiongrid-network
    command: uvicorn src.api.server:app --host 0.0.0.0 --port 8000 --reload

  # Frontend (React SPA)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_WS_URL: ws://localhost:3001
    ports:
      - "5173:5173"
    volumes:
      - ./frontend/src:/app/src
    networks:
      - motiongrid-network
    command: npm run dev

volumes:
  mongodb_data:
  redis_data:


networks:
  motiongrid-network:
    driver: bridge

```

#### .gcloudignore
```
node_modules/
.git/
.github/
infrastructure/.terraform/
.DS_Store
*.log
coverage/
dist/
tmp/
gcloud_temp/

```

## 2. Infrastructure

#### infrastructure\main.tf
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

resource "google_cloud_run_service" "api" {
  name     = "motiongrid-api"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-api:latest"
        ports {
            container_port = 8080
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
          name  = "JWT_SECRET"
          value = var.jwt_secret
        }
        env {
          name  = "ADMIN_EMAIL"
          value = var.admin_email
        }
        env {
          name  = "ADMIN_PASSWORD"
          value = var.admin_password
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

resource "google_cloud_run_service" "simulation" {
  name     = "motiongrid-simulation"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-simulation:latest"
        ports {
            container_port = 8000
        }
        resources {
          limits = {
            cpu    = "2000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
          name  = "API_URL"
          value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service" "frontend" {
  name     = "motiongrid-frontend"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-frontend:latest"
        ports {
            container_port = 80
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        env {
            name = "VITE_API_URL"
            value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service_iam_member" "public_access_frontend" {
  service  = google_cloud_run_service.frontend.name
  location = google_cloud_run_service.frontend.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

# Storage Bucket for Session Recordings
resource "google_storage_bucket" "sessions" {
  name     = "${var.project_id}-sessions"
  location = var.region
  
  uniform_bucket_level_access = true
  
  lifecycle_rule {
    action { type = "Delete" }
    condition { age = 180 }  # Keep recordings 6 months
  }
}

resource "google_cloud_run_service_iam_member" "public_access_api" {
  service  = google_cloud_run_service.api.name
  location = google_cloud_run_service.api.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_simulation" {
  service  = google_cloud_run_service.simulation.name
  location = google_cloud_run_service.simulation.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "frontend_url" {
  value = google_cloud_run_service.frontend.status[0].url
}

```

#### infrastructure\variables.tf
```hcl
variable "project_id" {
  description = "GCP Project ID"
  type        = string
  default     = "freeforge-481415"
}

variable "region" {
  description = "GCP Region"
  type        = string
  default     = "us-central1"
}

variable "mongodb_uri" {
    description = "MongoDB Connection String"
    type = string
    sensitive = true
}

variable "jwt_secret" {
    description = "JWT Secret for authentication"
    type = string
    sensitive = true
}

variable "admin_email" {
    description = "Default admin email"
    type = string
    default = "admin@freeforge.com"
}

variable "admin_password" {
    description = "Default admin password"
    type = string
    sensitive = true
}


```

## 3. Server

#### server\Dockerfile
```
# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine AS production
WORKDIR /app
ENV NODE_ENV=production
COPY package*.json ./
RUN npm install --only=production
COPY --from=builder /app/dist ./dist
EXPOSE 8080
CMD ["node", "dist/index.js"]

```

#### server\package.json
```json
{
  "name": "motiongrid-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.2",
    "mongoose": "^8.0.3",
    "redis": "^4.6.11",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "axios": "^1.6.2",
    "typescript": "^5.3.3",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/express": "^4.17.21",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11"
  }
}
```

#### server\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2016",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": false,
        "noImplicitAny": false,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "noEmitOnError": false,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts"
    ]
}
```

#### server\src\database.ts
```typescript
import mongoose from 'mongoose';

export const connectDB = async () => {
    const uri = process.env.MONGODB_URI;

    if (!uri) {
        console.error('❌ MONGODB_URI environment variable is required');
        // In production, we might want to throw error, but for now we log error
        // throwing error would crash loop which is handled by index.ts
        throw new Error('MONGODB_URI environment variable is required');
    }

    if (uri === 'memory') {
        console.warn('⚠️ Running in IN-MEMORY mode (dev only). Persistence disabled.');
        return;
    }

    try {
        console.log(`[DATABASE] Connecting to MongoDB (URI ending in: ...${uri.slice(-4)})`);
        await mongoose.connect(uri, {
            serverSelectionTimeoutMS: 10000, // 10 seconds
        });
        console.log('✅ MongoDB connected successfully');
    } catch (error: any) {
        console.error('❌ MongoDB connection failed:', error.message);
        throw error;
    }
};

```

#### server\src\index.ts
```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { connectDB } from './database';
import { socketService } from './services/SocketService';
import { authenticate as authMiddleware } from './middleware/auth';

// Import routes at the top as per best practices
import authRouter from './routes/auth';
import nodesRouter from './routes/nodes';
import sessionsRouter from './routes/sessions';
import anomaliesRouter from './routes/anomalies';
import entitiesRouter from './routes/entities';
import simulationRouter from './routes/simulation';
import analyticsRouter from './routes/analytics';

// Load environment variables
dotenv.config();

console.log('🚀 [STARTUP] Motion Intelligence Grid API initiating...');
console.log(`[STARTUP] Environment: ${process.env.NODE_ENV || 'development'}`);

const app = express();
const httpServer = createServer(app);

// BIND PORT IMMEDIATELY FOR CLOUD RUN HEALTH CHECKS
const PORT = process.env.PORT || 8080;
httpServer.listen(PORT, () => {
    console.log(`✅ [STARTUP] API listening on port ${PORT}`);
});

const io = new Server(httpServer, {
    cors: {
        origin: process.env.CLIENT_URL || '*',
        methods: ['GET', 'POST'],
    },
});

// Initialize SocketService
socketService.init(io);

// Middleware
app.use(cors());
app.use(helmet());
app.use(express.json());

// Basic health check (Always available)
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date(),
        db: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        uptime: process.uptime()
    });
});

// Routes
app.use('/api/auth', authRouter);
app.use('/api/nodes', authMiddleware, nodesRouter);
app.use('/api/sessions', authMiddleware, sessionsRouter);
app.use('/api/anomalies', authMiddleware, anomaliesRouter);
app.use('/api/entities', authMiddleware, entitiesRouter);
app.use('/api/simulation', authMiddleware, simulationRouter);
app.use('/api/analytics', authMiddleware, analyticsRouter);

// Internal Endpoints for Simulation Bridge
app.post('/internal/entity-update', async (req, res) => {
    const { sessionId, entities, stats, sentAt } = req.body;
    const latencyMs = sentAt ? Math.round((Date.now() / 1000 - sentAt) * 1000) : 0;
    socketService.emit('entity:tracking', { entities, stats, latencyMs }, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

app.post('/internal/anomaly', async (req, res) => {
    const { sessionId, anomaly } = req.body;
    socketService.emit('anomaly:detected', anomaly, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

const startServer = async () => {
    try {
        console.log('[STARTUP] Connecting to database...');
        await connectDB();
        console.log('✅ [STARTUP] Database connected successfully.');

        if (mongoose.connection.readyState === 1) {
            const { User } = await import('./models/User');
            const adminEmail = process.env.ADMIN_EMAIL || 'admin@freeforge.com';
            const adminPassword = process.env.ADMIN_PASSWORD || 'nimda';

            console.log(`[STARTUP] Checking for admin: ${adminEmail}`);
            const adminUser = await User.findOne({ email: adminEmail });

            if (!adminUser) {
                console.log(`[STARTUP] Seeding default admin user: ${adminEmail} with password: ${adminPassword}...`);
                const newAdmin = new User({
                    email: adminEmail,
                    passwordHash: adminPassword,
                    username: 'admin',
                    role: 'ADMIN'
                });
                await newAdmin.save();
                console.log('✅ [STARTUP] Default admin created.');
            } else {
                console.log(`[STARTUP] Admin user ${adminEmail} exists. Updating password to environment current value...`);
                adminUser.passwordHash = adminPassword;
                await adminUser.save();
                console.log('✅ [STARTUP] Admin password updated successfully.');
            }
        }
    } catch (error) {
        console.error('❌ [STARTUP] initialization failed:', error);
    }
};

startServer();

```

#### server\src\middleware\auth.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface UserPayload {
    userId: string;
    role: string;
    email: string;
}

declare global {
    namespace Express {
        interface Request {
            user?: UserPayload;
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    // Skip auth for login/public routes if applying globally, 
    // but usually we apply this middleware to specific routes.

    const authHeader = req.headers.authorization;
    let token = '';

    if (authHeader) {
        token = authHeader.split(' ')[1]; // Bearer <token>
    } else if (req.query.token) {
        token = req.query.token as string;
    }

    if (!token) {
        return res.status(401).json({ error: 'Token missing or Authorization header missing' });
    }

    try {
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const decoded = jwt.verify(token, secret) as UserPayload;
        req.user = decoded;
        next();
    } catch (err) {
        return res.status(401).json({ error: 'Invalid or expired token' });
    }
};

export const requireRole = (roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        if (!req.user || !roles.includes(req.user.role)) {
            return res.status(403).json({ error: 'Insufficient permissions' });
        }
        next();
    };
};

```

#### server\src\middleware\validate.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

export const validateBody = (schema: Joi.Schema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({ error: error.details[0].message });
        }
        next();
    };
};

```

#### server\src\models\Anomaly.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IAnomaly extends Document {
    anomalyId: string;
    sessionId: mongoose.Types.ObjectId;
    entityIds: mongoose.Types.ObjectId[];
    nodeIds: string[];
    occurredAt: Date;
    duration: number;
    type: 'GEOGRAPHICS' | 'KINETICS' | 'PROXEMICS' | 'ATMOSPHERICS';
    subtype: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    scenario?: string;
    headline: string;
    description: string;
    baselineText: string;
    anomalyText: string;
    metrics: {
        baselineDelta: number;
        confidence: number;
        riskScore: number;
    };
    ruleOfThreeHit: boolean;
    relatedAnomalies: mongoose.Types.ObjectId[];
    zone: string;
    location: { x: number; y: number; z: number };
    triage: {
        status: 'UNREVIEWED' | 'CONFIRMED' | 'DOWNGRADED' | 'FALSE_POSITIVE';
        notes?: string;
    };
    tags: string[];
    createdAt: Date;
    updatedAt: Date;
}

const AnomalySchema: Schema = new Schema({
    anomalyId: { type: String, required: true, unique: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    entityIds: [{ type: Schema.Types.ObjectId, ref: 'Entity' }],
    nodeIds: [String],
    occurredAt: { type: Date, default: Date.now },
    duration: { type: Number, default: 0 },
    type: { type: String, enum: ['GEOGRAPHICS', 'KINETICS', 'PROXEMICS', 'ATMOSPHERICS'], required: true },
    subtype: String,
    severity: { type: String, enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'], default: 'LOW' },
    scenario: String,
    headline: String,
    description: String,
    baselineText: String,
    anomalyText: String,
    metrics: {
        baselineDelta: Number,
        confidence: Number,
        riskScore: Number
    },
    ruleOfThreeHit: { type: Boolean, default: false },
    relatedAnomalies: [{ type: Schema.Types.ObjectId, ref: 'Anomaly' }],
    zone: String,
    location: {
        x: Number,
        y: Number,
        z: Number
    },
    triage: {
        status: { type: String, enum: ['UNREVIEWED', 'CONFIRMED', 'DOWNGRADED', 'FALSE_POSITIVE'], default: 'UNREVIEWED' },
        notes: String
    },
    tags: [String]
}, { timestamps: true });

export const Anomaly = mongoose.model<IAnomaly>('Anomaly', AnomalySchema);

```

#### server\src\models\Entity.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IEntity extends Document {
    entityId: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    name?: string;
    lastPosition: { x: number; y: number; z: number };
    lastVelocity: { x: number; y: number; z: number };
    lastSeenAt: Date;
    sessionId?: string;
}

const EntitySchema: Schema = new Schema({
    entityId: { type: String, required: true, unique: true },
    type: { type: String, enum: ['PERSON', 'OBJECT'], required: true },
    role: { type: String, enum: ['PLAYER', 'OFFICIAL', 'SPECTATOR', 'BALL'], default: 'SPECTATOR' },
    team: { type: String, enum: ['HOME', 'AWAY'] },
    name: String,
    lastPosition: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastVelocity: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastSeenAt: { type: Date, default: Date.now },
    sessionId: String
}, { timestamps: true });

export const Entity = mongoose.model<IEntity>('Entity', EntitySchema);

```

#### server\src\models\Node.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INode extends Document {
    nodeId: string;
    name: string;
    type: 'EDGE_NODE';
    status: 'ONLINE' | 'OFFLINE' | 'DEGRADED';
    position: { x: number; y: number; z: number };
    orientation: { pitch: number; yaw: number; roll: number };
    sensors: {
        camera: {
            enabled: boolean;
            resolution: { width: number; height: number };
            fps: number;
            fov: number;
            exposure: number;
            gain: number;
        };
        lidar: {
            enabled: boolean;
            model: string;
            channels: number;
            pointsPerSecond: number;
            range: number;
            accuracy: number;
        };
        imu: {
            enabled: boolean;
            sampleRate: number;
            accelRange: number;
            gyroRange: number;
        };
    };
    calibration: {
        intrinsic: {
            cameraMatrix: number[][];
            distortion: number[];
        };
        extrinsic: {
            rotationMatrix: number[][];
            translationVector: number[];
        };
        lidarToCameraTransform: number[][];
        calibrationQuality: number;
        calibratedAt: Date;
    };
    network: {
        ipAddress: string;
        port: number;
        ptpDomain: number;
        clockOffset: number;
        lastSyncAt: Date;
    };
    sessionId?: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const NodeSchema: Schema = new Schema({
    nodeId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    type: { type: String, default: 'EDGE_NODE' },
    status: { type: String, enum: ['ONLINE', 'OFFLINE', 'DEGRADED'], default: 'OFFLINE' },
    position: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    orientation: {
        pitch: { type: Number, default: 0 },
        yaw: { type: Number, default: 0 },
        roll: { type: Number, default: 0 }
    },
    sensors: {
        camera: {
            enabled: { type: Boolean, default: true },
            resolution: {
                width: { type: Number, default: 1920 },
                height: { type: Number, default: 1080 }
            },
            fps: { type: Number, default: 30 },
            fov: { type: Number, default: 90 },
            exposure: { type: Number, default: 50 },
            gain: { type: Number, default: 0 }
        },
        lidar: {
            enabled: { type: Boolean, default: true },
            model: { type: String, default: 'VLP-16' },
            channels: { type: Number, default: 16 },
            pointsPerSecond: { type: Number, default: 300000 },
            range: { type: Number, default: 100 },
            accuracy: { type: Number, default: 0.03 }
        },
        imu: {
            enabled: { type: Boolean, default: true },
            sampleRate: { type: Number, default: 100 },
            accelRange: { type: Number, default: 16 },
            gyroRange: { type: Number, default: 2000 }
        }
    },
    calibration: {
        intrinsic: {
            cameraMatrix: [[Number]],
            distortion: [Number]
        },
        extrinsic: {
            rotationMatrix: [[Number]],
            translationVector: [Number]
        },
        lidarToCameraTransform: [[Number]],
        calibrationQuality: { type: Number, default: 0 },
        calibratedAt: Date
    },
    network: {
        ipAddress: String,
        port: Number,
        ptpDomain: { type: Number, default: 0 },
        clockOffset: { type: Number, default: 0 },
        lastSyncAt: Date
    },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session' }
}, { timestamps: true });

export const Node = mongoose.model<INode>('Node', NodeSchema);

```

#### server\src\models\SensorFrame.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISensorFrame extends Document {
    frameId: string;
    sessionId: mongoose.Types.ObjectId;
    nodeId: string;
    timestamp: Date;
    frameNumber: number;
    camera?: {
        imagePath: string;
        resolution: { width: number; height: number };
    };
    lidar?: {
        pointCloudPath: string;
        pointCount: number;
    };
    fusion?: {
        detectedEntities: any[];
        processingTime: number;
    };
    createdAt: Date;
}

const SensorFrameSchema: Schema = new Schema({
    frameId: { type: String, required: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    nodeId: { type: String, required: true },
    timestamp: { type: Date, required: true },
    frameNumber: Number,
    camera: {
        imagePath: String,
        resolution: { width: Number, height: Number }
    },
    lidar: {
        pointCloudPath: String,
        pointCount: Number
    },
    fusion: {
        detectedEntities: [],
        processingTime: Number
    }
}, {
    timeseries: {
        timeField: 'timestamp',
        metaField: 'nodeId',
        granularity: 'seconds'
    },
    expireAfterSeconds: 86400 * 7 // 7 days retention
});

export const SensorFrame = mongoose.model<ISensorFrame>('SensorFrame', SensorFrameSchema);

```

#### server\src\models\Session.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISession extends Document {
    sessionId: string;
    name: string;
    sport: 'BASKETBALL' | 'SOCCER' | 'COMBAT' | 'CUSTOM';
    venue: string;
    startedAt: Date;
    endedAt?: Date;
    duration: number;
    status: 'RECORDING' | 'STOPPED' | 'PROCESSING' | 'READY';
    nodeIds: string[];
    stats: {
        totalFrames: number;
        totalEntities: number;
        totalAnomalies: number;
        anomalyBreakdown: {
            critical: number;
            high: number;
            medium: number;
            low: number;
        };
        avgOccupancy: number;
        peakOccupancy: number;
        avgActivityIndex: number;
    };
    scenario: {
        entityCount: number;
        crowdDensity: number;
        anomalyRate: number;
        environmentConfig: {
            lighting: 'BRIGHT' | 'DIM' | 'VARIABLE';
            weather?: 'CLEAR' | 'RAIN' | 'SNOW';
        };
    };
    dataPath: string;
    thumbnailPath?: string;
    createdAt: Date;
    updatedAt: Date;
}

const SessionSchema: Schema = new Schema({
    sessionId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    sport: { type: String, enum: ['BASKETBALL', 'SOCCER', 'COMBAT', 'CUSTOM'], required: true },
    venue: String,
    startedAt: { type: Date, default: Date.now },
    endedAt: Date,
    duration: { type: Number, default: 0 },
    status: { type: String, enum: ['RECORDING', 'STOPPED', 'PROCESSING', 'READY'], default: 'RECORDING' },
    nodeIds: [String],
    stats: {
        totalFrames: { type: Number, default: 0 },
        totalEntities: { type: Number, default: 0 },
        totalAnomalies: { type: Number, default: 0 },
        anomalyBreakdown: {
            critical: { type: Number, default: 0 },
            high: { type: Number, default: 0 },
            medium: { type: Number, default: 0 },
            low: { type: Number, default: 0 }
        },
        avgOccupancy: { type: Number, default: 0 },
        peakOccupancy: { type: Number, default: 0 },
        avgActivityIndex: { type: Number, default: 0 }
    },
    scenario: {
        entityCount: { type: Number, default: 0 },
        crowdDensity: { type: Number, default: 0 },
        anomalyRate: { type: Number, default: 0 },
        environmentConfig: {
            lighting: { type: String, default: 'BRIGHT' },
            weather: String
        }
    },
    dataPath: String,
    thumbnailPath: String
}, { timestamps: true });

export const Session = mongoose.model<ISession>('Session', SessionSchema);

```

#### server\src\models\User.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
    username: string;
    email: string;
    passwordHash: string;
    role: 'OPERATOR' | 'ANALYST' | 'ADMIN';
    permissions: string[];
    preferences: {
        theme: 'DARK' | 'LIGHT';
    };
    createdAt: Date;
    updatedAt: Date;
    validatePassword(password: string): Promise<boolean>;
}

const UserSchema: Schema = new Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['OPERATOR', 'ANALYST', 'ADMIN'], default: 'OPERATOR' },
    permissions: [String],
    preferences: {
        theme: { type: String, default: 'DARK' }
    }
}, { timestamps: true });

UserSchema.pre<IUser>('save', async function (next) {
    if (!this.isModified('passwordHash')) return next();
    try {
        const salt = await bcrypt.genSalt(10);
        this.passwordHash = await bcrypt.hash(this.passwordHash, salt);
        next();
    } catch (err: any) {
        next(err);
    }
});

UserSchema.methods.validatePassword = async function (password: string): Promise<boolean> {
    return await bcrypt.compare(password, this.passwordHash);
};

export const User = mongoose.model<IUser>('User', UserSchema);

```

#### server\src\routes\analytics.ts
```typescript
import express from 'express';

const router = express.Router();

router.get('/stats', (req, res) => {
    // Return aggregated stats
    res.json({
        totalAnomalies: 42,
        activeEntities: 15,
        systemHealth: 98.6,
        uptimeSeconds: 3600
    });
});

router.get('/performance', (req, res) => {
    // Return system performance metrics (FPS, Latency)
    res.json({
        simulationFps: 29.8,
        networkLatencyMs: 12,
        processingTimeMs: 4
    });
});

export default router;

```

#### server\src\routes\anomalies.ts
```typescript
import express from 'express';
import { Anomaly } from '../models/Anomaly';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, severity, status } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (severity) query.severity = severity;
        if (status) query['triage.status'] = status;

        const anomalies = await Anomaly.find(query).sort({ occurredAt: -1 }).limit(100);
        res.json({ anomalies, count: anomalies.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id/triage', async (req, res) => {
    try {
        const { status, notes } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            {
                'triage.status': status,
                'triage.notes': notes,
                'triage.triageAt': new Date()
            },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\auth.ts
```typescript
import express from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/User';

const router = express.Router();

router.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        // Find user
        const user = await User.findOne({ email });
        if (!user) {
            console.log(`Login attempt failed: User not found (${email})`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Validate password
        const isValid = await user.validatePassword(password);
        if (!isValid) {
            console.log(`Login attempt failed: Invalid password for ${email}`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        console.log(`Login successful for ${email}`);

        // Generate Token
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const token = jwt.sign(
            {
                userId: user._id,
                role: user.role,
                email: user.email
            },
            secret,
            { expiresIn: '24h' }
        );

        res.json({
            token,
            user: {
                id: user._id,
                email: user.email,
                role: user.role,
                username: user.username
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.post('/register', async (req, res) => {
    // For MVP/Demo: Allow registration of first user as ADMIN, others as VIEWERS
    // Or just open registration for "OPERATOR"
    try {
        const { email, password, username } = req.body;

        const existing = await User.findOne({ $or: [{ email }, { username }] });
        if (existing) {
            return res.status(400).json({ error: 'User already exists' });
        }

        const count = await User.countDocuments();
        const role = count === 0 ? 'ADMIN' : 'OPERATOR';

        const user = new User({
            email,
            passwordHash: password, // Will be hashed by pre-save hook
            username,
            role
        });

        await user.save();

        res.status(201).json({ message: 'User created', userId: user._id });
    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({ error: 'Registration failed' });
    }
});

export default router;

```

#### server\src\routes\entities.ts
```typescript
import express from 'express';
// In a real scenario, this might query the database or the simulation state
// For now, we'll return mock data or proxy to simulation if needed
const router = express.Router();

router.get('/', (req, res) => {
    // Return list of active entities
    // Could proxy to simulation: SimulationClient.getEntities()
    res.json([
        { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME' },
        { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY' }
    ]);
});

router.get('/:id/track', (req, res) => {
    const { id } = req.params;
    // Return history/track for entity
    res.json({
        entityId: id,
        path: []
    });
});

export default router;

```

#### server\src\routes\nodes.ts
```typescript
import express from 'express';
import axios from 'axios';
import { NodeService } from '../services/NodeService';

const router = express.Router();
const nodeService = new NodeService();

router.post('/', async (req, res) => {
    try {
        const node = await nodeService.createNode(req.body);
        res.status(201).json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const nodes = await nodeService.getNodes(req.query);
        res.json({ nodes, count: nodes.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const node = await nodeService.getNode(req.params.id);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/stream', async (req, res) => {
    try {
        const nodeId = req.params.id;
        // Ideally use env var for simulation URL
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios({
            method: 'get',
            url: `${simulationUrl}/nodes/${nodeId}/stream`,
            responseType: 'stream'
        });

        // Forward content type (multipart/x-mixed-replace)
        res.setHeader('Content-Type', response.headers['content-type']);
        response.data.pipe(res);
    } catch (err: any) {
        // console.error('Stream proxy error:', err.message);
        res.status(503).send('Stream unavailable');
    }
});

router.post('/:id/calibrate', async (req, res) => {
    try {
        const nodeId = req.params.id;
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios.post(`${simulationUrl}/nodes/${nodeId}/calibrate`);
        const result = response.data;

        // Update node in database
        await nodeService.updateNode(nodeId, {
            calibration: result.calibration
        });

        res.json(result);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const node = await nodeService.updateNode(req.params.id, req.body);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await nodeService.deleteNode(req.params.id);
        if (!success) return res.status(404).json({ error: 'Node not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\sessions.ts
```typescript
import express from 'express';
import { SessionService } from '../services/SessionService';

const router = express.Router();
const sessionService = new SessionService();

router.post('/', async (req, res) => {
    try {
        const session = await sessionService.createSession(req.body);
        res.status(201).json(session);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const sessions = await sessionService.getSessions(req.query);
        res.json({ sessions, count: sessions.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/start', async (req, res) => {
    try {
        const session = await sessionService.startSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/stop', async (req, res) => {
    try {
        const session = await sessionService.stopSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const session = await sessionService.updateSession(req.params.id, req.body);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json(session);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await sessionService.deleteSession(req.params.id);
        if (!success) return res.status(404).json({ error: 'Session not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\simulation.ts
```typescript
import express from 'express';
import { SimulationClient } from '../services/simulation_client';

const router = express.Router();

router.post('/start', async (req, res) => {
    const config = req.body;
    const success = await SimulationClient.startSimulation(config);
    if (success) {
        res.json({ message: 'Simulation started' });
    } else {
        res.status(500).json({ error: 'Failed to start simulation' });
    }
});

router.post('/stop', async (req, res) => {
    const success = await SimulationClient.stopSimulation();
    if (success) {
        res.json({ message: 'Simulation stopped' });
    } else {
        res.status(500).json({ error: 'Failed to stop simulation' });
    }
});

router.get('/status', async (req, res) => {
    const isHealthy = await SimulationClient.healthCheck();
    res.json({
        status: isHealthy ? 'running' : 'stopped',
        service: 'python-engine'
    });
});

export default router;

```

#### server\src\services\AnalyticsService.ts
```typescript
import { Session } from '../models/Session';
import { Anomaly } from '../models/Anomaly';

export class AnalyticsService {
    async getSessionStats(sessionId: string) {
        const session = await Session.findOne({ sessionId });
        if (!session) throw new Error('Session not found');

        const anomalyCount = await Anomaly.countDocuments({ sessionId: session._id });
        const criticalAnomalies = await Anomaly.countDocuments({ sessionId: session._id, severity: 'CRITICAL' });

        return {
            ...session.toJSON().stats,
            anomalyCount,
            criticalAnomalies
        };
    }

    async getGlobalStats() {
        const totalSessions = await Session.countDocuments();
        const totalAnomalies = await Anomaly.countDocuments();

        return {
            totalSessions,
            totalAnomalies,
            systemHealth: 'HEALTHY' // Placeholder
        };
    }
}

```

#### server\src\services\NodeService.ts
```typescript
import { Node, INode } from '../models/Node';

export class NodeService {
    async createNode(data: Partial<INode>): Promise<INode> {
        // Validation: Check if nodeId exists
        const existing = await Node.findOne({ nodeId: data.nodeId });
        if (existing) {
            throw new Error('Node ID already exists');
        }

        const node = new Node(data);
        return await node.save();
    }

    async getNodes(filter: any = {}): Promise<INode[]> {
        return await Node.find(filter);
    }

    async getNode(nodeId: string): Promise<INode | null> {
        return await Node.findOne({ nodeId });
    }

    async updateNode(nodeId: string, data: Partial<INode>): Promise<INode | null> {
        return await Node.findOneAndUpdate({ nodeId }, data, { new: true });
    }

    async deleteNode(nodeId: string): Promise<boolean> {
        const result = await Node.deleteOne({ nodeId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\SessionService.ts
```typescript
import { Session, ISession } from '../models/Session';
import mongoose from 'mongoose';

export class SessionService {
    async createSession(data: Partial<ISession>): Promise<ISession> {
        const session = new Session({
            ...data,
            sessionId: `SES_${Date.now()}`
        });
        return await session.save();
    }

    async getSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOne({ sessionId });
    }

    async getSessions(filter: any = {}): Promise<ISession[]> {
        return await Session.find(filter).sort({ createdAt: -1 });
    }

    async startSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'RECORDING',
                startedAt: new Date()
            },
            { new: true }
        );
    }

    async stopSession(sessionId: string): Promise<ISession | null> {
        const session = await Session.findOne({ sessionId });
        if (!session) return null;

        const endedAt = new Date();
        const duration = (endedAt.getTime() - session.startedAt.getTime()) / 1000;

        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'STOPPED',
                endedAt,
                duration
            },
            { new: true }
        );
    }


    async updateSession(sessionId: string, data: Partial<ISession>): Promise<ISession | null> {
        return await Session.findOneAndUpdate({ sessionId }, data, { new: true });
    }

    async deleteSession(sessionId: string): Promise<boolean> {
        const result = await Session.deleteOne({ sessionId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\simulation_client.ts
```typescript
import axios from 'axios';

const SIMULATION_API_URL = process.env.SIMULATION_API_URL || 'http://localhost:8000';

export class SimulationClient {

    static async healthCheck(): Promise<boolean> {
        try {
            const response = await axios.get(`${SIMULATION_API_URL}/health`);
            return response.data.status === 'ok';
        } catch (error) {
            console.error('Simulation API unhealthy:', error.message);
            return false;
        }
    }

    static async startSimulation(config: any): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/start`, config);
            return response.data.status === 'started';
        } catch (error) {
            console.error('Failed to start simulation:', error.message);
            return false;
        }
    }

    static async stopSimulation(): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/stop`);
            return response.data.status === 'stopped';
        } catch (error) {
            console.error('Failed to stop simulation:', error.message);
            return false;
        }
    }
}

```

#### server\src\services\SocketService.ts
```typescript
import { Server, Socket } from 'socket.io';
import jwt from 'jsonwebtoken';

class SocketService {
    private io: Server | null = null;

    init(io: Server) {
        this.io = io;
        this.setupListeners();
    }

    private setupListeners() {
        if (!this.io) return;

        // Authentication Middleware
        this.io.use((socket, next) => {
            const token = socket.handshake.auth.token || socket.handshake.query.token;

            if (!token) {
                return next(new Error('Authentication required'));
            }

            try {
                const secret = process.env.JWT_SECRET;
                if (!secret) {
                    console.error('❌ CRITICAL: JWT_SECRET environment variable is missing! Falling back to dev secret (INSECURE)');
                }
                const decoded = jwt.verify(token as string, secret || 'dev_secret_do_not_use_in_prod');
                (socket as any).user = decoded;
                next();
            } catch (err) {
                next(new Error('Invalid token'));
            }
        });

        this.setupHandlers();
    }

    private setupHandlers() {
        if (!this.io) return;

        this.io.on('connection', (socket: Socket) => {
            const user = (socket as any).user;
            console.log(`Client connected: ${socket.id} (User: ${user?.email || 'Unknown'})`);

            socket.on('disconnect', () => {
                console.log('Client disconnected:', socket.id);
            });

            // Handle subscriptions
            socket.on('subscribe:session', (data) => {
                console.log(`Client ${socket.id} subscribed to session ${data.sessionId}`);
                socket.join(`session:${data.sessionId}`);
            });

            socket.on('subscribe:node', (data) => {
                console.log(`Client ${socket.id} subscribed to node ${data.nodeId}`);
                socket.join(`node:${data.nodeId}`);
            });
        });
    }

    emit(event: string, data: any, room?: string) {
        if (!this.io) {
            console.warn('SocketService not initialized');
            return;
        }

        if (room) {
            this.io.to(room).emit(event, data);
        } else {
            this.io.emit(event, data);
        }
    }
}

export const socketService = new SocketService();

```

#### server\src\__tests__\integration\session-flow.test.ts
```typescript
import request from 'supertest';
// Mocking app import since we might not export it correctly for testing in index.ts
// In a real setup, we'd export `app` from app.ts and import it in index.ts
// For now, pseudo-integration test or need to refactor index.ts
// Refactoring index.ts to export app is best practice.

describe('Session Flow Integration', () => {
    it('placeholder for integration test', async () => {
        expect(true).toBe(true);
    });
});

```

#### server\src\__tests__\services\NodeService.test.ts
```typescript
import { NodeService } from '../../services/NodeService';
import { Node } from '../../models/Node';

// Mock the Mongoose Model
jest.mock('../../models/Node');

describe('NodeService', () => {
    let nodeService: NodeService;

    beforeEach(() => {
        nodeService = new NodeService();
        jest.clearAllMocks();
    });

    it('should create a node successfully', async () => {
        const mockNodeData = {
            nodeId: 'TEST_001',
            name: 'Test Node',
            position: { x: 0, y: 0, z: 0 },
            status: 'active'
        };

        // Mock findOne to return null (not found)
        (Node.findOne as jest.Mock).mockResolvedValue(null);

        // Mock create
        (Node.create as jest.Mock).mockResolvedValue(mockNodeData);

        const result = await nodeService.createNode(mockNodeData);

        expect(Node.findOne).toHaveBeenCalledWith({ nodeId: 'TEST_001' });
        expect(Node.create).toHaveBeenCalledWith(mockNodeData);
        expect(result).toEqual(mockNodeData);
    });

    it('should throw error if node already exists', async () => {
        const mockNodeData = { nodeId: 'DUPLICATE_001', name: 'Dup' };

        // Mock findOne to return existing doc
        (Node.findOne as jest.Mock).mockResolvedValue({ nodeId: 'DUPLICATE_001' });

        await expect(nodeService.createNode(mockNodeData))
            .rejects
            .toThrow('Node with this ID already exists');
    });

    it('should get all nodes', async () => {
        const mockNodes = [{ nodeId: 'N1' }, { nodeId: 'N2' }];
        (Node.find as jest.Mock).mockResolvedValue(mockNodes);

        const result = await nodeService.getAllNodes();

        expect(Node.find).toHaveBeenCalled();
        expect(result).toHaveLength(2);
    });
});

```

## 4. Simulation

#### simulation\Dockerfile
```
FROM python:3.10 AS base

WORKDIR /app

RUN apt-get update && apt-get install -y \
    libgl1 \
    libglib2.0-0 \
    libopenblas-dev \
    liblapack-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM base AS development
COPY . .
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

FROM base AS production
COPY src ./src
ENV PYTHONUNBUFFERED=1
EXPOSE 8000
CMD ["sh", "-c", "uvicorn src.api.server:app --host 0.0.0.0 --port ${PORT:-8080}"]

```

#### simulation\requirements.txt
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
numpy==1.24.3
opencv-python-headless==4.8.1.78

pymongo==4.6.0
motor==3.3.2
python-dateutil==2.8.2
pytz==2023.3

```

#### simulation\src\__init__.py
```python

```

#### simulation\src\anomalies\detector.py
```python
from typing import List

class AnomalyDetector:
    def detect(self, entities: List[dict]) -> List[dict]:
        anomalies = []
        
        # 1. Check Crowd Compression
        # Radius check -> if many entities in small area
        
        # 2. Check Speed
        for e in entities:
             if abs(e.get('velocity', {}).get('x', 0)) > 10: # >10m/s
                 anomalies.append({
                     'id': f"SPEED_{e['id']}",
                     'type': 'KINETICS',
                     'headline': f"High Speed Detected: {e['id']}",
                     'severity': 'MEDIUM'
                 })
                 
        return anomalies

```

#### simulation\src\anomalies\generator.py
```python
import numpy as np
from typing import List, Dict, Optional
import uuid
from datetime import datetime

class AnomalyGenerator:
    """
    Generates realistic anomalies based on entity behavior and scenario context.
    """
    
    def __init__(self):
        self.baselines = {}  # Zone -> baseline metrics
        self.anomaly_rate = 2.0  # anomalies per minute (configurable)
        self.last_anomaly_time = 0
        self.min_anomaly_interval = 5.0  # seconds between anomalies
        
    def detect(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """
        Check for anomalies based on entity behavior.
        Returns list of anomaly dicts.
        """
        anomalies = []
        
        # Update baselines
        self._update_baselines(entities, scenario)
        
        # 1. Crowd Compression (Geographics + Proxemics)
        for zone in scenario.zones:
            compression = self._check_crowd_compression(entities, zone, timestamp)
            if compression:
                anomalies.append(compression)
        
        # 2. Speed Violations (Kinetics)
        speed_anomalies = self._check_speed_anomalies(entities, timestamp)
        anomalies.extend(speed_anomalies)
        
        # 3. Loitering (Atmospherics)
        loitering = self._check_loitering(entities, timestamp)
        anomalies.extend(loitering)
        
        # 4. Restricted Zone Entry (Geographics)
        trespass = self._check_restricted_zones(entities, scenario, timestamp)
        anomalies.extend(trespass)
        
        # Apply Rule of Three
        anomalies = self._apply_rule_of_three(anomalies, timestamp)
        
        return anomalies
    
    def _check_crowd_compression(self, entities: List[Dict], zone, timestamp: float) -> Optional[Dict]:
        """Detect crowd compression/crush risk."""
        # Filter entities in this zone
        entities_in_zone = [
            e for e in entities 
            if self._entity_in_zone(e, zone)
        ]
        
        if not entities_in_zone:
            return None
        
        # Calculate density
        area = zone.area
        density = len(entities_in_zone) / area
        
        # Get baseline
        baseline_key = f"{zone.name}_density"
        baseline_density = self.baselines.get(baseline_key, 0.5)
        
        # Threshold: 2.5× baseline or >4 people/m² (crowd crush risk)
        threshold = max(baseline_density * 2.5, 4.0)
        
        if density > threshold:
            severity = 'CRITICAL' if density > 6.0 else 'HIGH'
            
            return {
                'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                'type': 'GEOGRAPHICS',
                'subtype': 'CROWD_COMPRESSION',
                'severity': severity,
                'scenario': 'CRUSH',
                'headline': f'{zone.name} Crowd Compression Risk',
                'description': f'Density {density:.1f} people/m², {density/baseline_density:.1f}× baseline',
                'baselineText': f'Normal density: {baseline_density:.1f} people/m²',
                'anomalyText': f'Current density: {density:.1f} people/m² ({len(entities_in_zone)} in {area:.0f}m²)',
                'zone': zone.name,
                'location': zone.center if hasattr(zone, 'center') else {'x': 0, 'y': 0, 'z': 0},
                'entityIds': [e['id'] for e in entities_in_zone],
                'metrics': {
                    'baselineDelta': ((density / baseline_density) - 1) * 100,
                    'confidence': 0.95,
                    'riskScore': min(density * 15, 100)
                },
                'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                'ruleOfThreeHit': False
            }
        
        return None
    
    def _check_speed_anomalies(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect excessive speed violations."""
        anomalies = []
        
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            vel = entity.get('velocity', {'x': 0, 'y': 0, 'z': 0})
            speed = np.sqrt(vel['x']**2 + vel['y']**2)  # Horizontal speed
            
            # Thresholds based on role
            role = entity.get('role', 'SPECTATOR')
            if role == 'PLAYER':
                max_speed = 10.0  # m/s (fast sprinting)
            elif role == 'OFFICIAL':
                max_speed = 5.0   # m/s
            else:
                max_speed = 2.0   # m/s (walking speed for spectators)
            
            if speed > max_speed * 1.5:  # 1.5× threshold
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'KINETICS',
                    'subtype': 'SPEED_VIOLATION',
                    'severity': 'MEDIUM',
                    'headline': f'Excessive Speed: {entity["id"]}',
                    'description': f'Entity moving at {speed:.1f} m/s, {(speed/max_speed):.1f}× expected',
                    'baselineText': f'Expected max speed: {max_speed:.1f} m/s for {role}',
                    'anomalyText': f'Current speed: {speed:.1f} m/s',
                    'zone': 'UNKNOWN',  # TODO: Determine zone from position
                    'location': entity['position'],
                    'entityIds': [entity['id']],
                    'metrics': {
                        'baselineDelta': ((speed / max_speed) - 1) * 100,
                        'confidence': 0.88,
                        'riskScore': min(speed * 8, 100)
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
        
        return anomalies
    
    def _check_loitering(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect loitering patterns (entities moving very slowly in same area)."""
        # TODO: Implement with entity history tracking
        return []
    
    def _check_restricted_zones(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """Detect entities entering restricted zones."""
        anomalies = []
        
        restricted_zones = [z for z in scenario.zones if z.type == 'RESTRICTED']
        
        for zone in restricted_zones:
            for entity in entities:
                if entity.get('role') == 'PLAYER':
                    continue  # Players allowed in restricted zones
                    
                if self._entity_in_zone(entity, zone):
                    anomalies.append({
                        'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                        'type': 'GEOGRAPHICS',
                        'subtype': 'RESTRICTED_ZONE_ENTRY',
                        'severity': 'HIGH',
                        'headline': f'Unauthorized Entry: {zone.name}',
                        'description': f'{entity["id"]} entered restricted zone',
                        'baselineText': f'Zone {zone.name} is restricted',
                        'anomalyText': f'{entity["role"]} entity detected in zone',
                        'zone': zone.name,
                        'location': entity['position'],
                        'entityIds': [entity['id']],
                        'metrics': {
                            'baselineDelta': 100,
                            'confidence': 0.92,
                            'riskScore': 75
                        },
                        'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                        'ruleOfThreeHit': False
                    })
        
        return anomalies
    
    def _apply_rule_of_three(self, anomalies: List[Dict], timestamp: float) -> List[Dict]:
        """
        Apply Rule of Three: flag when 3+ independent anomaly types
        converge in same space-time.
        """
        # Group anomalies by proximity
        spatial_threshold = 10.0  # meters
        temporal_threshold = 30.0  # seconds
        
        groups = []
        for anomaly in anomalies:
            placed = False
            for group in groups:
                # Check if anomaly belongs to this group
                representative = group[0]
                
                # Spatial proximity
                loc1 = anomaly['location']
                loc2 = representative['location']
                dist = np.sqrt(
                    (loc1['x'] - loc2['x'])**2 + 
                    (loc1['y'] - loc2['y'])**2
                )
                
                # Temporal proximity
                time_diff = abs(
                    anomaly['occurredAt'].timestamp() - 
                    representative['occurredAt'].timestamp()
                )
                
                if dist < spatial_threshold and time_diff < temporal_threshold:
                    group.append(anomaly)
                    placed = True
                    break
            
            if not placed:
                groups.append([anomaly])
        
        # Check each group for Rule of Three
        for group in groups:
            distinct_types = set(a['type'] for a in group)
            
            if len(distinct_types) >= 3:
                # Mark all anomalies in group
                for anomaly in group:
                    anomaly['ruleOfThreeHit'] = True
                    anomaly['severity'] = 'CRITICAL'  # Escalate
                    anomaly['relatedAnomalies'] = [
                        a['anomalyId'] for a in group if a != anomaly
                    ]
        
        return anomalies
    
    def _update_baselines(self, entities: List[Dict], scenario):
        """Update baseline metrics using exponential moving average."""
        # TODO: Implement proper baseline learning
        # For now, use static baselines
        for zone in scenario.zones:
            baseline_key = f"{zone.name}_density"
            if baseline_key not in self.baselines:
                self.baselines[baseline_key] = 1.0  # 1 person/m² default
    
    def _entity_in_zone(self, entity: Dict, zone) -> bool:
        """Check if entity is inside zone bounds."""
        pos = entity['position']
        bounds = zone.bounds  # (x_min, y_min, x_max, y_max)
        
        return (
            bounds[0] <= pos['x'] <= bounds[2] and
            bounds[1] <= pos['y'] <= bounds[3]
        )

```

#### simulation\src\api\server.py
```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import uvicorn
import os

from src.core.orchestrator import SimulationOrchestrator

orchestrator = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global orchestrator
    # Initialize with default config
    orchestrator = SimulationOrchestrator({})
    print("Simulation Engine Starting...")
    yield
    # Shutdown
    if orchestrator:
        orchestrator.stop()
    print("Simulation Engine Stopping...")

app = FastAPI(lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "simulation-engine"}

@app.post("/simulation/start")
async def start_simulation(config: dict):
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.load_scenario(config.get('sport', 'BASKETBALL'), config)
    orchestrator.start()
    return {"status": "started"}

@app.post("/simulation/stop")
async def stop_simulation():
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.stop()
    return {"status": "stopped"}

    return StreamingResponse(
        orchestrator.get_video_stream(node_id), 
        media_type="multipart/x-mixed-replace; boundary=frame"
    )

@app.post("/nodes/{node_id}/calibrate")
async def calibrate_node(node_id: str):
    """Simulate calibration for a node."""
    if not orchestrator:
         raise HTTPException(status_code=503, detail="Orchestrator not initialized")
    
    import random
    import time
    return {
        "nodeId": node_id,
        "calibration": {
            "reprojectionError": random.uniform(0.01, 0.05),
            "status": "SUCCESS",
            "timestamp": time.time()
        }
    }

@app.get("/")
async def root():
    return {"message": "Motion Intelligence Simulation Engine v1.0"}

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("src.api.server:app", host="0.0.0.0", port=port, reload=True)

```

#### simulation\src\calibration\utils.py
```python
import numpy as np

def generate_default_calibration():
    # Intrinsic (Camera)
    # 1920x1080, FOV ~90 deg
    fx = 1000
    fy = 1000
    cx = 960
    cy = 540
    camera_matrix = [
        [fx, 0, cx],
        [0, fy, cy],
        [0, 0, 1]
    ]
    
    # Extrinsic (Identity for now)
    rotation = np.eye(3).tolist()
    translation = [0, 0, 0]
    
    # Lidar to Camera (Example: Camera is 10cm above LIDAR)
    lidar_to_camera = np.eye(4)
    lidar_to_camera[1, 3] = -0.1 # y-axis translation
    
    return {
        'intrinsic': {
            'cameraMatrix': camera_matrix,
            'distortion': [0, 0, 0, 0, 0]
        },
        'extrinsic': {
            'rotationMatrix': rotation,
            'translationVector': translation
        },
        'lidarToCameraTransform': lidar_to_camera.tolist(),
        'calibrationQuality': 100,
        'calibratedAt': '2025-12-16T12:00:00Z'
    }

```

#### simulation\src\core\orchestrator.py
```python
import os
import time
import threading
from typing import List, Optional, Dict
import numpy as np

from .physics_engine import PhysicsEngine
from .scenario_manager import ScenarioManager
from ..nodes.edge_node import EdgeNode
from ..anomalies.generator import AnomalyGenerator
from ..utils.ptp_sync import PTPClock

class SimulationOrchestrator:
    def __init__(self, config: dict):
        self.config = config
        self.running = False
        self.paused = False
        self.thread = None
        
        # Core components
        self.physics_engine = PhysicsEngine()
        self.scenario = None
        self.anomaly_generator = AnomalyGenerator()
        self.clock = PTPClock(is_master=True)
        
        # State
        self.nodes: List[EdgeNode] = []
        self.entities: List[Dict] = []
        self.current_time = 0.0
        self.frame_count = 0
        self.target_fps = 30
        self.actual_fps = 0.0
        
    def load_scenario(self, sport: str, config: dict):
        """Load sport-specific scenario."""
        self.scenario = ScenarioManager.create_scenario(sport, config)
        self.scenario.initialize(self.entities)
        print(f"Loaded scenario: {sport} with {len(self.entities)} entities")
        
    def add_node(self, node_config: dict) -> EdgeNode:
        """Add a sensor node to the simulation."""
        node = EdgeNode(
            node_id=node_config['nodeId'],
            position=np.array([
                node_config['position']['x'],
                node_config['position']['y'],
                node_config['position']['z']
            ]),
            orientation=np.array([
                node_config['orientation']['pitch'],
                node_config['orientation']['yaw'],
                node_config['orientation']['roll']
            ]),
            sensors=node_config['sensors'],
            calibration=node_config.get('calibration', {})
        )
        self.nodes.append(node)
        print(f"Added node: {node_config['nodeId']}")
        return node
        
    def start(self):
        """Start the simulation loop."""
        if self.running:
            return
            
        if not self.scenario:
            # Fallback for empty start
            try:
                self.load_scenario('BASKETBALL', {})
            except:
                print("Failed to load default scenario")
            
        self.running = True
        self.paused = False
        self.thread = threading.Thread(target=self._loop, daemon=True)
        self.thread.start()
        print("Simulation started")
        
    def stop(self):
        """Stop the simulation."""
        self.running = False
        if self.thread:
            self.thread.join()
        print("Simulation stopped")
        
    def pause(self):
        """Pause the simulation."""
        self.paused = True
        
    def resume(self):
        """Resume the simulation."""
        self.paused = False
        
    def _loop(self):
        """Main simulation loop - runs at 30 FPS."""
        target_dt = 1.0 / self.target_fps
        last_fps_check = time.time()
        fps_frame_count = 0
        
        while self.running:
            if self.paused:
                time.sleep(0.1)
                continue
                
            loop_start = time.time()
            
            # 1. Update simulation time (PTP clock)
            self.current_time = self.clock.get_time() / 1e9  # Convert ns to seconds
            
            # 2. Update entity behaviors (scenario-specific)
            if self.scenario:
                self.scenario.update(self.entities, target_dt)
            
            # 3. Update physics (entity movement)
            self.physics_engine.step(self.entities, target_dt)
            
            # 4. Generate sensor data from all nodes
            # For this MVP, we just generate generating logs or frames
            # Logic to publish via WebSocket would go here
            # 4. Generate sensor data from all nodes
            for node in self.nodes:
                # This updates internal buffers like last_camera_frame
                node.generate_frame(
                    entities=self.entities,
                    timestamp=self.current_time
                )
            
            # 5. Detect anomalies
            if self.scenario:
                anomalies = self.anomaly_generator.detect(
                    entities=self.entities,
                    scenario=self.scenario,
                    timestamp=self.current_time
                )
                for anomaly in anomalies:
                    self._publish_anomaly(anomaly)
            
            # 6. Update frame counter
            self.frame_count += 1
            fps_frame_count += 1
            
            # 7. Calculate actual FPS every second
            now = time.time()
            if now - last_fps_check >= 1.0:
                self.actual_fps = fps_frame_count / (now - last_fps_check)
                fps_frame_count = 0
                last_fps_check = now
                # print(f"Simulation FPS: {self.actual_fps:.1f} | Entities: {len(self.entities)}")
            
            # 8. Sleep to maintain frame rate
            elapsed = time.time() - loop_start
            if elapsed < target_dt:
                time.sleep(target_dt - elapsed)
                
            # Broadcast updates (Every 3 frames approx 10Hz)
            if self.frame_count % 3 == 0:
                self._publish_entities()

    def _publish_entities(self):
        """Send entity positions to API."""
        try:
            # Basic validation
            if not self.entities:
                return

            payload = {
                'sessionId': None, # TODO: Pass session ID if managed
                'stats': {
                    'fps': self.actual_fps,
                    'frame': self.frame_count,
                    'time': self.current_time
                },
                'sentAt': time.time(),
                'entities': [
                    {
                        'id': e.get('id'),
                        'type': e.get('type'),
                        'role': e.get('role'),
                        'team': e.get('team'),
                        'position': e.get('position'),
                        'velocity': e.get('velocity'),
                        'color': e.get('color'),
                        'radius': e.get('radius'),
                        'severity': e.get('severity')
                    }
                    for e in self.entities
                ]
            }
            
            # Fire and forget POST
            # Using threads or async here would be better for performance, 
            # but for this simulation loop strictness, a short timeout is acceptable logic 
            # if we assume local network.
            try:
                import requests
                api_url = os.getenv('API_URL', 'http://api:3001')
                response = requests.post(
                    f"{api_url}/internal/entity-update",
                    json=payload,
                    timeout=0.2 
                )
                if response.status_code != 200:
                    print(f"Warning: API returned status {response.status_code} for entity-update")
            except ImportError:
                print("requests module not found")
            except Exception as e:
                # print(f"Failed to publish entities: {e}")
                pass # Still suppress to avoid loop crash, but could log periodically
                
        except Exception as e:
            print(f"Error publishing entities: {e}")

    def _publish_anomaly(self, anomaly):
        """Publish detected anomaly."""
        try:
            import requests
            requests.post(
                f"{os.getenv('API_URL', 'http://api:3001')}/internal/anomaly",
                json={
                    'sessionId': None,
                    'anomaly': anomaly
                },
                timeout=0.1
            )
        except Exception as e:
            print(f"Failed to publish anomaly: {e}")

    def get_video_stream(self, node_id: str):
        """Generator for MJPEG stream from a specific node."""
        node = next((n for n in self.nodes if n.node_id == node_id), None)
        if not node:
            return

        while self.running:
            frame = node.last_camera_frame
            if frame:
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
            
            # rate limit to approx 30 fps to avoid busy loop
            time.sleep(0.033)



```

#### simulation\src\core\physics_engine.py
```python
import numpy as np
from typing import List

class PhysicsEngine:
    def __init__(self):
        self.gravity = -9.81
        self.friction_coeff = 0.5

    def step(self, entities: List[dict], dt: float):
        """
        Update entity positions based on velocity and forces.
        """
        for entity in entities:
            # Simple Euler integration
            vel = np.array(entity.get('velocity', [0, 0, 0]), dtype=float)
            pos = np.array(entity.get('position', [0, 0, 0]), dtype=float)
            
            # Apply friction (damping)
            vel = vel * (1.0 - self.friction_coeff * dt)
            
            # Update position
            pos += vel * dt
            
            # Floor constraint (z >= 0)
            if pos[2] < 0:
                pos[2] = 0
                vel[2] = 0
            
            # Update entity state
            entity['position'] = {
                'x': float(pos[0]),
                'y': float(pos[1]),
                'z': float(pos[2])
            }
            entity['velocity'] = {
                'x': float(vel[0]),
                'y': float(vel[1]),
                'z': float(vel[2])
            }

```

#### simulation\src\core\scenario_manager.py
```python
from typing import List, Dict, Optional
import numpy as np

class Zone:
    def __init__(self, name: str, bounds: tuple, area: float, type: str):
        self.name = name
        self.bounds = bounds # (x_min, y_min, x_max, y_max)
        self.area = area
        self.type = type
        self.center = {
            'x': (bounds[0] + bounds[2]) / 2,
            'y': (bounds[1] + bounds[3]) / 2,
            'z': 0
        }

class Scenario:
    def __init__(self):
        self.zones: List[Zone] = []
        self.entities: List[dict] = []
        self.sport = 'UNKNOWN'

    def initialize(self, entities: List[dict]):
        """Populate initial entities"""
        pass

    def update(self, entities: List[dict], dt: float):
        """Update entity behaviors"""
        pass

class ScenarioManager:
    @staticmethod
    def create_scenario(sport: str, config: dict) -> Scenario:
        if sport == 'BASKETBALL':
            from ..sports.basketball import BasketballScenario
            return BasketballScenario(config)
        else:
            raise ValueError(f"Unknown sport: {sport}")

```

#### simulation\src\nodes\camera_simulator.py
```python
import numpy as np
import cv2
import time
from typing import List, Tuple, Optional

class CameraSimulator:
    def __init__(self, resolution: dict, fps: int, fov: float):
        self.width = resolution['width']
        self.height = resolution['height']
        self.fps = fps
        self.fov = fov
        self.last_frame_time = 0
        self.frame_interval = 1.0 / fps

    def render(self, entities: List[dict], timestamp: float) -> Optional[bytes]:
        """
        Render a frame if enough time has passed.
        Returns JPEG bytes or None.
        """
        # Simple frame rate control
        if timestamp - self.last_frame_time < self.frame_interval:
            return None
            
        self.last_frame_time = timestamp
        
        # Create blank image (dark gray background)
        image = np.full((self.height, self.width, 3), 30, dtype=np.uint8)
        
        # Draw entities (simplified 2D projection for now)
        for entity in entities:
             # Basic projection logic (placeholder)
             # In a real 3D sim, we'd use a projection matrix
             pos = entity.get('position', {'x':0, 'y':0, 'z':0})
             
             # Map x/y to screen coordinates (very rough approx)
             cx = int(self.width / 2 + pos['x'] * 50) 
             cy = int(self.height / 2 + pos['y'] * 50)
             
             if 0 <= cx < self.width and 0 <= cy < self.height:
                 cv2.circle(image, (cx, cy), 10, (0, 255, 0), -1)
                 cv2.putText(image, entity.get('id', '?'), (cx+15, cy), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        # Add noise
        noise = np.random.normal(0, 5, image.shape).astype(np.uint8)
        image = cv2.add(image, noise)
        
        # Encode to JPEG
        _, encoded = cv2.imencode('.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 80])
        return encoded.tobytes()

```

#### simulation\src\nodes\edge_node.py
```python
from typing import List, Dict, Any
import numpy as np
from .camera_simulator import CameraSimulator
from .lidar_simulator import LidarSimulator
from .imu_simulator import IMUSimulator

class EdgeNode:
    def __init__(self, node_id: str, position: np.ndarray, orientation: np.ndarray, sensors: dict, calibration: dict):
        self.node_id = node_id
        self.position = position
        self.orientation = orientation
        self.calibration = calibration
        self.last_camera_frame = None
        
        # Initialize Sensors
        self.camera = None
        if sensors.get('camera', {}).get('enabled'):
            cam_config = sensors['camera']
            self.camera = CameraSimulator(
                resolution=cam_config.get('resolution', {'width': 1920, 'height': 1080}),
                fps=cam_config.get('fps', 30),
                fov=cam_config.get('fov', 90)
            )
            
        self.lidar = None
        if sensors.get('lidar', {}).get('enabled'):
            lid_config = sensors['lidar']
            self.lidar = LidarSimulator(
                model=lid_config.get('model', 'VLP-16'),
                channels=lid_config.get('channels', 16),
                range_m=lid_config.get('range', 100)
            )
            
        self.imu = None
        if sensors.get('imu', {}).get('enabled'):
            self.imu = IMUSimulator(sample_rate=100)

    def generate_frame(self, entities: List[dict], timestamp: float) -> Dict[str, Any]:
        """Generate a synchronized frame from all enabled sensors."""
        frame = {
            'nodeId': self.node_id,
            'timestamp': timestamp,
            'sensors': {}
        }
        
        # Transform entities to node-local coordinates if needed
        # For now, simulators handle global entities
        
        if self.camera:
            image_data = self.camera.render(entities, timestamp)
            if image_data:
                frame['sensors']['camera'] = image_data # In real app, this would be a path or heavy blob
                self.last_camera_frame = image_data
        
        if self.lidar:
            point_cloud = self.lidar.scan(entities, timestamp)
            frame['sensors']['lidar'] = point_cloud # Numpy array
            
        if self.imu:
            imu_data = self.imu.read(timestamp, self.position) # Simplified IMU read
            frame['sensors']['imu'] = imu_data
            
        return frame

```

#### simulation\src\nodes\fusion_engine.py
```python
import numpy as np
from typing import List, Dict

class FusionEngine:
    """
    Fuses camera + LIDAR data at edge node.
    Core learning objective: demonstrates sensor fusion concepts.
    """
    
    def __init__(self, camera_matrix=None, lidar_to_camera_transform=None):
        # Defaults if not provided
        self.camera_matrix = camera_matrix if camera_matrix is not None else np.eye(3)
        self.transform = lidar_to_camera_transform if lidar_to_camera_transform is not None else np.eye(4)
        
    def _project_lidar_to_image(self, points):
        """Project 3D LIDAR points to 2D camera coordinates."""
        if len(points) == 0:
            return np.array([])
            
        # 1. Transform Lidar -> Camera frame
        # We assume standard Camera frame: X right, Y down, Z forward
        # Simple simulation hack: rotate points to align with camera Z
        # R_lidar_cam = np.array([[0, -1, 0], [0, 0, -1], [1, 0, 0]])
        # points_cam = points @ R_lidar_cam.T + np.array([0, 0, 0])
        
        # For simplicity in this demo, treat world X,Y as 'flat' image plane scaling
        focal_length = 1000
        
        u = focal_length * (points[:, 0] / (points[:, 1] + 1e-6)) + 960  # Center X
        v = focal_length * (points[:, 2] / (points[:, 1] + 1e-6)) + 540  # Center Y (Z is up in input, Y down in image)
        
        # Filter points behind camera (Y < 0)
        valid_mask = points[:, 1] > 0
        
        projected = np.zeros((len(points), 3))
        projected[:, 0] = u
        projected[:, 1] = v
        projected[:, 2] = valid_mask
        
        return projected

    def _iou(self, point, bbox):
        """Check if point is inside bbox."""
        x, y = point[0], point[1]
        x1, y1, x2, y2 = bbox
        return x1 <= x <= x2 and y1 <= y <= y2

    def fuse(self, camera_image, lidar_points, entities):
        """
        Perform fusion of camera and LIDAR data.
        Returns: List of detected entities with 3D positions derived from LIDAR clusters.
        """
        detections = []
        
        # 1. Project LIDAR points to camera image
        projected_points_2d = self._project_lidar_to_image(lidar_points[:, :3])
        
        # 2. Run 2D object detection (Simulated)
        bboxes = self._detect_objects_2d(camera_image, entities)
        
        # 3. Associate and Fuse
        for bbox_data in bboxes:
            bbox = bbox_data['bbox']
            
            # Find points inside this bbox
            points_inside_indices = []
            for i, pt in enumerate(projected_points_2d):
                if pt[2] > 0 and self._iou(pt, bbox): # Check validity and bounds
                    points_inside_indices.append(i)
            
            # Fuse: Compute centroid of associated LIDAR points
            if points_inside_indices:
                cluster = lidar_points[points_inside_indices]
                fused_pos = np.mean(cluster[:, :3], axis=0)
                confidence = 0.9 + (len(points_inside_indices) / 100.0) # More points = higher confidence
            else:
                # Fallback if no LIDAR hits (e.g. occlusion): use purely visual estimate or prior
                # For simulaton, fallback to entity truth + large noise
                target_entity = next((e for e in entities if e['id'] == bbox_data['entity_id']), None)
                if target_entity:
                    pos = target_entity['position']
                    fused_pos = np.array([pos['x'], pos['y'], pos['z']]) + np.random.normal(0, 0.5, 3)
                    confidence = 0.5
                else:
                    continue

            detections.append({
                'entityId': bbox_data['entity_id'],
                'position3d': fused_pos.tolist(),
                'velocity': [0, 0, 0], # Kalman filter would determine this over time
                'confidence': min(confidence, 1.0),
                'bbox2d': bbox
            })
        
        return detections

    def _detect_objects_2d(self, image, entities):
        """Simulate YOLO detection."""
        bboxes = []
        for entity in entities:
            # Simple manual projection for bounding box simulation
            pos = entity['position']
            # Scale world coords to 'pixel' coords roughly
            cx = 960 + (pos['x'] * 50) 
            cy = 540 - (pos['z'] * 50) 
            w, h = 60 / (pos['y']*0.1 + 1), 120 / (pos['y']*0.1 + 1)
            
            bboxes.append({
                'entity_id': entity['id'],
                'bbox': [cx - w/2, cy - h/2, cx + w/2, cy + h/2],
                'confidence': 0.95
            })
        return bboxes

```

#### simulation\src\nodes\imu_simulator.py
```python
import numpy as np

class IMUSimulator:
    def __init__(self, sample_rate: int):
        self.sample_rate = sample_rate
        self.accel_bias = np.random.normal(0, 0.01, 3)
        self.gyro_bias = np.random.normal(0, 0.001, 3)

    def sample(self, timestamp: float, motion: dict) -> dict:
        """
        Generate IMU reading based on actual motion.
        """
        true_accel = motion.get('acceleration', np.zeros(3))
        true_gyro = motion.get('angular_velocity', np.zeros(3))
        
        # Add noise and bias
        accel_noise = np.random.normal(0, 0.01, 3)
        gyro_noise = np.random.normal(0, 0.001, 3)
        
        accel = true_accel + self.accel_bias + accel_noise
        gyro = true_gyro + self.gyro_bias + gyro_noise
        
        # Add gravity (assuming z is up)
        accel[2] += 9.81
        
        return {
            'acceleration': accel.tolist(),
            'gyroscope': gyro.tolist(),
            'temperature': 45.0 + np.random.normal(0, 0.1)
        }

```

#### simulation\src\nodes\lidar_simulator.py
```python
import numpy as np
from typing import List, Tuple

class LidarSimulator:
    def __init__(self, model: str, channels: int, range_m: float):
        self.model = model
        self.channels = channels
        self.range = range_m
        self.points_per_second = 300000

    def scan(self, entities: List[dict], timestamp: float) -> np.ndarray:
        """
        Generate a point cloud.
        Returns numpy array of (x, y, z, intensity).
        """
        # Generate background points (ground plane)
        # Simplified: Grid of points
        x = np.linspace(-20, 20, 100)
        y = np.linspace(-20, 20, 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X) # Ground is at z=0
        
        # Flatten
        ground_points = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1)
        
        entity_points = []
        for entity in entities:
            pos = entity.get('position', {'x':0, 'y':0, 'z':0})
            # Generate a cluster of points for the entity
            num_points = 50
            # Gaussian distribution around entity position
            ep = np.random.normal([pos['x'], pos['y'], pos['z']], 0.2, (num_points, 3))
            entity_points.append(ep)
            
        if entity_points:
            all_entity_points = np.vstack(entity_points)
            points = np.vstack([ground_points, all_entity_points])
        else:
            points = ground_points

        # Add intensity (random for now)
        intensities = np.random.rand(len(points), 1)
        
        return np.hstack([points, intensities]).astype(np.float32)

```

#### simulation\src\sports\basketball.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class BasketballScenario(Scenario):
    """NBA-style basketball simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'BASKETBALL'
        
        # Court dimensions (NBA standard in meters)
        self.court_length = 28.65
        self.court_width = 15.24
        
        # Zones
        self.zones = [
            Zone(
                name='COURT',
                bounds=self._court_bounds(),
                area=self.court_length * self.court_width,
                type='FIELD'
            ),
            Zone(
                name='HOME_BENCH',
                bounds=(0, 0, 5, 2),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='AWAY_BENCH',
                bounds=(0, self.court_width - 2, 5, self.court_width),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='PAINT_HOME',
                bounds=(0, self.court_width/2 - 2.44, 5.8, self.court_width/2 + 2.44),
                area=28.3,
                type='RESTRICTED'
            )
        ]
        
        self.crowd_count = config.get('crowdCount', 5000) if config else 5000
        
    def initialize(self, entities: List[Dict]):
        """Set up players, refs, ball, crowd."""
        
        # Home team (5 players)
        for i in range(5):
            pos = self._get_formation_position('HOME', i)
            entity = {
                'id': f'HOME_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'HOME',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (255, 0, 0),  # Red
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Away team (5 players)
        for i in range(5):
            pos = self._get_formation_position('AWAY', i)
            entity = {
                'id': f'AWAY_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'AWAY',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (0, 0, 255),  # Blue
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Referees (3)
        for i in range(3):
            entity = {
                'id': f'REF_{i+1}',
                'type': 'PERSON',
                'role': 'OFFICIAL',
                'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 1.8,
                'color': (128, 128, 128),  # Gray
                'reflectance': 0.4,
                'behavior': 'referee'
            }
            entities.append(entity)
        
        # Basketball
        entity = {
            'id': 'BALL',
            'type': 'OBJECT',
            'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 1.5},
            'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
            'radius': 0.12,
            'color': (255, 165, 0),  # Orange
            'reflectance': 0.6
        }
        entities.append(entity)
        
        # Crowd (simplified - grouped entities)
        self._generate_crowd(entities, self.crowd_count)
        
        print(f"Basketball scenario initialized: {len(entities)} entities")
        
    def update(self, entities: List[Dict], dt: float):
        """Update entity behaviors each frame."""
        for entity in entities:
            behavior = entity.get('behavior')
            
            if behavior == 'basketball_player':
                self._update_player_behavior(entity, entities, dt)
            elif behavior == 'referee':
                self._update_referee_behavior(entity, entities, dt)
        
        # Update ball physics (bouncing, possession)
        self._update_ball(entities, dt)
        
    def _get_formation_position(self, team: str, index: int) -> tuple:
        """Get initial position for player in formation."""
        # Simple positioning - half court
        if team == 'HOME':
            x_base = self.court_length * 0.25
        else:
            x_base = self.court_length * 0.75
            
        # Spread players across court width
        y = (self.court_width / 6) * (index + 1)
        
        return (x_base, y)
        
    def _update_player_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Basic basketball player AI."""
        # Find ball
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Move towards ball (simplified)
        dx = ball['position']['x'] - entity['position']['x']
        dy = ball['position']['y'] - entity['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 0.5:  # Not at ball
            # Move towards ball
            speed = 3.0  # m/s
            entity['velocity']['x'] = (dx / dist) * speed
            entity['velocity']['y'] = (dy / dist) * speed
        else:
            # At ball - slow down
            entity['velocity']['x'] *= 0.5
            entity['velocity']['y'] *= 0.5
            
    def _update_referee_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Referee follows play."""
        # Similar to player but slower
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if ball:
            dx = ball['position']['x'] - entity['position']['x']
            dy = ball['position']['y'] - entity['position']['y']
            dist = np.sqrt(dx**2 + dy**2)
            
            if dist > 3.0:
                speed = 2.0
                entity['velocity']['x'] = (dx / dist) * speed
                entity['velocity']['y'] = (dy / dist) * speed
                
    def _update_ball(self, entities: List[Dict], dt: float):
        """Update ball physics."""
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Gravity
        ball['velocity']['z'] -= 9.81 * dt
        
        # Bounce on floor
        if ball['position']['z'] <= 0.12:  # Ball radius
            ball['position']['z'] = 0.12
            ball['velocity']['z'] = -ball['velocity']['z'] * 0.7  # Bounce with loss
            
    def _court_bounds(self) -> tuple:
        """Return (x_min, y_min, x_max, y_max)."""
        return (0, 0, self.court_length, self.court_width)
        
    def _generate_crowd(self, entities: List[Dict], count: int):
        """Generate crowd entities (simplified grouping)."""
        # Stands are outside court boundaries
        # Create grouped "crowd sections" rather than individual spectators
        num_sections = 8
        people_per_section = count // num_sections
        
        for i in range(num_sections):
            entity = {
                'id': f'CROWD_SECTION_{i+1}',
                'type': 'GROUP',
                'role': 'SPECTATOR',
                'count': people_per_section,
                'position': {
                    'x': np.random.uniform(-5, self.court_length + 5),
                    'y': np.random.uniform(-5, self.court_width + 5),
                    'z': 0.0
                },
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 2.0,  # Group radius
                'color': (100, 100, 200),
                'reflectance': 0.3
            }
            entities.append(entity)

```

#### simulation\src\sports\combat.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class CombatScenario(Scenario):
    """MMA/Boxing style simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'COMBAT'
        self.ring_size = 9.0 # meters
        
        self.zones = [
            Zone(name='RING', bounds=(0,0,self.ring_size,self.ring_size), area=81, type='RING'),
            Zone(name='RINGSIDE', bounds=(-2,-2,self.ring_size+2,self.ring_size+2), area=150, type='RESTRICTED')
        ]

    def initialize(self, entities: List[Dict]):
        # Fighter 1
        entities.append({
            'id': 'FIGHTER_1', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (255, 0, 0)
        })
        
        # Fighter 2
        entities.append({
            'id': 'FIGHTER_2', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size*2/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (0, 0, 255)
        })
        
        # Referee
        entities.append({
            'id': 'REF', 'type': 'PERSON', 'role': 'OFFICIAL',
            'position': {'x': self.ring_size/2, 'y': self.ring_size/4, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.75, 'color': (200, 200, 200)
        })

    def update(self, entities: List[Dict], dt: float):
        f1 = next(e for e in entities if e['id'] == 'FIGHTER_1')
        f2 = next(e for e in entities if e['id'] == 'FIGHTER_2')
        
        # Circle each other
        center_x = (f1['position']['x'] + f2['position']['x']) / 2
        center_y = (f1['position']['y'] + f2['position']['y']) / 2
        
        for f in [f1, f2]:
            dx = center_x - f['position']['x']
            dy = center_y - f['position']['y']
            # Add orbit logic here... simplified
            f['velocity']['x'] += (np.random.rand()-0.5) * 2.0
            f['velocity']['y'] += (np.random.rand()-0.5) * 2.0

```

#### simulation\src\sports\soccer.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class SoccerScenario(Scenario):
    """FIFA-style soccer simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'SOCCER'
        
        # Field dimensions (Standard 105m x 68m)
        self.field_length = 105.0
        self.field_width = 68.0
        
        # Zones
        self.zones = [
            Zone(
                name='FIELD',
                bounds=(0, 0, self.field_length, self.field_width),
                area=self.field_length * self.field_width,
                type='FIELD'
            ),
             Zone(
                name='PENALTY_AREA_HOME',
                bounds=(0, self.field_width/2 - 20.15, 16.5, self.field_width/2 + 20.15),
                area=665.0, # Approx
                type='RESTRICTED'
            ),
             Zone(
                name='PENALTY_AREA_AWAY',
                bounds=(self.field_length - 16.5, self.field_width/2 - 20.15, self.field_length, self.field_width/2 + 20.15),
                area=665.0,
                type='RESTRICTED'
            )
        ]
        
    def initialize(self, entities: List[Dict]):
        # Home Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('HOME', i)
            entities.append(self._create_player(f'HOME_{i+1}', 'HOME', pos, (255, 0, 0)))

        # Away Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('AWAY', i)
            entities.append(self._create_player(f'AWAY_{i+1}', 'AWAY', pos, (0, 0, 255)))
            
        # Ball
        entities.append({
            'id': 'BALL', 'type': 'OBJECT', 
            'position': {'x': self.field_length/2, 'y': self.field_width/2, 'z': 0.11},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.11, 'color': (255, 255, 255)
        })

    def update(self, entities: List[Dict], dt: float):
        # Very simple AI: chase ball
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball: return
        
        for e in entities:
            if e.get('role') == 'PLAYER':
                self._update_player(e, ball, dt)

    def _create_player(self, pid, team, pos, color):
        return {
            'id': pid, 'type': 'PERSON', 'role': 'PLAYER', 'team': team,
            'position': {'x': pos[0], 'y': pos[1], 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.8, 'color': color, 'behavior': 'soccer_player'
        }

    def _get_formation_position(self, team, index):
        # 4-4-2 Formation stub
        base_x = 10 if team == 'HOME' else self.field_length - 10
        direction = 1 if team == 'HOME' else -1
        
        if index == 0: # GK
            return (base_x, self.field_width/2)
        elif index < 5: # Defenders
            return (base_x + 15*direction, self.field_width * (index/5))
        elif index < 9: # Midfielders
            return (base_x + 35*direction, self.field_width * ((index-4)/5))
        else: # Forwards
            return (base_x + 55*direction, self.field_width * ((index-8)/3))

    def _update_player(self, player, ball, dt):
        # Chase ball logic similar to basketball
        dx = ball['position']['x'] - player['position']['x']
        dy = ball['position']['y'] - player['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 1.0:
            speed = 4.0
            player['velocity']['x'] = (dx/dist) * speed
            player['velocity']['y'] = (dy/dist) * speed

```

#### simulation\src\utils\ptp_sync.py
```python
import time
import numpy as np

class PTPClock:
    """
    IEEE 1588 Precision Time Protocol simulation.
    Simulates clock drift and offset correction.
    """
    
    def __init__(self, is_master: bool = True):
        self.is_master = is_master
        self.epoch = time.time_ns()
        self.crystal_frequency = 1e9  # 1 GHz nominal
        # Simulate hardware clock drift (parts per million)
        self.ppm_drift = np.random.uniform(-30, 30) if not is_master else 0.0
        self.offset_ns = 0
        
    def get_time(self) -> int:
        """Get current PTP time in nanoseconds."""
        elapsed = time.time_ns() - self.epoch
        # Apply simulated drift
        drift_factor = 1.0 + (self.ppm_drift / 1e6)
        
        return int(elapsed * drift_factor) + self.offset_ns + self.epoch
    
    def get_time_sec(self) -> float:
        """Get current PTP time in seconds."""
        return self.get_time() / 1e9
    
    def sync_with_master(self, master_time: int):
        """Synchronize slave clock with master time sample."""
        if self.is_master:
            return
            
        current_time = self.get_time()
        offset = master_time - current_time
        
        # Simple PI controller for smooth clock discipline
        # In a real PTP stack this is much more complex
        self.offset_ns += int(offset * 0.5)

```

#### simulation\tests\test_camera_simulator.py
```python
import unittest
import numpy as np
from src.nodes.camera_simulator import CameraSimulator

class TestCameraSimulator(unittest.TestCase):
    def setUp(self):
        self.camera = CameraSimulator(
            resolution={'width': 1920, 'height': 1080},
            fps=30,
            fov=90
        )
    
    def test_render_returns_bytes_when_due(self):
        # Timestamp 0.0 -> should render
        # Timestamp 0.001 -> should NOT render (too soon for 30fps)
        
        entities = [{'id': 'E1', 'position': {'x': 0, 'y': 0, 'z': 5}}]
        
        # First frame
        frame1 = self.camera.render(entities, timestamp=1.0)
        self.assertIsNotNone(frame1)
        self.assertIsInstance(frame1, bytes)
        
        # Too soon
        frame2 = self.camera.render(entities, timestamp=1.01)
        self.assertIsNone(frame2)
        
        # Next frame due (approx 33ms later)
        frame3 = self.camera.render(entities, timestamp=1.04)
        self.assertIsNotNone(frame3)

if __name__ == '__main__':
    unittest.main()

```

#### simulation\tests\test_performance.py
```python
import time
import unittest
from src.core.orchestrator import SimulationOrchestrator

class TestPerformance(unittest.TestCase):
    def test_fps_stability(self):
        # This test ensures the loop runs at ~30 FPS
        # We'll just run a few iter and check time
        
        # Mock orchestrator behavior without threading for test
        orch = SimulationOrchestrator()
        
        start_time = time.time()
        frames = 30
        
        for i in range(frames):
            orch._generate_sensor_data()
            orch._detect_anomalies()
            time.sleep(1/30) # Simulate loop wait
            
        elapsed = time.time() - start_time
        fps = frames / elapsed
        
        print(f"Measured FPS: {fps}")
        self.assertTrue(25 < fps < 35, f"FPS {fps} out of range")

if __name__ == '__main__':
    unittest.main()

```

## 5. Frontend

#### frontend\Dockerfile
```
# Build Stage
FROM node:18-slim AS builder
WORKDIR /app
COPY package.json ./
RUN npm install
COPY . .
# Skip type check based on previous tsconfig relaxation, but run build
RUN npm run build

# Serve Stage
FROM node:18-slim
WORKDIR /app
RUN npm install -g serve
COPY --from=builder /app/dist ./dist
EXPOSE 80
CMD ["serve", "-s", "dist", "-l", "80"]

```

#### frontend\index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motion Intelligence Grid</title>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

#### frontend\package.json
```json
{
    "name": "motiongrid-frontend",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.1",
        "three": "^0.160.0",
        "@react-three/fiber": "^8.15.12",
        "@react-three/drei": "^9.92.4",
        "socket.io-client": "^4.6.2",
        "recharts": "^2.10.3",
        "axios": "^1.6.2",
        "date-fns": "^2.30.0",
        "zustand": "^4.4.7",
        "clsx": "^2.0.0",
        "tailwind-merge": "^2.1.0",
        "lucide-react": "^0.294.0",
        "class-variance-authority": "^0.7.0"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@types/three": "^0.160.0",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.3.6",
        "typescript": "^5.2.2",
        "vite": "^5.0.8"
    }
}
```

#### frontend\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "module": "ESNext",
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        /* Linting */
        "strict": false,
        "noImplicitAny": false,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": [
        "src"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
```

#### frontend\tsconfig.node.json
```json
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "vite.config.ts"
    ]
}
```

#### frontend\vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        host: true,
        allowedHosts: true, // Allow Cloud Run domains
        port: 5173,
        proxy: {
            '/api': {
                target: 'http://localhost:3001',
                changeOrigin: true
            }
        }
    }
})

```

#### frontend\src\App.tsx
```typescript
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AppShell } from './components/layout/AppShell';
import { AuthProvider, useAuth } from './context/AuthContext';
import { Login } from './views/Login';

import Dashboard from './views/Dashboard/Dashboard';
import SystemConfig from './views/SystemConfig/SystemConfig';

import { LiveMonitoring } from './views/LiveMonitoring/index';
import { SessionReplay } from './views/SessionReplay/SessionReplay';
import { AnalyticsDashboard } from './views/Analytics/AnalyticsDashboard';

import { PlaceholderView } from './components/common/PlaceholderView';

import { SessionsList } from './views/Sessions/SessionsList';
import { AnomalyTriage } from './views/Triage/AnomalyTriage';
import { EntityProfile } from './views/Entities/EntityProfile';
import { EntitiesList } from './views/Entities/EntitiesList';

const RequireAuth = ({ children }: { children: JSX.Element }) => {
    const { isAuthenticated } = useAuth();
    const location = useLocation();

    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }
    return children;
};

function App() {
    return (
        <AuthProvider>
            <Router>
                <Routes>
                    <Route path="/login" element={<Login />} />

                    <Route path="/*" element={
                        <RequireAuth>
                            <AppShell>
                                <Routes>
                                    <Route path="/" element={<Dashboard />} />
                                    <Route path="/live" element={<LiveMonitoring />} />
                                    <Route path="/replay/:id" element={<SessionReplay />} />
                                    <Route path="/analytics" element={<AnalyticsDashboard />} />
                                    <Route path="/config" element={<SystemConfig />} />

                                    {/* New Features - No Longer Placeholders */}
                                    <Route path="/sessions" element={<SessionsList />} />
                                    <Route path="/sessions/:id" element={<SessionReplay />} />
                                    <Route path="/triage" element={<AnomalyTriage />} />
                                    <Route path="/entities" element={<EntitiesList />} />
                                    <Route path="/entities/:id" element={<EntityProfile />} />

                                    <Route path="/automation" element={<PlaceholderView title="Automation Rules" />} />

                                    {/* Fallback */}
                                    <Route path="*" element={<PlaceholderView title="404: Page Not Found" description="The page you are looking for does not exist." />} />
                                </Routes>
                            </AppShell>
                        </RequireAuth>
                    } />
                </Routes>
            </Router>
        </AuthProvider>
    )
}

export default App

```

#### frontend\src\index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  background-color: #020617;
  /* navy-950 */
  color: #f8fafc;
  /* light text */
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
```

#### frontend\src\main.tsx
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

```

#### frontend\src\vite-env.d.ts
```typescript
/// <reference types="vite/client" />

```

#### frontend\src\components\common\PlaceholderView.tsx
```typescript
import React from 'react';
import { Construction } from 'lucide-react';
import { Card } from '../ui/Card';

interface PlaceholderViewProps {
    title: string;
    description?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
    title,
    description = "This feature is currently under development. Check back soon for updates."
}) => {
    return (
        <div className="p-6 h-full flex items-center justify-center">
            <Card className="max-w-md w-full p-8 text-center flex flex-col items-center gap-4 bg-navy-800 border-navy-700">
                <div className="w-16 h-16 bg-navy-900 rounded-full flex items-center justify-center border border-navy-700 shadow-inner">
                    <Construction className="w-8 h-8 text-primary-400" />
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white mb-2">{title}</h2>
                    <p className="text-slate-400 leading-relaxed">
                        {description}
                    </p>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\components\layout\AppShell.tsx
```typescript
import { Sidebar } from './Sidebar';
import { TopBar } from './TopBar';

interface AppShellProps {
    children: React.ReactNode;
}

export function AppShell({ children }: AppShellProps) {
    return (
        <div className="min-h-screen bg-navy-950 text-slate-200 font-sans selection:bg-secondary-500/30">
            <TopBar />
            <Sidebar />

            <main className="pl-[260px] pt-[80px] min-h-screen transition-all duration-300">
                <div className="max-w-[1920px] mx-auto p-6 animate-in fade-in duration-500 slide-in-from-bottom-4">
                    {children}
                </div>
            </main>
        </div>
    );
}

```

#### frontend\src\components\layout\Sidebar.tsx
```typescript
import {
    LayoutDashboard,
    Radio,
    Server,
    Settings,
    Bell,
    Search,
    Menu,
    Play,
    LayoutGrid,
    Activity,
    Video,
    BarChart3,
    Zap,
    AlertTriangle,
    Users,
    HelpCircle,
    LogOut
} from 'lucide-react';
import { NavLink } from 'react-router-dom';
import { cn } from '../../utils/cn';

const NAV_ITEMS = [
    { label: 'Overview', path: '/', icon: LayoutGrid },
    { label: 'Live Intelligence', path: '/live', icon: Activity },
    { label: 'Session Replay', path: '/replay/mock-session-1', icon: Play }, // Added for easy access
    { label: 'System Config', path: '/config', icon: Settings },
    { label: 'Sessions', path: '/sessions', icon: Video },
    { label: 'Analytics', path: '/analytics', icon: BarChart3 },
    { label: 'Automation', path: '/automation', icon: Zap },
    { label: 'Triage', path: '/triage', icon: AlertTriangle },
    { label: 'Entities', path: '/entities', icon: Users },
];

export function Sidebar() {
    return (
        <aside className="w-[260px] bg-navy-900 border-r border-navy-800 fixed left-0 top-0 bottom-0 pt-[80px] flex flex-col z-40">
            <div className="flex-1 overflow-y-auto py-6 px-3 space-y-1">
                <div className="text-xs font-bold text-slate-500 uppercase px-4 mb-2 tracking-wider">Menu</div>
                {NAV_ITEMS.map((item) => (
                    <NavLink
                        key={item.path}
                        to={item.path}
                        className={({ isActive }) => cn(
                            "flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200",
                            isActive
                                ? "bg-secondary-600/10 text-secondary-400 border border-secondary-600/20 shadow-[0_0_15px_rgba(99,102,241,0.1)]"
                                : "text-slate-400 hover:bg-navy-800 hover:text-slate-200"
                        )}
                    >
                        <item.icon className="w-5 h-5" />
                        {item.label}
                    </NavLink>
                ))}
            </div>

            <div className="p-4 border-t border-navy-800 space-y-1">
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-navy-800 hover:text-slate-200 transition-colors">
                    <HelpCircle className="w-5 h-5" />
                    Help & Docs
                </button>
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-red-900/20 hover:text-red-400 transition-colors">
                    <LogOut className="w-5 h-5" />
                    Logout
                </button>
            </div>
        </aside>
    );
}

```

#### frontend\src\components\layout\TopBar.tsx
```typescript
import { Bell, Settings, User, Search } from 'lucide-react';
import { Button } from '../ui/Button';

export function TopBar() {
    return (
        <header className="h-[80px] bg-navy-950 border-b border-navy-800 flex items-center justify-between px-6 fixed top-0 left-0 right-0 z-50">
            {/* Left: Logo & Context */}
            <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-lg flex items-center justify-center shadow-lg shadow-primary-500/20">
                        <svg className="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <span className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-400 to-secondary-400">
                        MotionGrid
                    </span>
                </div>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div className="flex items-center gap-2 text-slate-400 bg-navy-900 py-2 px-4 rounded-lg border border-navy-800">
                    <Search className="w-4 h-4" />
                    <span className="text-sm">Global Search...</span>
                </div>
            </div>

            {/* Right: Actions & Profile */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" className="relative" onClick={() => alert("Notifications coming soon!")}>
                    <Bell className="w-5 h-5 text-slate-400" />
                    <span className="absolute top-2 right-2 w-2 h-2 bg-status-critical rounded-full animate-pulse" />
                </Button>
                <Button variant="ghost" size="icon" onClick={() => alert("Settings panel coming soon!")}>
                    <Settings className="w-5 h-5 text-slate-400" />
                </Button>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div
                    className="flex items-center gap-3 pl-2 cursor-pointer hover:bg-navy-900 p-2 rounded-lg transition-colors"
                    onClick={() => alert("User profile management coming soon!")}
                >
                    <div className="text-right hidden md:block">
                        <div className="text-sm font-semibold text-white">Admin User</div>
                        <div className="text-xs text-primary-400">OPERATOR</div>
                    </div>
                    <div className="w-10 h-10 bg-navy-800 rounded-full flex items-center justify-center border border-navy-700">
                        <User className="w-5 h-5 text-slate-300" />
                    </div>
                </div>
            </div>
        </header>
    );
}

```

#### frontend\src\components\ui\Badge.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const badgeVariants = cva(
    "inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide transition-colors",
    {
        variants: {
            variant: {
                default: "bg-navy-700 text-white",
                critical: "bg-status-critical text-white shadow-[0_0_10px_rgba(220,38,38,0.4)]",
                high: "bg-status-high text-white",
                medium: "bg-status-medium text-white",
                low: "bg-status-low text-white",
                success: "bg-status-success text-white",
                outline: "border border-navy-700 text-slate-400 bg-transparent",
            },
            size: {
                sm: "text-[10px] px-2 py-0.5",
                md: "text-xs px-3 py-1",
                lg: "text-sm px-4 py-1.5",
            }
        },
        defaultVariants: {
            variant: "default",
            size: "md",
        }
    }
);

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof badgeVariants> { }

export function Badge({ className, variant, size, ...props }: BadgeProps) {
    return (
        <span className={badgeVariants({ variant, size, className })} {...props} />
    );
}

```

#### frontend\src\components\ui\Button.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';
import React from 'react';

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-lg text-sm font-semibold transition-all focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none active:scale-95",
    {
        variants: {
            variant: {
                primary: "bg-secondary-600 text-white hover:bg-secondary-500 shadow-lg shadow-secondary-900/20",
                secondary: "border border-navy-700 bg-transparent text-slate-300 hover:bg-navy-800",
                danger: "bg-status-critical text-white hover:bg-red-700",
                ghost: "bg-transparent text-slate-400 hover:text-white hover:bg-navy-800",
                icon: "p-2 bg-transparent text-slate-400 hover:bg-navy-800 hover:text-white rounded-md",
            },
            size: {
                sm: "px-3 py-1.5 text-xs",
                md: "px-4 py-2",
                lg: "px-6 py-3 text-base",
                icon: "h-9 w-9 p-0",
            },
            fullWidth: {
                true: "w-full",
            }
        },
        defaultVariants: {
            variant: "primary",
            size: "md",
            fullWidth: false,
        }
    }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, fullWidth, ...props }, ref) => {
        return (
            <button
                ref={ref}
                className={buttonVariants({ variant, size, fullWidth, className })}
                {...props}
            />
        );
    }
);
Button.displayName = "Button";

```

#### frontend\src\components\ui\Card.tsx
```typescript
import { cn } from '../../utils/cn';
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    hover?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
    ({ className, hover = true, children, ...props }, ref) => {
        return (
            <div
                ref={ref}
                className={cn(
                    "bg-navy-800 border border-navy-700 rounded-xl shadow-md p-5",
                    "transition-all duration-200 ease-out",
                    hover && "hover:-translate-y-0.5 hover:shadow-lg hover:shadow-black/20 hover:border-navy-600",
                    className
                )}
                {...props}
            >
                {children}
            </div>
        );
    }
);
Card.displayName = "Card";

export function CardHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("mb-4 flex items-center justify-between", className)} {...props}>
            {children}
        </div>
    );
}

export function CardTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
    return (
        <h3 className={cn("text-lg font-bold text-white", className)} {...props}>
            {children}
        </h3>
    );
}

export function CardContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("text-sm text-slate-300 leading-relaxed", className)} {...props}>
            {children}
        </div>
    );
}

```

#### frontend\src\context\AuthContext.tsx
```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import { api } from '../services/api';

interface User {
    id: string;
    email: string;
    role: string;
    username: string;
}

interface AuthContextType {
    user: User | null;
    token: string | null;
    login: (token: string, user: User) => void;
    logout: () => void;
    isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [token, setToken] = useState<string | null>(null);

    useEffect(() => {
        // Init from local storage
        const storedToken = localStorage.getItem('token');
        const storedUser = localStorage.getItem('user');

        if (storedToken && storedUser) {
            try {
                setToken(storedToken);
                setUser(JSON.parse(storedUser));
                // Set default header
                api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
            } catch (e) {
                console.error("Failed to parse stored user", e);
                localStorage.clear();
            }
        }
    }, []);

    const login = (newToken: string, newUser: User) => {
        setToken(newToken);
        setUser(newUser);
        localStorage.setItem('token', newToken);
        localStorage.setItem('user', JSON.stringify(newUser));
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
    };

    const logout = () => {
        setToken(null);
        setUser(null);
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        delete api.defaults.headers.common['Authorization'];
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout, isAuthenticated: !!token }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

```

#### frontend\src\services\api.ts
```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';

export const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

export const Api = {
    // Nodes
    getNodes: async () => (await api.get('/nodes')).data,
    getNode: async (id: string) => (await api.get(`/nodes/${id}`)).data,
    createNode: async (data: any) => (await api.post('/nodes', data)).data,
    updateNode: async (id: string, data: any) => (await api.patch(`/nodes/${id}`, data)).data,
    deleteNode: async (id: string) => (await api.delete(`/nodes/${id}`)).data,
    calibrateNode: async (id: string) => (await api.post(`/nodes/${id}/calibrate`)).data,

    // Sessions
    getSessions: async () => (await api.get('/sessions')).data,
    getSession: async (id: string) => (await api.get(`/sessions/${id}`)).data,
    createSession: async (data: any) => (await api.post('/sessions', data)).data,
    updateSession: async (id: string, data: any) => (await api.patch(`/sessions/${id}`, data)).data,
    deleteSession: async (id: string) => (await api.delete(`/sessions/${id}`)).data,
    startSession: async (id: string) => (await api.post(`/sessions/${id}/start`)).data,
    stopSession: async (id: string) => (await api.post(`/sessions/${id}/stop`)).data,

    // Simulation
    startSimulation: async (config: any) => (await api.post('/simulation/start', config)).data,
    stopSimulation: async () => (await api.post('/simulation/stop')).data,
    getSimulationStatus: async () => (await api.get('/simulation/status')).data,

    // Entities
    getEntities: async () => (await api.get('/entities')).data,

    // Analytics
    getStats: async () => (await api.get('/analytics/stats')).data
};

```

#### frontend\src\services\websocket.ts
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketService {
    private socket: Socket | null = null;
    private callbacks: Map<string, Function[]> = new Map();

    connect(url: string) {
        const token = localStorage.getItem('auth_token');
        this.socket = io(url, {
            transports: ['websocket'],
            reconnection: true,
            auth: { token }
        });

        this.socket.on('connect', () => {
            console.log('WebSocket connected');
            // Re-subscribe if we had active subscriptions? 
            // For now, simpler to leave it to the components.
        });

        this.socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        // Register for all expected events
        ['sensor:frame', 'anomaly:detected', 'entity:tracking', 'session:stats', 'node:status']
            .forEach(event => {
                this.socket!.on(event, (data: any) => {
                    const cbs = this.callbacks.get(event) || [];
                    cbs.forEach(cb => cb(data));
                });
            });
    }

    subscribeToSession(sessionId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:session', { sessionId });
    }

    subscribeToNode(nodeId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:node', { nodeId });
    }

    on(event: string, callback: Function) {
        if (!this.callbacks.has(event)) {
            this.callbacks.set(event, []);
        }
        this.callbacks.get(event)!.push(callback);
    }

    off(event: string, callback: Function) {
        if (!this.callbacks.has(event)) return;
        const cbs = this.callbacks.get(event) || [];
        this.callbacks.set(event, cbs.filter(cb => cb !== callback));
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
}

export const wsService = new WebSocketService();

```

#### frontend\src\utils\cn.ts
```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

```

#### frontend\src\views\Login.tsx
```typescript
import React, { useState } from 'react';
import { useAuth } from '../context/AuthContext';
import { api } from '../services/api';
import { useNavigate, useLocation } from 'react-router-dom';
import { KeyRound, Mail, User, Loader2 } from 'lucide-react';

export const Login: React.FC = () => {
    const { login } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    // Redirect to where they came from (or dashboard)
    const from = (location.state as any)?.from?.pathname || '/';

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            const response = await api.post('/auth/login', { email, password });
            const { token, user } = response.data;
            login(token, user);
            navigate(from, { replace: true });
        } catch (err: any) {
            console.error(err);
            setError(err.response?.data?.error || 'Login failed. Please check your credentials.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-slate-950 flex items-center justify-center p-4">
            <div className="bg-slate-900 border border-slate-800 rounded-xl max-w-md w-full p-8 shadow-2xl">
                <div className="text-center mb-8">
                    <div className="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-4 shadow-lg shadow-blue-900/50">
                        <KeyRound className="w-8 h-8 text-white" />
                    </div>
                    <h2 className="text-3xl font-bold text-white mb-2">Welcome Back</h2>
                    <p className="text-slate-400">Sign in to Motion Intelligence Grid</p>
                </div>

                {error && (
                    <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4 mb-6 text-red-500 text-sm">
                        {error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Email Address</label>
                        <div className="relative">
                            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="operator@motiongrid.com"
                            />
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Password</label>
                        <div className="relative">
                            <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="••••••••"
                            />
                        </div>
                    </div>

                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg transition shadow-lg shadow-blue-900/20 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                    >
                        {loading ? (
                            <>
                                <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                                Signing in...
                            </>
                        ) : (
                            'Sign In'
                        )}
                    </button>
                </form>

                <div className="mt-6 text-center text-sm text-slate-500">
                    <p>Default Admin: admin@freeforge.com / nimda</p>
                </div>
            </div>
        </div>
    );
};

```

#### frontend\src\views\Analytics\AnalyticsDashboard.tsx
```typescript
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';

export const AnalyticsDashboard = () => {
    return (
        <div className="p-6 space-y-6 text-white h-full overflow-y-auto">
            <h1 className="text-2xl font-bold mb-4">System Analytics</h1>

            {/* KPI Grid */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <KPICard title="Total Sessions" value="1,284" trend="+12%" />
                <KPICard title="Avg. Anomaly Rate" value="0.4/hr" trend="-5%" trendGood />
                <KPICard title="Active Nodes" value="24/24" trend="100%" />
                <KPICard title="Data Throughput" value="1.2 GB/s" trend="+8%" />
            </div>

            {/* Charts Section */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">Anomaly Distribution by Type</h3>
                    <div className="flex items-end justify-around h-60 gap-4 pb-2 border-b border-slate-700">
                        <Bar height="30%" label="Speed" color="bg-blue-500" />
                        <Bar height="60%" label="Crowd" color="bg-purple-500" />
                        <Bar height="15%" label="Zone" color="bg-yellow-500" />
                        <Bar height="45%" label="Formation" color="bg-green-500" />
                    </div>
                </Card>

                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">System Load (24h)</h3>
                    {/* Simple SVG Line Chart */}
                    <div className="h-60 w-full relative">
                        <svg className="w-full h-full overflow-visible">
                            <defs>
                                <linearGradient id="grad" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="#0ea5e9" stopOpacity="0.5" />
                                    <stop offset="100%" stopColor="#0ea5e9" stopOpacity="0" />
                                </linearGradient>
                            </defs>
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20 V150 H0 Z"
                                fill="url(#grad)"
                            />
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20"
                                fill="none"
                                stroke="#0ea5e9"
                                strokeWidth="3"
                            />
                        </svg>
                        <div className="absolute bottom-0 w-full text-xs text-slate-500 flex justify-between">
                            <span>00:00</span>
                            <span>06:00</span>
                            <span>12:00</span>
                            <span>18:00</span>
                            <span>24:00</span>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const KPICard = ({ title, value, trend, trendGood = false }: any) => (
    <Card className="p-4">
        <div className="text-slate-400 text-sm">{title}</div>
        <div className="text-2xl font-bold mt-1">{value}</div>
        <div className={`text-xs mt-2 ${trendGood || trend.startsWith('+') ? 'text-green-400' : 'text-slate-500'}`}>
            {trend} vs last week
        </div>
    </Card>
);

const Bar = ({ height, label, color }: any) => (
    <div className="flex flex-col items-center flex-1 h-full justify-end group">
        <div className={`w-full max-w-[40px] rounded-t-sm ${color} transition-all duration-500`} style={{ height }}></div>
        <div className="text-xs text-slate-400 mt-2">{label}</div>
    </div>
);

```

#### frontend\src\views\Dashboard\Dashboard.tsx
```typescript
import { AnomalyPanel } from './components/AnomalyPanel';
import { DashboardControls } from './components/DashboardControls';
import { StadiumMap } from './components/StadiumMap';
import { DashboardSparkline } from './components/DashboardSparkline';

const Dashboard = () => {
    return (
        <div className="space-y-6">
            <DashboardControls />

            <div className="flex flex-col lg:flex-row gap-6">
                {/* Main View: Stadium Map */}
                <div className="flex-1">
                    <StadiumMap />

                    {/* Bottom Sparkline */}
                    <div className="mt-6 h-[100px] bg-navy-900 border border-navy-800 rounded-xl relative overflow-hidden p-2">
                        <DashboardSparkline />
                    </div>
                </div>

                {/* Right Panel: Anomalies */}
                <AnomalyPanel />
            </div>
        </div>
    );
};

export default Dashboard;

```

#### frontend\src\views\Dashboard\components\AnomalyPanel.tsx
```typescript
import { Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { Badge } from '../../../components/ui/Badge';

const ANOMALIES = [
    { id: 1, time: '11:22', zone: 'Gate B', type: 'Crowd Compression', severity: 'critical', score: 87, delta: '+150%' },
    { id: 2, time: '11:20', zone: 'Concourse N', type: 'Rapid Movement', severity: 'high', score: 65, delta: '+80%' },
    { id: 3, time: '11:15', zone: 'Field', type: 'Unauthorized Access', severity: 'medium', score: 45, delta: 'N/A' },
    { id: 4, time: '11:10', zone: 'Gate A', type: 'Loitering', severity: 'low', score: 20, delta: '+15%' },
];

export function AnomalyPanel() {
    return (
        <div className="w-full lg:w-[360px] bg-navy-900 border border-navy-800 rounded-2xl flex flex-col h-[600px]">
            {/* Header */}
            <div className="p-4 border-b border-navy-800 flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-bold text-white">Active Anomalies</h3>
                    <div className="text-xs text-slate-400">23 Detected • <span className="text-status-critical">4 Critical</span></div>
                </div>
                <div className="flex gap-2">
                    <Button variant="ghost" size="icon"><Filter className="w-4 h-4" /></Button>
                    <Button variant="ghost" size="icon"><MoreHorizontal className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* List */}
            <div className="flex-1 overflow-y-auto p-3 space-y-3">
                {ANOMALIES.map((item) => (
                    <div
                        key={item.id}
                        className="group bg-navy-800 rounded-xl p-3 border border-navy-700 hover:border-indigo-500/50 hover:bg-navy-800/80 transition-all cursor-pointer relative overflow-hidden"
                    >
                        {/* Severity Indicator Bar */}
                        <div className={`absolute left-0 top-0 bottom-0 w-1 ${item.severity === 'critical' ? 'bg-status-critical' :
                            item.severity === 'high' ? 'bg-status-high' :
                                item.severity === 'medium' ? 'bg-status-medium' : 'bg-status-low'
                            }`} />

                        <div className="pl-3">
                            <div className="flex justify-between items-start mb-1">
                                <Badge variant={item.severity as any} size="sm">{item.severity}</Badge>
                                <span className="text-xs font-mono text-slate-500">{item.time}</span>
                            </div>

                            <h4 className="font-bold text-white text-sm mb-1 group-hover:text-indigo-300 transition-colors">{item.type}</h4>
                            <div className="flex justify-between items-center text-xs">
                                <span className="text-slate-400 uppercase tracking-wide font-semibold">{item.zone}</span>
                                <div className="flex gap-3 text-slate-500">
                                    <span>Risk: <span className={item.score > 80 ? 'text-red-400' : 'text-slate-300'}>{item.score}</span></span>
                                    <span>Δ: {item.delta}</span>
                                </div>
                            </div>
                        </div>

                        {/* Hover Actions Overlay (Simulated) */}
                        <div className="absolute right-2 bottom-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button size="sm" variant="secondary" className="h-7 text-xs px-2">View</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-navy-800 bg-navy-950/50 rounded-b-2xl">
                <Button variant="primary" fullWidth size="md">View All Anomalies</Button>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardControls.tsx
```typescript
import { Calendar, ChevronDown } from 'lucide-react';

export function DashboardControls() {
    return (
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6 bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
            {/* Event Selector */}
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-indigo-500/20 rounded-lg flex items-center justify-center text-indigo-400">
                    <Calendar className="w-5 h-5" />
                </div>
                <div>
                    <div className="text-xs text-slate-400 uppercase font-bold tracking-wide">Current Event</div>
                    <div className="flex items-center gap-2 text-white font-semibold cursor-pointer hover:text-indigo-400 transition-colors">
                        Match Day: Team A vs Team B
                        <ChevronDown className="w-4 h-4" />
                    </div>
                </div>
            </div>

            {/* Time Range Chips */}
            <div className="flex bg-navy-900 rounded-lg p-1 border border-navy-700">
                {['Now', 'Last 30m', 'Last 2h', '24h', 'Custom'].map((range, idx) => (
                    <button
                        key={range}
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${idx === 0
                            ? 'bg-secondary-600 text-white shadow-md'
                            : 'text-slate-400 hover:text-white hover:bg-navy-700'
                            }`}
                    >
                        {range}
                    </button>
                ))}
            </div>

            {/* System Status */}
            <div className="flex items-center gap-2 px-4 py-2 bg-status-success/10 border border-status-success/20 rounded-lg text-status-success">
                <span className="relative flex h-2.5 w-2.5">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
                </span>
                <span className="text-sm font-bold tracking-wide">SYSTEM OPTIMAL</span>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardSparkline.tsx
```typescript
import { Area, AreaChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts';

const generateMockData = () => {
    const data = [];
    for (let i = 0; i < 24; i++) {
        data.push({
            time: `${i}:00`,
            events: Math.floor(Math.random() * 50) + 10,
            anomalies: Math.floor(Math.random() * 5),
        });
    }
    return data;
};

const data = generateMockData();

export function DashboardSparkline() {
    return (
        <div className="w-full h-full">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={data}>
                    <defs>
                        <linearGradient id="colorEvents" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#818cf8" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#818cf8" stopOpacity={0} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis hide />
                    <Tooltip
                        contentStyle={{ backgroundColor: '#1e293b', borderColor: '#334155', color: '#f8fafc' }}
                        itemStyle={{ color: '#818cf8' }}
                        labelStyle={{ color: '#94a3b8' }}
                    />
                    <Area
                        type="monotone"
                        dataKey="events"
                        stroke="#818cf8"
                        fillOpacity={1}
                        fill="url(#colorEvents)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\StadiumMap.tsx
```typescript
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ZONES = [
    { id: 'gate-a', name: 'GATE A', type: 'GATE', status: 'critical', x: '10%', y: '20%' },
    { id: 'gate-b', name: 'GATE B', type: 'GATE', status: 'normal', x: '80%', y: '20%' },
    { id: 'field', name: 'FIELD', type: 'FIELD', status: 'normal', x: '45%', y: '45%' },
    { id: 'concourse-n', name: 'CONCOURSE N', type: 'CONCOURSE', status: 'high', x: '45%', y: '10%' },
    { id: 'concourse-s', name: 'CONCOURSE S', type: 'CONCOURSE', status: 'normal', x: '45%', y: '80%' },
];

export function StadiumMap() {
    return (
        <div className="relative w-full h-[600px] bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden shadow-inner">
            {/* Grid Pattern Background */}
            <div className="absolute inset-0 opacity-10"
                style={{ backgroundImage: 'radial-gradient(circle, #334155 1px, transparent 1px)', backgroundSize: '30px 30px' }}
            />

            {/* Stadium Visual Placeholder - Simple SVG representation */}
            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 600">
                {/* Field */}
                <rect x="250" y="150" width="500" height="300" rx="40" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <circle cx="500" cy="300" r="50" fill="none" stroke="#334155" strokeWidth="2" />
                <line x1="500" y1="150" x2="500" y2="450" stroke="#334155" strokeWidth="2" />

                {/* Zones Outline */}
                <path d="M 150 100 Q 500 0 850 100 L 900 250 L 850 500 Q 500 600 150 500 L 100 250 Z"
                    fill="none" stroke="#4f46e5" strokeWidth="2" strokeDasharray="10 5" opacity="0.3" />
            </svg>

            {/* Zone Cards Overlay */}
            {ZONES.map((zone) => (
                <div
                    key={zone.id}
                    className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer transition-transform hover:scale-105 hover:z-10"
                    style={{ left: zone.x, top: zone.y }}
                >
                    <Card className={`w-48 p-3 bg-navy-800/90 backdrop-blur-sm border-l-4 ${zone.status === 'critical' ? 'border-l-status-critical shadow-[0_0_20px_rgba(220,38,38,0.2)]' :
                            zone.status === 'high' ? 'border-l-status-high' :
                                'border-l-status-success'
                        }`}>
                        <div className="flex justify-between items-start mb-2">
                            <span className="text-xs font-bold text-slate-300 tracking-wider">{zone.name}</span>
                            <Badge variant={zone.status as any} size="sm">{zone.status}</Badge>
                        </div>
                        <div className="space-y-1">
                            <div className="text-xs text-slate-400">Last event: 2m ago</div>
                            <div className="text-xs text-slate-400">Anomalies: <span className="text-white font-mono">3</span></div>
                        </div>
                    </Card>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\Entities\EntitiesList.tsx
```typescript

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Search, Filter, Eye } from 'lucide-react';
import { api } from '../../services/api';

interface Entity {
    id: string;
    type: string;
    role?: string;
    team?: string;
    lastSeen: number;
    status: 'ACTIVE' | 'INACTIVE';
}

export const EntitiesList = () => {
    const navigate = useNavigate();
    const [entities, setEntities] = useState<Entity[]>([]);
    const [search, setSearch] = useState('');

    useEffect(() => {
        const fetchEntities = async () => {
            try {
                // Mock endpoint or real if available
                const data = await api.get('/entities');
                if (Array.isArray(data)) setEntities(data);
            } catch (err) {
                // Determine mock data if API fails (for demo robustness)
                setEntities([
                    { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'HOME_PLAYER_2', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'REF_1', type: 'PERSON', role: 'REFEREE', team: 'NEUTRAL', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'BALL', type: 'OBJECT', role: 'game_ball', lastSeen: Date.now(), status: 'ACTIVE' },
                ]);
            }
        }
        fetchEntities();
    }, []);

    const filtered = entities.filter(e => e.id.toLowerCase().includes(search.toLowerCase()));

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Entity Directory</h1>
                <div className="flex gap-2">
                    <div className="relative">
                        <Search className="absolute left-3 top-2.5 w-4 h-4 text-slate-400" />
                        <input
                            type="text"
                            placeholder="Search entities..."
                            className="bg-slate-900 border border-slate-700 rounded-md pl-9 pr-4 py-2 text-sm focus:outline-none focus:border-blue-500 w-64"
                            value={search}
                            onChange={(e) => setSearch(e.target.value)}
                        />
                    </div>
                    <Button variant="outline"><Filter className="w-4 h-4 mr-2" /> Filter</Button>
                </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filtered.map(entity => (
                    <Card key={entity.id} className="hover:border-blue-500/50 transition-colors cursor-pointer" onClick={() => navigate(`/entities/${entity.id}`)}>
                        <div className="flex justify-between items-start mb-4">
                            <Badge variant={entity.team === 'HOME' ? 'critical' : entity.team === 'AWAY' ? 'primary' : 'outline'}>
                                {entity.role || entity.type}
                            </Badge>
                            <div className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]" />
                        </div>
                        <h3 className="text-lg font-bold mb-1">{entity.id}</h3>
                        <div className="text-slate-400 text-sm mb-4">
                            Last seen: {new Date(entity.lastSeen).toLocaleTimeString()}
                        </div>
                        <div className="flex justify-end">
                            <Button variant="ghost" size="sm">
                                <Eye className="w-4 h-4 mr-2" /> View Profile
                            </Button>
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\Entities\EntityProfile.tsx
```typescript
import { useParams, useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { ArrowLeft, Activity, Shield, MapPin } from 'lucide-react';

export const EntityProfile = () => {
    const { id } = useParams();
    const navigate = useNavigate();

    return (
        <div className="p-6 text-white max-w-5xl mx-auto">
            <Button variant="ghost" size="sm" onClick={() => navigate(-1)} className="mb-4">
                <ArrowLeft className="w-4 h-4 mr-2" /> Back
            </Button>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Profile Header */}
                <Card className="md:col-span-3 p-6 flex items-center gap-6">
                    <div className="w-24 h-24 rounded-full bg-slate-800 flex items-center justify-center text-3xl font-bold text-blue-400">
                        {id?.substring(0, 2).toUpperCase() || 'E'}
                    </div>
                    <div>
                        <h1 className="text-3xl font-bold">{id || 'Unknown Entity'}</h1>
                        <div className="text-slate-400 flex gap-4 mt-2">
                            <span className="flex items-center gap-1"><Shield className="w-4 h-4" /> Security Staff</span>
                            <span className="flex items-center gap-1"><MapPin className="w-4 h-4" /> Zone B</span>
                            <span className="flex items-center gap-1 text-green-400"><Activity className="w-4 h-4" /> Active</span>
                        </div>
                    </div>
                </Card>

                {/* Stats */}
                <Card className="p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Movement Stats</h3>
                    <div className="space-y-4">
                        <Stat label="Avg Speed" value="1.4 m/s" />
                        <Stat label="Distance" value="4.2 km" />
                        <Stat label="Zone Violations" value="0" />
                    </div>
                </Card>

                {/* Recent Activity */}
                <Card className="md:col-span-2 p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Recent Activity Timeline</h3>
                    <div className="space-y-4">
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:45</div>
                            <div>Entered Zone B (North Gate)</div>
                        </div>
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:30</div>
                            <div>Shift Started</div>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const Stat = ({ label, value }: any) => (
    <div className="flex justify-between items-center border-b border-slate-800 pb-2">
        <span className="text-slate-400 text-sm">{label}</span>
        <span className="font-mono">{value}</span>
    </div>
);

```

#### frontend\src\views\LiveMonitoring\AlertPanel.tsx
```typescript
import { useEffect, useState } from 'react';
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';
import { wsService } from '../../services/websocket';

interface Anomaly {
    id: string;
    headline: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    time: string;
}

export const AlertPanel = () => {
    const [alerts, setAlerts] = useState<Anomaly[]>([]);

    useEffect(() => {
        // Connect if not already (MeshView also connects, but idempotent)
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            console.log('Anomaly received:', data);

            // Map Python payload to frontend model
            // Python sends: { anomalyId, headline, severity, occurredAt, ... }
            const newAlert: Anomaly = {
                id: data.anomalyId || 'unknown',
                headline: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                // occurredAt is ISO string now
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };

            setAlerts(prev => [newAlert, ...prev].slice(0, 50)); // Keep last 50
        });

        return () => {
            // Unsubscribe logic if wsService supports it, or just let it exist
        };
    }, []);

    return (
        <div className="bg-gray-800 border-l border-gray-700 w-80 flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-red-400" />
                    Active Alerts
                </h3>
            </div>

            <div className="flex-1 overflow-auto p-4 space-y-3">
                {alerts.length === 0 && (
                    <div className="text-gray-500 text-center text-sm py-8">
                        No active alerts.
                    </div>
                )}
                {alerts.map(alert => (
                    <div key={alert.id} className="bg-gray-700/50 rounded-lg p-3 border border-gray-600 hover:border-gray-500 transition-colors">
                        <div className="flex justify-between items-start mb-2">
                            <span className={`text-xs font-bold px-1.5 py-0.5 rounded ${alert.severity === 'CRITICAL' ? 'bg-red-500/20 text-red-300' :
                                alert.severity === 'HIGH' ? 'bg-orange-500/20 text-orange-300' : 'bg-blue-500/20 text-blue-300'
                                }`}>
                                {alert.severity}
                            </span>
                            <span className="text-xs text-gray-400">{alert.time}</span>
                        </div>
                        <h4 className="text-sm font-medium mb-2">{alert.headline}</h4>

                        {/* Triage Actions */}
                        <div className="flex gap-2 mt-2">
                            <button className="flex-1 flex items-center justify-center gap-1 bg-green-900/30 hover:bg-green-900/50 text-green-300 py-1 rounded text-xs transition-colors">
                                <CheckCircle className="h-3 w-3" /> Confirm
                            </button>
                            <button className="flex-1 flex items-center justify-center gap-1 bg-gray-600/30 hover:bg-gray-600/50 text-gray-300 py-1 rounded text-xs transition-colors">
                                <XCircle className="h-3 w-3" /> Dismiss
                            </button>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\CameraGrid.tsx
```typescript

import { useEffect, useState } from 'react';
import { Camera } from 'lucide-react';
import { VideoPlaceholder } from './components/VideoPlaceholder';
import { Api } from '../../../services/api';

interface CameraNode {
    id: string; // real ID (uuid)
    nodeId: string; // human readable (CAM_01)
    status: string;
}

export const CameraGrid = () => {
    const [cameras, setCameras] = useState<CameraNode[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                // Map backend nodes to camera view
                // Backend node has: nodeId (string), id (uuid), config...
                const mapped = data.nodes.map((n: any) => ({
                    id: n._id,
                    nodeId: n.nodeId,
                    status: 'ONLINE' // Assume online if fetched for now
                }));

                if (mapped.length > 0) {
                    setCameras(mapped);
                } else {
                    // Fallback to placeholders if no real nodes found (for demo preservation)
                    setCameras([
                        { id: 'mock1', nodeId: 'CAM_01 (Sim)', status: 'ONLINE' },
                        { id: 'mock2', nodeId: 'CAM_02 (Sim)', status: 'ONLINE' },
                    ]);
                }
            } catch (e) {
                console.error("Failed to fetch camera nodes", e);
                // Fallback
                setCameras([
                    { id: 'mock1', nodeId: 'CAM_01 (Offline)', status: 'OFFLINE' },
                    { id: 'mock2', nodeId: 'CAM_02 (Offline)', status: 'OFFLINE' },
                ]);
            } finally {
                setLoading(false);
            }
        };

        fetchNodes();
    }, []);

    if (loading) {
        return <div className="text-white text-center p-4">Loading streams...</div>;
    }

    return (
        <div className="grid grid-cols-2 gap-2 h-full">
            {cameras.map(cam => (
                <div key={cam.id} className="relative bg-black rounded overflow-hidden group">
                    <div className="absolute inset-0 flex items-center justify-center text-gray-700">
                        {cam.status === 'ONLINE' ? (
                            <div className="flex-1 bg-black relative w-full h-full">
                                {/* Pass nodeId only if it's not a mock ID, or handle mock logic inside VideoPlaceholder? 
                                    Actually, if we want real stream, we need real nodeId (CAM_01 etc from sim).
                                    If mapped from real API, cam.nodeId is what we want.
                                */}
                                <VideoPlaceholder
                                    label={cam.nodeId}
                                    // Use cam.nodeId as endpoint parameter. 
                                    // If it's a mock fallback, this might fail to stream (404) and component will fallback to noise.
                                    nodeId={cam.nodeId}
                                />
                            </div>) : (
                            <div className="flex flex-col items-center">
                                <Camera className="h-8 w-8 mb-2 opacity-50" />
                                <span className="text-xs">OFFLINE</span>
                            </div>
                        )}
                    </div>

                    {/* Overlay */}
                    <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white backdrop-blur-sm">
                        {cam.nodeId}
                    </div>
                    <div className={`absolute top-2 right-2 w-2 h-2 rounded-full ${cam.status === 'ONLINE' ? 'bg-green-500' : 'bg-red-500'}`} />
                </div>
            ))}
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\index.tsx
```typescript
import { useEffect } from 'react';
import { MeshView3D } from './MeshView3D';
import { LayerControls } from './components/LayerControls';
import { LiveAlerts } from './components/LiveAlerts';
import { CameraStrip } from './components/CameraStrip';
import { wsService } from '../../services/websocket';
import { Button } from '../../components/ui/Button';
import { Pause, RefreshCw } from 'lucide-react';

export const LiveMonitoring = () => {
    useEffect(() => {
        const wsUrl = (import.meta as any).env?.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app';
        wsService.connect(wsUrl);
    }, []);

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] gap-4">
            {/* Top Controls */}
            <div className="flex items-center justify-between pb-2 border-b border-navy-800">
                <div className="flex gap-4 items-center">
                    <h2 className="text-lg font-bold text-white">Zone A: Main Concourse</h2>
                    <div className="flex gap-1">
                        <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span className="text-xs text-green-400 font-mono">LIVE FEED</span>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="icon" variant="ghost"><RefreshCw className="w-4 h-4" /></Button>
                    <Button size="icon" variant="secondary"><Pause className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* Main Content Area */}
            <div className="flex flex-1 gap-4 overflow-hidden">
                {/* Left: Layers */}
                <div className="flex-shrink-0">
                    <LayerControls />
                </div>

                {/* Center: 3D View */}
                <div className="flex-1 bg-black rounded-2xl border border-navy-800 relative overflow-hidden group">
                    <MeshView3D />

                    {/* Camera Strip Overlay */}
                    <div className="translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                        <CameraStrip />
                    </div>
                </div>

                {/* Right: Alerts */}
                <div className="flex-shrink-0">
                    <LiveAlerts />
                </div>
            </div>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\MeshView3D.tsx
```typescript
import { useEffect, useState, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text, Html } from '@react-three/drei';
import * as THREE from 'three';
import { wsService } from '../../services/websocket';

interface Entity {
    id: string;
    type: string;
    position: { x: number; y: number; z: number };
    velocity: { x: number; y: number; z: number };
    radius?: number;
    color?: number[];
    severity?: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
}

const EntityMesh = ({ entity }: { entity: Entity }) => {
    // Convert array color or hex to THREE.Color
    const color = useMemo(() => {
        if (Array.isArray(entity.color)) {
            return new THREE.Color(entity.color[0] / 255, entity.color[1] / 255, entity.color[2] / 255);
        }
        return new THREE.Color(entity.color || 'white');
    }, [entity.color]);

    const VelocityArrow = ({ velocity }: { velocity: { x: number; y: number; z: number } }) => {
        const length = Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);
        if (length < 0.1) return null;
        // Normalize direction
        const dir = new THREE.Vector3(velocity.x, velocity.y, velocity.z).normalize();
        return (
            <arrowHelper args={[dir, new THREE.Vector3(0, 0, 0), Math.min(length, 2), 0xffff00]} />
        );
    };

    const RiskHalo = ({ severity }: { severity?: string }) => {
        if (!severity || severity === 'LOW') return null;
        const color = severity === 'CRITICAL' ? 'red' : severity === 'HIGH' ? 'orange' : 'yellow';
        return (
            <mesh position={[0, -0.9, 0]} rotation={[0, 0, 0]}>
                <ringGeometry args={[0.5, 0.7, 32]} />
                <meshBasicMaterial color={color} transparent opacity={0.5} side={THREE.DoubleSide} />
            </mesh>
        );
    };

    return (
        <group position={[entity.position.x, entity.position.y, entity.position.z]}>
            {/* Entity Body */}
            <mesh castShadow receiveShadow>
                <capsuleGeometry args={[entity.radius || 0.3, 1.8, 4, 8]} />
                <meshStandardMaterial color={color} roughness={0.3} metalness={0.1} />
            </mesh>

            <RiskHalo severity={entity.severity} />
            <VelocityArrow velocity={entity.velocity} />

            {/* ID Tag */}
            <Html position={[0, 2.2, 0]} center distanceFactor={15}>
                <div className={`text-[10px] px-1.5 py-0.5 rounded backdrop-blur-md whitespace-nowrap border font-mono
                    ${entity.severity === 'CRITICAL' ? 'bg-red-500/20 border-red-500 text-red-200' :
                        entity.severity === 'HIGH' ? 'bg-orange-500/20 border-orange-500 text-orange-200' :
                            'bg-slate-900/60 border-slate-700 text-slate-300'}`}>
                    {entity.id}
                </div>
            </Html>
        </group>
    );
};

const Floor = () => {
    return (
        <mesh receiveShadow rotation={[0, 0, 0]} position={[0, 0, -0.01]}>
            <planeGeometry args={[100, 100]} />
            <meshStandardMaterial color="#0f172a" roughness={0.8} metalness={0.2} />
            <gridHelper args={[100, 50, 0x334155, 0x1e293b]} rotation={[Math.PI / 2, 0, 0]} />
        </mesh>
    );
};

export const MeshView3D = () => {
    const [entities, setEntities] = useState<Entity[]>([]);
    const [stats, setStats] = useState({ fps: 0, frame: 0, time: 0 });

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');
        const unsubscribe = wsService.on('entity:tracking', (data: { entities: Entity[], stats?: any }) => {
            if (data && data.entities) setEntities(data.entities);
            if (data && data.stats) setStats(data.stats);
        });
        return () => { }; // Connection managed globally or by context in real app
    }, []);

    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden border border-slate-800 relative shadow-inner">
            <div className="absolute top-4 left-4 z-10 space-y-2">
                <div className="bg-slate-900/90 p-3 rounded-lg border border-slate-800 text-xs text-slate-300 backdrop-blur shadow-lg space-y-2">
                    <div className="font-bold text-slate-100 mb-1 border-b border-slate-700 pb-1">Live Telemetry</div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Entities</span>
                        <span className="font-mono text-white text-right">{entities.length}</span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sim FPS</span>
                        <span className={`font-mono text-right ${stats.fps < 25 ? 'text-yellow-400' : 'text-green-400'}`}>
                            {stats.fps.toFixed(1)}
                        </span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sync</span>
                        <div className="flex items-center gap-1.5 justify-end">
                            <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" />
                            <span className="font-mono text-white">ACTIVE</span>
                        </div>
                    </div>
                </div>
            </div>

            <Canvas shadows camera={{ position: [0, -30, 20], fov: 50, up: [0, 0, 1] }}>
                <color attach="background" args={['#020617']} />
                <fog attach="fog" args={['#020617', 20, 90]} />

                <ambientLight intensity={0.4} />
                <directionalLight
                    position={[10, -20, 20]}
                    intensity={1.2}
                    castShadow
                    shadow-mapSize={[1024, 1024]}
                />
                <pointLight position={[-10, 10, 5]} intensity={0.5} color="#3b82f6" />

                <OrbitControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2.1} />

                <Floor />
                <axesHelper args={[2]} position={[0, 0, 0.1]} />

                {entities.map(e => (
                    <EntityMesh key={e.id} entity={e} />
                ))}
            </Canvas>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\components\CameraStrip.tsx
```typescript
export function CameraStrip() {
    return (
        <div className="absolute bottom-4 left-4 right-4 flex gap-4 overflow-x-auto pb-2 scrollbar-hide">
            {[1, 2, 3, 4, 5].map(cam => (
                <div key={cam} className="w-40 h-24 bg-black rounded-lg border border-navy-700 relative flex-shrink-0 group cursor-pointer hover:border-indigo-500 transition-colors">
                    <div className="absolute top-1 left-1 bg-black/50 px-1 rounded text-[10px] text-slate-300">CAM-0{cam}</div>
                    <div className="w-full h-full flex items-center justify-center text-slate-700 text-xs">NO SIGNAL</div>
                    <div className="absolute top-1 right-1 h-2 w-2 bg-green-500 rounded-full shadow-[0_0_5px_rgba(34,197,94,0.5)]"></div>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LayerControls.tsx
```typescript
import { Layers, Eye, Activity, Map, Users, Zap } from 'lucide-react';
import { Card } from '../../../components/ui/Card';

const LAYERS = [
    { id: 'entities', label: 'Entities', icon: Users, default: true },
    { id: 'risk', label: 'Risk Halos', icon: Zap, default: true },
    { id: 'velocity', label: 'Velocity Vectors', icon: Activity, default: false },
    { id: 'trails', label: 'Path Trails', icon: Map, default: false },
    { id: 'social', label: 'Social Radar', icon: Users, default: false },
    { id: 'terrain', label: 'Behavior Terrain', icon: Layers, default: true },
];

export function LayerControls() {
    return (
        <Card className="w-64 bg-navy-900 border-navy-800 flex flex-col gap-4 h-full">
            <div className="flex items-center gap-2 mb-2 pb-2 border-b border-navy-800">
                <Layers className="w-4 h-4 text-indigo-400" />
                <h3 className="font-bold text-white text-sm">View Layers</h3>
            </div>

            <div className="space-y-3">
                {LAYERS.map(layer => (
                    <label key={layer.id} className="flex items-center justify-between group cursor-pointer">
                        <div className="flex items-center gap-3 text-slate-300 group-hover:text-white transition-colors">
                            <layer.icon className="w-4 h-4 text-slate-500 group-hover:text-indigo-400" />
                            <span className="text-sm font-medium">{layer.label}</span>
                        </div>
                        <div className="relative inline-block w-8 h-4 rounded-full cursor-pointer">
                            <input type="checkbox" className="sr-only peer" defaultChecked={layer.default} />
                            <div className="w-8 h-4 bg-navy-800 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-indigo-600"></div>
                        </div>
                    </label>
                ))}
            </div>

            <div className="mt-auto pt-4 border-t border-navy-800">
                <div className="text-xs text-slate-500 mb-2 uppercase font-bold">Camera Overlay</div>
                <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <Eye className="w-4 h-4" /> Show FOV Cones
                    <input type="checkbox" className="ml-auto accent-indigo-500" defaultChecked />
                </label>
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LiveAlerts.tsx
```typescript
import { AlertTriangle, Clock } from 'lucide-react';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ALERTS = [
    { id: 1, type: 'Crowd Crush', risk: 92, time: '10s ago', zone: 'Gate B' },
    { id: 2, type: 'Fight Precursor', risk: 78, time: '32s ago', zone: 'Concourse' },
    { id: 3, type: 'Fallen Object', risk: 45, time: '1m ago', zone: 'Aisle 12' },
];

export function LiveAlerts() {
    return (
        <Card className="w-80 bg-navy-900 border-navy-800 flex flex-col h-full">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-navy-800">
                <div className="flex items-center gap-2">
                    <AlertTriangle className="w-4 h-4 text-status-critical" />
                    <h3 className="font-bold text-white text-sm">Live Alerts</h3>
                </div>
                <Badge variant="critical">3 Active</Badge>
            </div>

            <div className="flex-1 overflow-y-auto space-y-3">
                {ALERTS.map(alert => (
                    <div key={alert.id} className="bg-navy-800 p-3 rounded-lg border border-navy-700 hover:border-red-500/50 transition-colors cursor-pointer group">
                        <div className="flex justify-between items-start mb-1">
                            <span className="text-xs font-bold text-red-300">{alert.type}</span>
                            <span className="text-[10px] text-slate-500 flex items-center gap-1">
                                <Clock className="w-3 h-3" /> {alert.time}
                            </span>
                        </div>
                        <div className="flex justify-between items-end">
                            <div className="text-xs text-slate-400">{alert.zone}</div>
                            <div className="text-sm font-mono font-bold text-white">
                                {alert.risk}% <span className="text-xs font-sans font-normal text-slate-500">Risk</span>
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\VideoPlaceholder.tsx
```typescript
import { useEffect, useRef, useState } from 'react';
import { api } from '../../../services/api';

export function VideoPlaceholder({ label, nodeId }: { label: string, nodeId?: string }) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [useStream, setUseStream] = useState(!!nodeId);
    const [imgError, setImgError] = useState(false);

    // Construct stream URL
    // We need to access the baseURL from axios instance or env
    const baseURL = api.defaults.baseURL || import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';
    const token = localStorage.getItem('auth_token');
    const streamUrl = nodeId ? `${baseURL}/nodes/${nodeId}/stream?token=${token}` : '';

    useEffect(() => {
        if (useStream && !imgError && nodeId) return; // If using stream, don't run canvas animation

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId: number;
        let time = 0;

        const draw = () => {
            time += 0.05;
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a'; // bg-slate-900
            ctx.fillRect(0, 0, width, height);

            // Digital Noise / Scanlines
            for (let i = 0; i < height; i += 4) {
                ctx.fillStyle = `rgba(30, 41, 59, ${Math.random() * 0.5})`;
                ctx.fillRect(0, i, width, 1);
            }

            // Moving "Entities" (Simple Blobs)
            const x = (Math.sin(time) * 0.4 + 0.5) * width;
            const y = (Math.cos(time * 0.7) * 0.4 + 0.5) * height;

            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(79, 70, 229, 0.4)'; // Indigo
            ctx.fill();

            // Overlay Text
            ctx.font = '12px monospace';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('REC', width - 40, 20);
            ctx.fillText(new Date().toLocaleTimeString(), 10, height - 10);
            ctx.fillText(label, 10, 20);

            if (imgError) {
                ctx.fillStyle = '#ef4444';
                ctx.fillText('SIGNAL LOST', width / 2 - 30, height / 2);
            }

            // Recording Dot
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(width - 50, 15, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }

            animationFrameId = window.requestAnimationFrame(draw);
        };

        const resize = () => {
            if (canvas?.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        };

        window.addEventListener('resize', resize);
        resize(); // Initial resize
        draw();

        return () => {
            window.removeEventListener('resize', resize);
            window.cancelAnimationFrame(animationFrameId);
        };
    }, [label, useStream, imgError, nodeId]);

    if (useStream && !imgError && nodeId) {
        return (
            <div className="relative w-full h-full bg-black">
                <img
                    src={streamUrl}
                    alt={label}
                    className="w-full h-full object-cover"
                    onError={() => setImgError(true)}
                />
                {/* Overlay Text for Stream too */}
                <div className="absolute top-0 left-0 p-2 text-xs font-mono text-green-500 w-full flex justify-between">
                    <span>{label}</span>
                    <span>LIVE</span>
                </div>
            </div>
        );
    }

    return (
        <canvas ref={canvasRef} className="w-full h-full block" />
    );
}

```

#### frontend\src\views\SessionReplay\SessionReplay.tsx
```typescript
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button } from '../../components/ui/Button';
import { Card } from '../../components/ui/Card';
import { Play, Pause, SkipBack, SkipForward, ArrowLeft } from 'lucide-react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';

interface SessionData {
    id: string;
    name: string;
    sport: string;
    startTime: string;
    duration: number;
    status: string;
}

export const SessionReplay = () => {
    const { id } = useParams();
    const navigate = useNavigate();
    const [session, setSession] = useState<SessionData | null>(null);
    const [currentTime, setCurrentTime] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const playbackRef = useRef<number>();

    // Mock fetch session details
    useEffect(() => {
        // In real app: fetch(`/api/sessions/${id}`)
        setSession({
            id: id || '1',
            name: 'Championship Final Game 3',
            sport: 'BASKETBALL',
            startTime: new Date().toISOString(),
            duration: 1200, // 20 mins
            status: 'COMPLETED'
        });
    }, [id]);

    // Playback loop
    useEffect(() => {
        if (isPlaying) {
            playbackRef.current = window.setInterval(() => {
                setCurrentTime(prev => {
                    if (prev >= (session?.duration || 0)) {
                        setIsPlaying(false);
                        return prev;
                    }
                    return prev + 1;
                });
            }, 1000); // 1x Speed
        } else {
            clearInterval(playbackRef.current);
        }
        return () => clearInterval(playbackRef.current);
    }, [isPlaying, session]);

    const formatTime = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    return (
        <div className="flex flex-col h-full gap-4 p-4 text-white">
            {/* Header */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="sm" onClick={() => navigate('/sessions')}>
                    <ArrowLeft className="w-4 h-4 mr-2" /> Back
                </Button>
                <div>
                    <h1 className="text-xl font-bold">{session?.name || 'Loading...'}</h1>
                    <div className="text-sm text-slate-400">
                        {session?.sport} • {new Date(session?.startTime || '').toLocaleDateString()}
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 flex gap-4 min-h-0">
                {/* 3D Replay Viewport */}
                <div className="flex-1 bg-slate-950 rounded-xl overflow-hidden relative border border-slate-800">
                    <div className="absolute top-4 left-4 z-10 bg-black/50 px-2 py-1 rounded text-xs">
                        REPLAY MODE
                    </div>
                    <Canvas camera={{ position: [0, -40, 30] }}>
                        <ambientLight intensity={0.5} />
                        <gridHelper args={[100, 100, 0x334155, 0x0f172a]} rotation={[Math.PI / 2, 0, 0]} />
                        <OrbitControls />
                        {/* Placeholder for entities at currentTime */}
                        <mesh position={[Math.sin(currentTime * 0.1) * 5, Math.cos(currentTime * 0.1) * 5, 1]}>
                            <sphereGeometry args={[0.5]} />
                            <meshStandardMaterial color="orange" />
                        </mesh>
                    </Canvas>
                </div>

                {/* Sidebar Stats */}
                <div className="w-80 flex flex-col gap-4">
                    <Card className="flex-1">
                        <div className="p-4">
                            <h3 className="font-semibold mb-4">Events Log</h3>
                            <div className="space-y-2 text-sm text-slate-400">
                                <div className="flex justify-between">
                                    <span>Sync Start</span>
                                    <span>0:00</span>
                                </div>
                                <div className="flex justify-between text-yellow-400">
                                    <span>Anomaly Detected</span>
                                    <span>0:45</span>
                                </div>
                                <div className="flex justify-between text-red-400">
                                    <span>Speed Violation</span>
                                    <span>1:20</span>
                                </div>
                            </div>
                        </div>
                    </Card>
                </div>
            </div>

            {/* Controls Bar */}
            <Card className="p-4 bg-slate-900 border-t border-slate-800">
                <div className="flex flex-col gap-2">
                    {/* Scrubber */}
                    <div className="flex items-center gap-4 text-xs text-slate-400">
                        <span className="w-12 text-right">{formatTime(currentTime)}</span>
                        <input
                            type="range"
                            min="0"
                            max={session?.duration || 100}
                            value={currentTime}
                            onChange={(e) => setCurrentTime(Number(e.target.value))}
                            className="flex-1 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="w-12">{formatTime(session?.duration || 0)}</span>
                    </div>

                    {/* Buttons */}
                    <div className="flex items-center justify-center gap-4">
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.max(0, currentTime - 10))}>
                            <SkipBack className="w-5 h-5" />
                        </Button>
                        <Button
                            variant="primary"
                            size="icon"
                            className="w-12 h-12 rounded-full"
                            onClick={() => setIsPlaying(!isPlaying)}
                        >
                            {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6 ml-1" />}
                        </Button>
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.min(session?.duration || 0, currentTime + 10))}>
                            <SkipForward className="w-5 h-5" />
                        </Button>
                    </div>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\views\Sessions\SessionsList.tsx
```typescript
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Play, Loader2 } from 'lucide-react';
import { api } from '../../services/api';

interface Session {
    id: string;
    sessionId: string;
    startTime: number;
    endTime?: number;
    sport: string;
    anomalies: any[]; // Expecting count or array
}

export const SessionsList = () => {
    const navigate = useNavigate();
    const [sessions, setSessions] = useState<Session[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchSessions = async () => {
            try {
                const data = await api.get('/sessions');
                if (Array.isArray(data)) {
                    // Map or sort data if necessary (latest first)
                    const sorted = data.sort((a: any, b: any) => b.startTime - a.startTime);
                    setSessions(sorted);
                }
            } catch (error) {
                console.error('Failed to fetch sessions:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchSessions();
    }, []);

    const formatDuration = (start: number, end?: number) => {
        if (!end) return 'Live';
        const diff = end - start;
        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        return `${minutes}m ${seconds}s`;
    };

    const formatDate = (ts: number) => new Date(ts).toLocaleDateString() + ' ' + new Date(ts).toLocaleTimeString();

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Recorded Sessions</h1>
                <Button variant="primary" onClick={() => window.location.reload()}>Refresh</Button>
            </div>

            <Card className="overflow-hidden">
                {loading ? (
                    <div className="p-12 flex justify-center text-slate-500">
                        <Loader2 className="animate-spin w-8 h-8" />
                    </div>
                ) : (
                    <table className="w-full text-left text-sm">
                        <thead className="bg-slate-900 uppercase text-slate-400 font-semibold">
                            <tr>
                                <th className="p-4">Session ID</th>
                                <th className="p-4">Sport</th>
                                <th className="p-4">Date</th>
                                <th className="p-4">Duration</th>
                                <th className="p-4">Anomalies</th>
                                <th className="p-4">Status</th>
                                <th className="p-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-800">
                            {sessions.length === 0 && (
                                <tr>
                                    <td colSpan={7} className="p-8 text-center text-slate-500">No sessions found.</td>
                                </tr>
                            )}
                            {sessions.map((session) => (
                                <tr key={session.id || session.sessionId} className="hover:bg-slate-800/50 transition-colors">
                                    <td className="p-4 font-mono text-slate-300">{session.sessionId}</td>
                                    <td className="p-4 font-medium">{session.sport}</td>
                                    <td className="p-4 text-slate-400">{formatDate(session.startTime)}</td>
                                    <td className="p-4 text-slate-400">{formatDuration(session.startTime, session.endTime)}</td>
                                    <td className="p-4">
                                        <Badge variant={session.anomalies?.length > 0 ? 'critical' : 'success'}>
                                            {session.anomalies?.length || 0} Detected
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Badge variant={session.endTime ? 'outline' : 'warning'}>
                                            {session.endTime ? 'COMPLETED' : 'LIVE'}
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            onClick={() => navigate(`/sessions/${session.sessionId}`)}
                                        >
                                            <Play className="w-4 h-4 mr-2" /> Replay
                                        </Button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </Card>
        </div>
    );
};

```

#### frontend\src\views\SystemConfig\SystemConfig.tsx
```typescript
import { useState } from 'react';
import { Network, Activity, Crosshair } from 'lucide-react';
import { Button } from '../../components/ui/Button';
import { NodeTopology } from './components/NodeTopology';
import { SensorHealth } from './components/SensorHealth';
import { CalibrationWizard } from './components/CalibrationWizard';

type Tab = 'topology' | 'health' | 'calibration';

const SystemConfig = () => {
    const [activeTab, setActiveTab] = useState<Tab>('topology');

    return (
        <div className="space-y-6">
            {/* Top Bar Actions */}
            <div className="flex justify-between items-center bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
                <div className="flex gap-2">
                    <Button
                        variant={activeTab === 'topology' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('topology')}
                        className="gap-2"
                    >
                        <Network className="w-4 h-4" /> Node Topology
                    </Button>
                    <Button
                        variant={activeTab === 'health' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('health')}
                        className="gap-2"
                    >
                        <Activity className="w-4 h-4" /> Sensor Health
                    </Button>
                    <Button
                        variant={activeTab === 'calibration' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('calibration')}
                        className="gap-2"
                    >
                        <Crosshair className="w-4 h-4" /> Calibration
                    </Button>
                </div>
                <div className="flex gap-2">
                    <Button variant="secondary" size="sm">Export Config</Button>
                    <Button variant="primary" size="sm">Save Changes</Button>
                </div>
            </div>

            {/* Tab Content */}
            <div className="min-h-[600px]">
                {activeTab === 'topology' && <NodeTopology />}
                {activeTab === 'health' && <SensorHealth />}
                {activeTab === 'calibration' && <CalibrationWizard />}
            </div>
        </div>
    );
};

export default SystemConfig;

```

#### frontend\src\views\SystemConfig\components\CalibrationWizard.tsx
```typescript
import { useState, useEffect } from 'react';
import { Button } from '../../../components/ui/Button';
import { Camera, CheckCircle, RefreshCw, AlertTriangle } from 'lucide-react';
import { Api } from '../../../services/api';

type Step = 'SELECT' | 'CAPTURE' | 'VERIFY' | 'COMPLETE';

export function CalibrationWizard() {
    const [step, setStep] = useState<Step>('SELECT');
    const [progress, setProgress] = useState(0);
    const [selectedNode, setSelectedNode] = useState<string | null>(null);
    const [nodes, setNodes] = useState<any[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    // Fetch nodes
    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                setNodes(data.nodes);
            } catch (err) {
                console.error('Failed to fetch nodes for calibration', err);
            }
        };
        fetchNodes();
    }, []);

    const handleStart = async () => {
        if (!selectedNode) return;
        setStep('CAPTURE');
        setProgress(10);
        setError(null);

        try {
            // Start calibration on backend
            const result = await Api.calibrateNode(selectedNode);

            // Progress animation simulation while waiting or based on real status 
            // but for now we just show it finish
            setProgress(50);
            setTimeout(() => {
                setProgress(100);
                setStep('VERIFY');
            }, 1500);

        } catch (err: any) {
            setError(err.message || 'Calibration failed');
            setStep('SELECT');
        }
    };

    const reset = () => {
        setStep('SELECT');
        setProgress(0);
        setSelectedNode(null);
        setError(null);
    };

    return (
        <div className="h-[500px] bg-navy-900 border border-navy-800 rounded-xl p-6 flex flex-col">
            <div className="mb-6">
                <h3 className="text-xl font-bold text-white mb-2">Sensor Calibration</h3>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <span className={step === 'SELECT' ? 'text-indigo-400 font-bold' : ''}>1. Select Node</span>
                    <span>→</span>
                    <span className={step === 'CAPTURE' ? 'text-indigo-400 font-bold' : ''}>2. Capture</span>
                    <span>→</span>
                    <span className={step === 'VERIFY' ? 'text-indigo-400 font-bold' : ''}>3. Verify</span>
                </div>
            </div>

            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-navy-700 rounded-xl bg-navy-800/30 p-8">
                {step === 'SELECT' && (
                    <div className="text-center space-y-4 w-full">
                        <div className="bg-navy-700 p-4 rounded-full inline-block">
                            <Camera className="w-8 h-8 text-indigo-400" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Select a Node to Calibrate</h4>
                        {error && <div className="text-red-500 text-xs">{error}</div>}
                        <div className="grid grid-cols-2 gap-3 w-full max-w-md mx-auto">
                            {nodes.length > 0 ? nodes.map(node => (
                                <button
                                    key={node.nodeId}
                                    onClick={() => setSelectedNode(node.nodeId)}
                                    className={`p-3 rounded border text-sm truncate ${selectedNode === node.nodeId ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node.nodeId}
                                </button>
                            )) : (
                                <div className="col-span-2 text-slate-500 text-xs">No nodes found. Using demo nodes...</div>
                            )}

                            {/* DEMO FALLBACK if no real nodes */}
                            {nodes.length === 0 && ['CAM-01', 'CAM-02'].map(node => (
                                <button
                                    key={node}
                                    onClick={() => setSelectedNode(node)}
                                    className={`p-3 rounded border text-sm ${selectedNode === node ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node}
                                </button>
                            ))}
                        </div>
                        <Button
                            variant="primary"
                            disabled={!selectedNode}
                            onClick={handleStart}
                        >
                            Start Calibration
                        </Button>
                    </div>
                )}

                {step === 'CAPTURE' && (
                    <div className="text-center space-y-6 w-full max-w-md">
                        <RefreshCw className="w-12 h-12 text-indigo-400 animate-spin mx-auto" />
                        <div>
                            <h4 className="text-lg font-medium text-white mb-1">Calibrating {selectedNode}...</h4>
                            <p className="text-sm text-slate-400">Capturing extrinsic parameters and aligning with point cloud.</p>
                        </div>
                        <div className="w-full bg-navy-950 rounded-full h-2.5 overflow-hidden">
                            <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-100" style={{ width: `${progress}%` }}></div>
                        </div>
                        <p className="text-xs text-slate-500 font-mono">{progress}% Complete</p>
                    </div>
                )}

                {step === 'VERIFY' && (
                    <div className="text-center space-y-4">
                        <AlertTriangle className="w-12 h-12 text-amber-400 mx-auto" />
                        <h4 className="text-lg font-medium text-white">Verification Required</h4>
                        <p className="text-sm text-slate-400 max-w-xs mx-auto">
                            The calculated transform has a reprojection error of <span className="text-white font-mono">0.024m</span>. This is within acceptable limits.
                        </p>
                        <div className="flex gap-3 justify-center">
                            <Button variant="secondary" onClick={reset}>Discard</Button>
                            <Button variant="primary" onClick={() => setStep('COMPLETE')}>Apply Transform</Button>
                        </div>
                    </div>
                )}

                {step === 'COMPLETE' && (
                    <div className="text-center space-y-4">
                        <div className="bg-emerald-500/10 p-4 rounded-full inline-block">
                            <CheckCircle className="w-12 h-12 text-emerald-500" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Calibration Successful</h4>
                        <p className="text-sm text-slate-400">Node {selectedNode} is now active and aligned.</p>
                        <Button variant="ghost" onClick={reset}>Calibrate Another Node</Button>
                    </div>
                )}
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\NodeTopology.tsx
```typescript
import { Plus } from 'lucide-react';
import { TopologyCanvas } from './TopologyCanvas';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const NODES = [
    { id: 'NODE_001', name: 'Gate B Cam 1', status: 'online', type: 'Camera' },
    { id: 'NODE_002', name: 'Gate B LIDAR', status: 'offline', type: 'LIDAR' },
    { id: 'NODE_003', name: 'Field Cam Main', status: 'online', type: 'Camera' },
];

export function NodeTopology() {
    return (
        <div className="flex flex-col lg:flex-row gap-6 h-[700px]">
            {/* Left Panel: Node List */}
            <div className="w-full lg:w-[300px] flex flex-col gap-4">
                <Card className="flex-1 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-white">Nodes</h3>
                        <Button size="icon" variant="ghost"><Plus className="w-4 h-4" /></Button>
                    </div>

                    <div className="space-y-3 flex-1 overflow-y-auto">
                        {NODES.map(node => (
                            <div key={node.id} className="p-3 bg-navy-900 rounded-lg border border-navy-700 hover:border-indigo-500 cursor-pointer transition-colors">
                                <div className="flex justify-between items-start mb-1">
                                    <div className="font-mono text-xs text-slate-500">{node.id}</div>
                                    <Badge variant={node.status === 'online' ? 'success' : 'critical'} size="sm" className="h-2 w-2 p-0 rounded-full"> </Badge>
                                </div>
                                <div className="font-bold text-sm text-slate-200">{node.name}</div>
                                <div className="text-xs text-indigo-400 mt-1">{node.type}</div>
                            </div>
                        ))}
                    </div>

                    <Button variant="secondary" fullWidth className="mt-4">Add New Node</Button>
                </Card>
            </div>

            {/* Right Panel: 3D View */}
            <div className="flex-1 bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden relative">
                <TopologyCanvas />
                <div className="absolute top-4 right-4 bg-navy-800/80 p-2 rounded text-xs text-slate-400">
                    <p>Left Click: Rotate</p>
                    <p>Right Click: Pan</p>
                    <p>Scroll: Zoom</p>
                </div>

                {/* Overlay Controls */}
                <div className="absolute top-4 right-4 bg-navy-800/80 backdrop-blur p-3 rounded-lg border border-navy-700 space-y-2">
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show Frustums
                    </label>
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show LIDAR
                    </label>
                </div>
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\SensorHealth.tsx
```typescript
import { Badge } from '../../../components/ui/Badge';

export function SensorHealth() {
    return (
        <div className="bg-navy-800 rounded-xl border border-navy-700 overflow-hidden">
            <table className="w-full text-left text-sm">
                <thead className="bg-navy-900 text-slate-400 font-medium">
                    <tr>
                        <th className="p-4">Node ID</th>
                        <th className="p-4">Sensor</th>
                        <th className="p-4">Status</th>
                        <th className="p-4">FPS (Target)</th>
                        <th className="p-4">Latency</th>
                        <th className="p-4">Last Update</th>
                        <th className="p-4 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-navy-700">
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_001</td>
                        <td className="p-4">Camera</td>
                        <td className="p-4"><Badge variant="success">ONLINE</Badge></td>
                        <td className="p-4">30/30</td>
                        <td className="p-4 text-green-400">12ms</td>
                        <td className="p-4 text-slate-400">Just now</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_002</td>
                        <td className="p-4">LIDAR</td>
                        <td className="p-4"><Badge variant="critical">OFFLINE</Badge></td>
                        <td className="p-4 text-red-400">0/10</td>
                        <td className="p-4 text-slate-500">--</td>
                        <td className="p-4 text-red-400">5m ago</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\TopologyCanvas.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Grid, Center, Text } from '@react-three/drei';

const Node = ({ position, color, label }: { position: [number, number, number], color: string, label: string }) => {
    return (
        <group position={position}>
            {/* Node visual */}
            <mesh>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* Frustum Visual (Cone) */}
            <mesh position={[0, 0, 2]} rotation={[Math.PI / 2, 0, 0]}>
                <coneGeometry args={[1, 4, 32, 1, true]} />
                <meshStandardMaterial color={color} wireframe opacity={0.3} transparent />
            </mesh>

            {/* Label */}
            <Text position={[0, 1.2, 0]} fontSize={0.5} color="white" anchorX="center" anchorY="middle">
                {label}
            </Text>
        </group>
    );
};

export function TopologyCanvas() {
    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden">
            <Canvas>
                <PerspectiveCamera makeDefault position={[10, 10, 10]} fov={50} />
                <OrbitControls makeDefault />

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} />

                <Grid infiniteGrid fadeDistance={50} sectionColor="#4f46e5" cellColor="#4f46e5" sectionSize={5} cellSize={1} />

                <Center>
                    <Node position={[0, 2, 0]} color="#10b981" label="Cam-01" />
                    <Node position={[-5, 2, 5]} color="#3b82f6" label="Lidar-01" />
                    <Node position={[5, 2, 5]} color="#3b82f6" label="Lidar-02" />
                </Center>
            </Canvas>
        </div>
    );
}

```

#### frontend\src\views\Triage\AnomalyTriage.tsx
```typescript
import { useEffect, useState } from 'react';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { wsService } from '../../services/websocket';

interface TriageTask {
    id: string;
    title: string;
    time: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

export const AnomalyTriage = () => {
    const [newIncidents, setNewIncidents] = useState<TriageTask[]>([]);

    // Mock existing state for other columns
    const [investigating] = useState<TriageTask[]>([
        { id: 'A-099', title: 'Crowd Density Warning', time: '09:30 AM', severity: 'MEDIUM' },
    ]);
    const [resolved] = useState<TriageTask[]>([
        { id: 'A-055', title: 'Sensor Dropout', time: 'Yesterday', severity: 'LOW' },
    ]);

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            const newTask: TriageTask = {
                id: data.anomalyId || 'unknown',
                title: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };
            setNewIncidents(prev => [newTask, ...prev]);
        });
        return () => { };
    }, []);

    return (
        <div className="p-6 h-full text-white overflow-hidden flex flex-col">
            <h1 className="text-2xl font-bold mb-6">Anomaly Triage (Live)</h1>

            <div className="flex-1 flex gap-6 min-h-0 overflow-x-auto">
                <Column title="New Incidents" color="border-red-500" items={newIncidents} />
                <Column title="Investigating" color="border-yellow-500" items={investigating} />
                <Column title="Resolved" color="border-green-500" items={resolved} />
            </div>
        </div>
    );
};

const Column = ({ title, color, items }: any) => (
    <div className="flex-1 flex flex-col gap-4 min-w-[300px]">
        <div className={`font-semibold pb-2 border-b-2 ${color} flex justify-between`}>
            {title}
            <span className="text-slate-500 text-sm">{items.length}</span>
        </div>
        <div className="flex-1 bg-slate-900/50 rounded-lg p-2 space-y-3 overflow-y-auto">
            {items.map((item: any) => (
                <Card key={item.id} className="p-3 cursor-move hover:bg-slate-800 transition-colors">
                    <div className="flex justify-between items-start mb-2">
                        <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                        <Badge variant={item.severity.toLowerCase()}>{item.severity}</Badge>
                    </div>
                    <div className="font-medium text-sm mb-2">{item.title}</div>
                    <div className="text-xs text-slate-400">{item.time}</div>
                </Card>
            ))}
        </div>
    </div>
);

```

## 1. Root

#### deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting deployment for Motion Intelligence Grid..."

# 1. Build and Push Containers
Write-Host "Building and Pushing Containers..."
gcloud builds submit --config cloudbuild.yaml . --project $ProjectId

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# 2. Apply Terraform
Write-Host "Applying Terraform..."
cd infrastructure
terraform init
terraform apply `
    -var="project_id=$ProjectId" `
    -var="region=$Region" `
    -var="mongodb_uri=$env:MONGODB_URI" `
    -var="jwt_secret=$env:JWT_SECRET" `
    -var="admin_password=$env:ADMIN_PASSWORD" `
    -auto-approve

if ($LASTEXITCODE -ne 0) {
    Write-Error "Terraform failed!"
    exit 1
}

Write-Host "Deployment Complete!"

```

#### manual_deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting Robust Deployment for Motion Intelligence Grid..." -ForegroundColor Cyan

# Function to Build and Push
function Build-And-Push {
    param(
        [string]$ServiceName,
        [string]$Path
    )
    $ImageName = "gcr.io/$ProjectId/motiongrid-$ServiceName`:latest"
    Write-Host "Processing $ServiceName..." -ForegroundColor Yellow
    
    # Build
    Write-Host "  Building $ImageName..."
    docker build -t $ImageName $Path
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Build Failed"; exit 1 }
    
    # Push
    Write-Host "  Pushing $ImageName..."
    docker push $ImageName
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Push Failed"; exit 1 }
    
    Write-Host "  $ServiceName Done." -ForegroundColor Green
}

# 1. Server
Build-And-Push "api" "./server"

# 2. Simulation
Build-And-Push "simulation" "./simulation"

# 3. Frontend
Build-And-Push "frontend" "./frontend"

# 4. Terraform
Write-Host "Applying Infrastructure Updates..." -ForegroundColor Yellow
Set-Location "./infrastructure"
terraform init
terraform apply -var="project_id=$ProjectId" -var="region=$Region" -auto-approve -lock=false

if ($LASTEXITCODE -ne 0) { 
    Write-Error "Terraform Failed"
    exit 1 
}

Write-Host "Deployment Complete! 🚀" -ForegroundColor Green
Set-Location ..

```

#### cloudbuild.yaml
```yaml
steps:
  # Build API
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-api:latest', './server']
    
  # Build Simulation
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest', './simulation']
    
  # Build Frontend
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest', './frontend']

  # Push Images
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-api:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest']


options:
  machineType: 'N1_HIGHCPU_8'

```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # MongoDB database
  mongodb:
    image: mongo:6
    container_name: motiongrid-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: devpassword123
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - motiongrid-network
    command: --wiredTigerCacheSizeGB 1.5

  # Redis (optional, for caching)
  redis:
    image: redis:7-alpine
    container_name: motiongrid-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - motiongrid-network
    command: redis-server --appendonly yes

  # API Gateway (Node.js + Express + Socket.io)
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-api
    restart: unless-stopped
    environment:
      NODE_ENV: development
      PORT: 3001
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
      REDIS_URL: redis://redis:6379
      JWT_SECRET: dev-secret-key
      SIMULATION_API_URL: http://simulation:8000
    ports:
      - "3001:3001"
    volumes:
      - ./server/src:/app/src
    depends_on:
      - mongodb
      - redis
    networks:
      - motiongrid-network
    command: npm run dev

  # Simulation Engine (Python + FastAPI)
  simulation:
    build:
      context: ./simulation
      dockerfile: Dockerfile
    container_name: motiongrid-simulation
    restart: unless-stopped
    environment:
      PYTHONUNBUFFERED: 1
      API_PORT: 8000
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
    ports:
      - "8000:8000"
    volumes:
      - ./simulation/src:/app/src
    depends_on:
      - mongodb
    networks:
      - motiongrid-network
    command: uvicorn src.api.server:app --host 0.0.0.0 --port 8000 --reload

  # Frontend (React SPA)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_WS_URL: ws://localhost:3001
    ports:
      - "5173:5173"
    volumes:
      - ./frontend/src:/app/src
    networks:
      - motiongrid-network
    command: npm run dev

volumes:
  mongodb_data:
  redis_data:


networks:
  motiongrid-network:
    driver: bridge

```

#### .gcloudignore
```
node_modules/
.git/
.github/
infrastructure/.terraform/
.DS_Store
*.log
coverage/
dist/
tmp/
gcloud_temp/

```

## 2. Infrastructure

#### infrastructure\main.tf
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

resource "google_cloud_run_service" "api" {
  name     = "motiongrid-api"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-api:latest"
        ports {
            container_port = 8080
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
          name  = "JWT_SECRET"
          value = var.jwt_secret
        }
        env {
          name  = "ADMIN_EMAIL"
          value = var.admin_email
        }
          env {
            name  = "ADMIN_PASSWORD"
            value = var.admin_password
          }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

resource "google_cloud_run_service" "simulation" {
  name     = "motiongrid-simulation"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-simulation:latest"
        ports {
            container_port = 8000
        }
        resources {
          limits = {
            cpu    = "2000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
          name  = "API_URL"
          value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service" "frontend" {
  name     = "motiongrid-frontend"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-frontend:latest"
        ports {
            container_port = 80
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        env {
            name = "VITE_API_URL"
            value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service_iam_member" "public_access_frontend" {
  service  = google_cloud_run_service.frontend.name
  location = google_cloud_run_service.frontend.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

# Storage Bucket for Session Recordings
resource "google_storage_bucket" "sessions" {
  name     = "${var.project_id}-sessions"
  location = var.region
  
  uniform_bucket_level_access = true
  
  lifecycle_rule {
    action { type = "Delete" }
    condition { age = 180 }  # Keep recordings 6 months
  }
}

resource "google_cloud_run_service_iam_member" "public_access_api" {
  service  = google_cloud_run_service.api.name
  location = google_cloud_run_service.api.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_simulation" {
  service  = google_cloud_run_service.simulation.name
  location = google_cloud_run_service.simulation.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "frontend_url" {
  value = google_cloud_run_service.frontend.status[0].url
}

```

#### infrastructure\variables.tf
```hcl
variable "project_id" {
  description = "GCP Project ID"
  type        = string
  default     = "freeforge-481415"
}

variable "region" {
  description = "GCP Region"
  type        = string
  default     = "us-central1"
}

variable "mongodb_uri" {
    description = "MongoDB Connection String"
    type = string
    sensitive = true
}

variable "jwt_secret" {
    description = "JWT Secret for authentication"
    type = string
    sensitive = true
}

variable "admin_email" {
    description = "Default admin email"
    type = string
    default = "admin@freeforge.com"
}

variable "admin_password" {
    description = "Default admin password"
    type = string
    sensitive = true
}


```

## 3. Server

#### server\Dockerfile
```
# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine AS production
WORKDIR /app
ENV NODE_ENV=production
COPY package*.json ./
RUN npm install --only=production
COPY --from=builder /app/dist ./dist
EXPOSE 8080
CMD ["node", "dist/index.js"]

```

#### server\package.json
```json
{
  "name": "motiongrid-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.2",
    "mongoose": "^8.0.3",
    "redis": "^4.6.11",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "axios": "^1.6.2",
    "typescript": "^5.3.3",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/express": "^4.17.21",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11"
  }
}
```

#### server\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2016",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": false,
        "noImplicitAny": false,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "noEmitOnError": false,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts"
    ]
}
```

#### server\src\database.ts
```typescript
import mongoose from 'mongoose';

export const connectDB = async () => {
    const uri = process.env.MONGODB_URI;

    if (!uri) {
        console.error('❌ MONGODB_URI environment variable is required');
        // In production, we might want to throw error, but for now we log error
        // throwing error would crash loop which is handled by index.ts
        throw new Error('MONGODB_URI environment variable is required');
    }

    if (uri === 'memory') {
        console.warn('⚠️ Running in IN-MEMORY mode (dev only). Persistence disabled.');
        return;
    }

    try {
        console.log(`[DATABASE] Connecting to MongoDB (URI ending in: ...${uri.slice(-4)})`);
        await mongoose.connect(uri, {
            serverSelectionTimeoutMS: 10000, // 10 seconds
        });
        console.log('✅ MongoDB connected successfully');
    } catch (error: any) {
        console.error('❌ MongoDB connection failed:', error.message);
        throw error;
    }
};

```

#### server\src\index.ts
```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { connectDB } from './database';
import { socketService } from './services/SocketService';
import { authenticate as authMiddleware } from './middleware/auth';

// Import routes at the top as per best practices
import authRouter from './routes/auth';
import nodesRouter from './routes/nodes';
import sessionsRouter from './routes/sessions';
import anomaliesRouter from './routes/anomalies';
import entitiesRouter from './routes/entities';
import simulationRouter from './routes/simulation';
import analyticsRouter from './routes/analytics';

// Load environment variables
dotenv.config();

console.log('🚀 [STARTUP] Motion Intelligence Grid API initiating...');
console.log(`[STARTUP] Environment: ${process.env.NODE_ENV || 'development'}`);

const app = express();
const httpServer = createServer(app);

// BIND PORT IMMEDIATELY FOR CLOUD RUN HEALTH CHECKS
const PORT = process.env.PORT || 8080;
httpServer.listen(PORT, () => {
    console.log(`✅ [STARTUP] API listening on port ${PORT}`);
});

const io = new Server(httpServer, {
    cors: {
        origin: process.env.CLIENT_URL || '*',
        methods: ['GET', 'POST'],
    },
});

// Initialize SocketService
socketService.init(io);

// Middleware
app.use(cors());
app.use(helmet());
app.use(express.json());

// Basic health check (Always available)
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date(),
        db: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        uptime: process.uptime()
    });
});

// Routes
app.use('/api/auth', authRouter);
app.use('/api/nodes', authMiddleware, nodesRouter);
app.use('/api/sessions', authMiddleware, sessionsRouter);
app.use('/api/anomalies', authMiddleware, anomaliesRouter);
app.use('/api/entities', authMiddleware, entitiesRouter);
app.use('/api/simulation', authMiddleware, simulationRouter);
app.use('/api/analytics', authMiddleware, analyticsRouter);

// Internal Endpoints for Simulation Bridge
app.post('/internal/entity-update', async (req, res) => {
    const { sessionId, entities, stats, sentAt } = req.body;
    const latencyMs = sentAt ? Math.round((Date.now() / 1000 - sentAt) * 1000) : 0;
    socketService.emit('entity:tracking', { entities, stats, latencyMs }, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

app.post('/internal/anomaly', async (req, res) => {
    const { sessionId, anomaly } = req.body;
    socketService.emit('anomaly:detected', anomaly, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

const startServer = async () => {
    try {
        console.log('[STARTUP] Connecting to database...');
        await connectDB();
        console.log('✅ [STARTUP] Database connected successfully.');

        if (mongoose.connection.readyState === 1) {
            const { User } = await import('./models/User');
            const adminEmail = process.env.ADMIN_EMAIL || 'admin@freeforge.com';
            const adminPassword = process.env.ADMIN_PASSWORD || 'nimda';

            console.log(`[STARTUP] Checking for admin: ${adminEmail}`);
            const adminUser = await User.findOne({ email: adminEmail });

            if (!adminUser) {
                console.log(`[STARTUP] Seeding default admin user: ${adminEmail} with password: ${adminPassword}...`);
                const newAdmin = new User({
                    email: adminEmail,
                    passwordHash: adminPassword,
                    username: 'admin',
                    role: 'ADMIN'
                });
                await newAdmin.save();
                console.log('✅ [STARTUP] Default admin created.');
            } else {
                console.log(`[STARTUP] Admin user ${adminEmail} exists. Updating password to environment current value...`);
                adminUser.passwordHash = adminPassword;
                await adminUser.save();
                console.log('✅ [STARTUP] Admin password updated successfully.');
            }
        }
    } catch (error) {
        console.error('❌ [STARTUP] initialization failed:', error);
    }
};

startServer();

```

#### server\src\middleware\auth.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface UserPayload {
    userId: string;
    role: string;
    email: string;
}

declare global {
    namespace Express {
        interface Request {
            user?: UserPayload;
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    // Skip auth for login/public routes if applying globally, 
    // but usually we apply this middleware to specific routes.

    const authHeader = req.headers.authorization;
    let token = '';

    if (authHeader) {
        token = authHeader.split(' ')[1]; // Bearer <token>
    } else if (req.query.token) {
        token = req.query.token as string;
    }

    if (!token) {
        return res.status(401).json({ error: 'Token missing or Authorization header missing' });
    }

    try {
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const decoded = jwt.verify(token, secret) as UserPayload;
        req.user = decoded;
        next();
    } catch (err) {
        return res.status(401).json({ error: 'Invalid or expired token' });
    }
};

export const requireRole = (roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        if (!req.user || !roles.includes(req.user.role)) {
            return res.status(403).json({ error: 'Insufficient permissions' });
        }
        next();
    };
};

```

#### server\src\middleware\validate.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

export const validateBody = (schema: Joi.Schema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({ error: error.details[0].message });
        }
        next();
    };
};

```

#### server\src\models\Anomaly.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IAnomaly extends Document {
    anomalyId: string;
    sessionId: mongoose.Types.ObjectId;
    entityIds: mongoose.Types.ObjectId[];
    nodeIds: string[];
    occurredAt: Date;
    duration: number;
    type: 'GEOGRAPHICS' | 'KINETICS' | 'PROXEMICS' | 'ATMOSPHERICS';
    subtype: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    scenario?: string;
    headline: string;
    description: string;
    baselineText: string;
    anomalyText: string;
    metrics: {
        baselineDelta: number;
        confidence: number;
        riskScore: number;
    };
    ruleOfThreeHit: boolean;
    relatedAnomalies: mongoose.Types.ObjectId[];
    zone: string;
    location: { x: number; y: number; z: number };
    triage: {
        status: 'UNREVIEWED' | 'CONFIRMED' | 'DOWNGRADED' | 'FALSE_POSITIVE';
        notes?: string;
    };
    tags: string[];
    createdAt: Date;
    updatedAt: Date;
}

const AnomalySchema: Schema = new Schema({
    anomalyId: { type: String, required: true, unique: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    entityIds: [{ type: Schema.Types.ObjectId, ref: 'Entity' }],
    nodeIds: [String],
    occurredAt: { type: Date, default: Date.now },
    duration: { type: Number, default: 0 },
    type: { type: String, enum: ['GEOGRAPHICS', 'KINETICS', 'PROXEMICS', 'ATMOSPHERICS'], required: true },
    subtype: String,
    severity: { type: String, enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'], default: 'LOW' },
    scenario: String,
    headline: String,
    description: String,
    baselineText: String,
    anomalyText: String,
    metrics: {
        baselineDelta: Number,
        confidence: Number,
        riskScore: Number
    },
    ruleOfThreeHit: { type: Boolean, default: false },
    relatedAnomalies: [{ type: Schema.Types.ObjectId, ref: 'Anomaly' }],
    zone: String,
    location: {
        x: Number,
        y: Number,
        z: Number
    },
    triage: {
        status: { type: String, enum: ['UNREVIEWED', 'CONFIRMED', 'DOWNGRADED', 'FALSE_POSITIVE'], default: 'UNREVIEWED' },
        notes: String
    },
    tags: [String]
}, { timestamps: true });

export const Anomaly = mongoose.model<IAnomaly>('Anomaly', AnomalySchema);

```

#### server\src\models\Entity.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IEntity extends Document {
    entityId: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    name?: string;
    lastPosition: { x: number; y: number; z: number };
    lastVelocity: { x: number; y: number; z: number };
    lastSeenAt: Date;
    sessionId?: string;
}

const EntitySchema: Schema = new Schema({
    entityId: { type: String, required: true, unique: true },
    type: { type: String, enum: ['PERSON', 'OBJECT'], required: true },
    role: { type: String, enum: ['PLAYER', 'OFFICIAL', 'SPECTATOR', 'BALL'], default: 'SPECTATOR' },
    team: { type: String, enum: ['HOME', 'AWAY'] },
    name: String,
    lastPosition: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastVelocity: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastSeenAt: { type: Date, default: Date.now },
    sessionId: String
}, { timestamps: true });

export const Entity = mongoose.model<IEntity>('Entity', EntitySchema);

```

#### server\src\models\Node.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INode extends Document {
    nodeId: string;
    name: string;
    type: 'EDGE_NODE';
    status: 'ONLINE' | 'OFFLINE' | 'DEGRADED';
    position: { x: number; y: number; z: number };
    orientation: { pitch: number; yaw: number; roll: number };
    sensors: {
        camera: {
            enabled: boolean;
            resolution: { width: number; height: number };
            fps: number;
            fov: number;
            exposure: number;
            gain: number;
        };
        lidar: {
            enabled: boolean;
            model: string;
            channels: number;
            pointsPerSecond: number;
            range: number;
            accuracy: number;
        };
        imu: {
            enabled: boolean;
            sampleRate: number;
            accelRange: number;
            gyroRange: number;
        };
    };
    calibration: {
        intrinsic: {
            cameraMatrix: number[][];
            distortion: number[];
        };
        extrinsic: {
            rotationMatrix: number[][];
            translationVector: number[];
        };
        lidarToCameraTransform: number[][];
        calibrationQuality: number;
        calibratedAt: Date;
    };
    network: {
        ipAddress: string;
        port: number;
        ptpDomain: number;
        clockOffset: number;
        lastSyncAt: Date;
    };
    sessionId?: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const NodeSchema: Schema = new Schema({
    nodeId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    type: { type: String, default: 'EDGE_NODE' },
    status: { type: String, enum: ['ONLINE', 'OFFLINE', 'DEGRADED'], default: 'OFFLINE' },
    position: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    orientation: {
        pitch: { type: Number, default: 0 },
        yaw: { type: Number, default: 0 },
        roll: { type: Number, default: 0 }
    },
    sensors: {
        camera: {
            enabled: { type: Boolean, default: true },
            resolution: {
                width: { type: Number, default: 1920 },
                height: { type: Number, default: 1080 }
            },
            fps: { type: Number, default: 30 },
            fov: { type: Number, default: 90 },
            exposure: { type: Number, default: 50 },
            gain: { type: Number, default: 0 }
        },
        lidar: {
            enabled: { type: Boolean, default: true },
            model: { type: String, default: 'VLP-16' },
            channels: { type: Number, default: 16 },
            pointsPerSecond: { type: Number, default: 300000 },
            range: { type: Number, default: 100 },
            accuracy: { type: Number, default: 0.03 }
        },
        imu: {
            enabled: { type: Boolean, default: true },
            sampleRate: { type: Number, default: 100 },
            accelRange: { type: Number, default: 16 },
            gyroRange: { type: Number, default: 2000 }
        }
    },
    calibration: {
        intrinsic: {
            cameraMatrix: [[Number]],
            distortion: [Number]
        },
        extrinsic: {
            rotationMatrix: [[Number]],
            translationVector: [Number]
        },
        lidarToCameraTransform: [[Number]],
        calibrationQuality: { type: Number, default: 0 },
        calibratedAt: Date
    },
    network: {
        ipAddress: String,
        port: Number,
        ptpDomain: { type: Number, default: 0 },
        clockOffset: { type: Number, default: 0 },
        lastSyncAt: Date
    },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session' }
}, { timestamps: true });

export const Node = mongoose.model<INode>('Node', NodeSchema);

```

#### server\src\models\SensorFrame.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISensorFrame extends Document {
    frameId: string;
    sessionId: mongoose.Types.ObjectId;
    nodeId: string;
    timestamp: Date;
    frameNumber: number;
    camera?: {
        imagePath: string;
        resolution: { width: number; height: number };
    };
    lidar?: {
        pointCloudPath: string;
        pointCount: number;
    };
    fusion?: {
        detectedEntities: any[];
        processingTime: number;
    };
    createdAt: Date;
}

const SensorFrameSchema: Schema = new Schema({
    frameId: { type: String, required: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    nodeId: { type: String, required: true },
    timestamp: { type: Date, required: true },
    frameNumber: Number,
    camera: {
        imagePath: String,
        resolution: { width: Number, height: Number }
    },
    lidar: {
        pointCloudPath: String,
        pointCount: Number
    },
    fusion: {
        detectedEntities: [],
        processingTime: Number
    }
}, {
    timeseries: {
        timeField: 'timestamp',
        metaField: 'nodeId',
        granularity: 'seconds'
    },
    expireAfterSeconds: 86400 * 7 // 7 days retention
});

export const SensorFrame = mongoose.model<ISensorFrame>('SensorFrame', SensorFrameSchema);

```

#### server\src\models\Session.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISession extends Document {
    sessionId: string;
    name: string;
    sport: 'BASKETBALL' | 'SOCCER' | 'COMBAT' | 'CUSTOM';
    venue: string;
    startedAt: Date;
    endedAt?: Date;
    duration: number;
    status: 'RECORDING' | 'STOPPED' | 'PROCESSING' | 'READY';
    nodeIds: string[];
    stats: {
        totalFrames: number;
        totalEntities: number;
        totalAnomalies: number;
        anomalyBreakdown: {
            critical: number;
            high: number;
            medium: number;
            low: number;
        };
        avgOccupancy: number;
        peakOccupancy: number;
        avgActivityIndex: number;
    };
    scenario: {
        entityCount: number;
        crowdDensity: number;
        anomalyRate: number;
        environmentConfig: {
            lighting: 'BRIGHT' | 'DIM' | 'VARIABLE';
            weather?: 'CLEAR' | 'RAIN' | 'SNOW';
        };
    };
    dataPath: string;
    thumbnailPath?: string;
    createdAt: Date;
    updatedAt: Date;
}

const SessionSchema: Schema = new Schema({
    sessionId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    sport: { type: String, enum: ['BASKETBALL', 'SOCCER', 'COMBAT', 'CUSTOM'], required: true },
    venue: String,
    startedAt: { type: Date, default: Date.now },
    endedAt: Date,
    duration: { type: Number, default: 0 },
    status: { type: String, enum: ['RECORDING', 'STOPPED', 'PROCESSING', 'READY'], default: 'RECORDING' },
    nodeIds: [String],
    stats: {
        totalFrames: { type: Number, default: 0 },
        totalEntities: { type: Number, default: 0 },
        totalAnomalies: { type: Number, default: 0 },
        anomalyBreakdown: {
            critical: { type: Number, default: 0 },
            high: { type: Number, default: 0 },
            medium: { type: Number, default: 0 },
            low: { type: Number, default: 0 }
        },
        avgOccupancy: { type: Number, default: 0 },
        peakOccupancy: { type: Number, default: 0 },
        avgActivityIndex: { type: Number, default: 0 }
    },
    scenario: {
        entityCount: { type: Number, default: 0 },
        crowdDensity: { type: Number, default: 0 },
        anomalyRate: { type: Number, default: 0 },
        environmentConfig: {
            lighting: { type: String, default: 'BRIGHT' },
            weather: String
        }
    },
    dataPath: String,
    thumbnailPath: String
}, { timestamps: true });

export const Session = mongoose.model<ISession>('Session', SessionSchema);

```

#### server\src\models\User.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
    username: string;
    email: string;
    passwordHash: string;
    role: 'OPERATOR' | 'ANALYST' | 'ADMIN';
    permissions: string[];
    preferences: {
        theme: 'DARK' | 'LIGHT';
    };
    createdAt: Date;
    updatedAt: Date;
    validatePassword(password: string): Promise<boolean>;
}

const UserSchema: Schema = new Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['OPERATOR', 'ANALYST', 'ADMIN'], default: 'OPERATOR' },
    permissions: [String],
    preferences: {
        theme: { type: String, default: 'DARK' }
    }
}, { timestamps: true });

UserSchema.pre<IUser>('save', async function (next) {
    if (!this.isModified('passwordHash')) return next();
    try {
        const salt = await bcrypt.genSalt(10);
        this.passwordHash = await bcrypt.hash(this.passwordHash, salt);
        next();
    } catch (err: any) {
        next(err);
    }
});

UserSchema.methods.validatePassword = async function (password: string): Promise<boolean> {
    return await bcrypt.compare(password, this.passwordHash);
};

export const User = mongoose.model<IUser>('User', UserSchema);

```

#### server\src\routes\analytics.ts
```typescript
import express from 'express';

const router = express.Router();

router.get('/stats', (req, res) => {
    // Return aggregated stats
    res.json({
        totalAnomalies: 42,
        activeEntities: 15,
        systemHealth: 98.6,
        uptimeSeconds: 3600
    });
});

router.get('/performance', (req, res) => {
    // Return system performance metrics (FPS, Latency)
    res.json({
        simulationFps: 29.8,
        networkLatencyMs: 12,
        processingTimeMs: 4
    });
});

export default router;

```

#### server\src\routes\anomalies.ts
```typescript
import express from 'express';
import { Anomaly } from '../models/Anomaly';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, severity, status } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (severity) query.severity = severity;
        if (status) query['triage.status'] = status;

        const anomalies = await Anomaly.find(query).sort({ occurredAt: -1 }).limit(100);
        res.json({ anomalies, count: anomalies.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id/triage', async (req, res) => {
    try {
        const { status, notes } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            {
                'triage.status': status,
                'triage.notes': notes,
                'triage.triageAt': new Date()
            },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/tag', async (req, res) => {
    try {
        const { tags } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            { $addToSet: { tags: { $each: tags } } },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\auth.ts
```typescript
import express from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/User';

const router = express.Router();

router.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        // Find user
        const user = await User.findOne({ email });
        if (!user) {
            console.log(`Login attempt failed: User not found (${email})`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Validate password
        const isValid = await user.validatePassword(password);
        if (!isValid) {
            console.log(`Login attempt failed: Invalid password for ${email}`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        console.log(`Login successful for ${email}`);

        // Generate Token
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const token = jwt.sign(
            {
                userId: user._id,
                role: user.role,
                email: user.email
            },
            secret,
            { expiresIn: '24h' }
        );

        res.json({
            token,
            user: {
                id: user._id,
                email: user.email,
                role: user.role,
                username: user.username
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.post('/register', async (req, res) => {
    // For MVP/Demo: Allow registration of first user as ADMIN, others as VIEWERS
    // Or just open registration for "OPERATOR"
    try {
        const { email, password, username } = req.body;

        const existing = await User.findOne({ $or: [{ email }, { username }] });
        if (existing) {
            return res.status(400).json({ error: 'User already exists' });
        }

        const count = await User.countDocuments();
        const role = count === 0 ? 'ADMIN' : 'OPERATOR';

        const user = new User({
            email,
            passwordHash: password, // Will be hashed by pre-save hook
            username,
            role
        });

        await user.save();

        res.status(201).json({ message: 'User created', userId: user._id });
    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({ error: 'Registration failed' });
    }
});

export default router;

```

#### server\src\routes\entities.ts
```typescript
import express from 'express';
import { Entity } from '../models/Entity';
import { SensorFrame } from '../models/SensorFrame';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, type, RKole } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (type) query.type = type;
        if (RKole) query.role = RKole;

        const entities = await Entity.find(query);
        res.json(entities);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const entity = await Entity.findOne({ entityId: req.params.id });
        if (!entity) return res.status(404).json({ error: 'Entity not found' });
        res.json(entity);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/track', async (req, res) => {
    try {
        const { id } = req.params;
        const { startTime, endTime } = req.query;

        // Find frames where this entity appears in fusion data
        // Note: This query depends on how SensorFrame stores fusion data
        const query: any = {
            'fusion.detectedEntities.id': id
        };

        if (startTime || endTime) {
            query.timestamp = {};
            if (startTime) query.timestamp.$gte = new Date(String(startTime));
            if (endTime) query.timestamp.$lte = new Date(String(endTime));
        }

        const frames = await SensorFrame.find(query)
            .select('timestamp fusion.detectedEntities')
            .sort({ timestamp: 1 })
            .limit(1000);

        // Extract just the relevant position data
        const path = frames.map(f => {
            const ent = f.toJSON().fusion?.detectedEntities?.find((e: any) => e.id === id);
            return {
                timestamp: f.timestamp,
                position: ent?.position
            };
        }).filter(p => p.position);

        res.json({
            entityId: id,
            path
        });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\nodes.ts
```typescript
import express from 'express';
import axios from 'axios';
import { NodeService } from '../services/NodeService';

const router = express.Router();
const nodeService = new NodeService();

router.post('/', async (req, res) => {
    try {
        const node = await nodeService.createNode(req.body);
        res.status(201).json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const nodes = await nodeService.getNodes(req.query);
        res.json({ nodes, count: nodes.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const node = await nodeService.getNode(req.params.id);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/stream', async (req, res) => {
    try {
        const nodeId = req.params.id;
        // Ideally use env var for simulation URL
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios({
            method: 'get',
            url: `${simulationUrl}/nodes/${nodeId}/stream`,
            responseType: 'stream'
        });

        // Forward content type (multipart/x-mixed-replace)
        res.setHeader('Content-Type', response.headers['content-type']);
        response.data.pipe(res);
    } catch (err: any) {
        // console.error('Stream proxy error:', err.message);
        res.status(503).send('Stream unavailable');
    }
});

router.post('/:id/calibrate', async (req, res) => {
    try {
        const nodeId = req.params.id;
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios.post(`${simulationUrl}/nodes/${nodeId}/calibrate`);
        const result = response.data;

        // Update node in database
        await nodeService.updateNode(nodeId, {
            calibration: result.calibration
        });

        res.json(result);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const node = await nodeService.updateNode(req.params.id, req.body);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await nodeService.deleteNode(req.params.id);
        if (!success) return res.status(404).json({ error: 'Node not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\sessions.ts
```typescript
import express from 'express';
import { SessionService } from '../services/SessionService';

const router = express.Router();
const sessionService = new SessionService();

router.post('/', async (req, res) => {
    try {
        const session = await sessionService.createSession(req.body);
        res.status(201).json(session);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const sessions = await sessionService.getSessions(req.query);
        res.json({ sessions, count: sessions.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/start', async (req, res) => {
    try {
        const session = await sessionService.startSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/stop', async (req, res) => {
    try {
        const session = await sessionService.stopSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const session = await sessionService.updateSession(req.params.id, req.body);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json(session);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await sessionService.deleteSession(req.params.id);
        if (!success) return res.status(404).json({ error: 'Session not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});


router.get('/:sessionId/frames', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const { startTime, endTime, limit = 100 } = req.query;

        // This relies on SensorFrame model being available. 
        // We might need to import it or use a service method.
        // Ideally checking SessionService first.
        const frames = await sessionService.getSessionFrames(sessionId, {
            startTime: startTime ? new Date(String(startTime)) : undefined,
            endTime: endTime ? new Date(String(endTime)) : undefined,
            limit: Number(limit)
        });

        res.json({ frames, count: frames.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\simulation.ts
```typescript
import express from 'express';
import { SimulationClient } from '../services/simulation_client';

const router = express.Router();

router.post('/start', async (req, res) => {
    const config = req.body;
    const success = await SimulationClient.startSimulation(config);
    if (success) {
        res.json({ message: 'Simulation started' });
    } else {
        res.status(500).json({ error: 'Failed to start simulation' });
    }
});

router.post('/stop', async (req, res) => {
    const success = await SimulationClient.stopSimulation();
    if (success) {
        res.json({ message: 'Simulation stopped' });
    } else {
        res.status(500).json({ error: 'Failed to stop simulation' });
    }
});

router.get('/status', async (req, res) => {
    const isHealthy = await SimulationClient.healthCheck();
    res.json({
        status: isHealthy ? 'running' : 'stopped',
        service: 'python-engine'
    });
});

export default router;

```

#### server\src\services\AnalyticsService.ts
```typescript
import { Session } from '../models/Session';
import { Anomaly } from '../models/Anomaly';

export class AnalyticsService {
    async getSessionStats(sessionId: string) {
        const session = await Session.findOne({ sessionId });
        if (!session) throw new Error('Session not found');

        const anomalyCount = await Anomaly.countDocuments({ sessionId: session._id });
        const criticalAnomalies = await Anomaly.countDocuments({ sessionId: session._id, severity: 'CRITICAL' });

        return {
            ...session.toJSON().stats,
            anomalyCount,
            criticalAnomalies
        };
    }

    async getGlobalStats() {
        const totalSessions = await Session.countDocuments();
        const totalAnomalies = await Anomaly.countDocuments();

        return {
            totalSessions,
            totalAnomalies,
            systemHealth: 'HEALTHY' // Placeholder
        };
    }
}

```

#### server\src\services\NodeService.ts
```typescript
import { Node, INode } from '../models/Node';

export class NodeService {
    async createNode(data: Partial<INode>): Promise<INode> {
        // Validation: Check if nodeId exists
        const existing = await Node.findOne({ nodeId: data.nodeId });
        if (existing) {
            throw new Error('Node ID already exists');
        }

        const node = new Node(data);
        return await node.save();
    }

    async getNodes(filter: any = {}): Promise<INode[]> {
        return await Node.find(filter);
    }

    async getNode(nodeId: string): Promise<INode | null> {
        return await Node.findOne({ nodeId });
    }

    async updateNode(nodeId: string, data: Partial<INode>): Promise<INode | null> {
        return await Node.findOneAndUpdate({ nodeId }, data, { new: true });
    }

    async deleteNode(nodeId: string): Promise<boolean> {
        const result = await Node.deleteOne({ nodeId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\SessionService.ts
```typescript
import { Session, ISession } from '../models/Session';
import mongoose from 'mongoose';
import { SensorFrame } from '../models/SensorFrame';

export class SessionService {
    async createSession(data: Partial<ISession>): Promise<ISession> {
        const session = new Session({
            ...data,
            sessionId: `SES_${Date.now()}`
        });
        return await session.save();
    }

    async getSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOne({ sessionId });
    }

    async getSessions(filter: any = {}): Promise<ISession[]> {
        return await Session.find(filter).sort({ createdAt: -1 });
    }

    async getSessionFrames(sessionId: string, options: { startTime?: Date, endTime?: Date, limit?: number }): Promise<any[]> {
        const session = await Session.findOne({ sessionId });
        if (!session) return [];

        const query: any = { sessionId: session._id };
        if (options.startTime || options.endTime) {
            query.timestamp = {};
            if (options.startTime) query.timestamp.$gte = options.startTime;
            if (options.endTime) query.timestamp.$lte = options.endTime;
        }

        return await SensorFrame.find(query).sort({ timestamp: 1 }).limit(options.limit || 100);
    }

    async startSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'RECORDING',
                startedAt: new Date()
            },
            { new: true }
        );
    }

    async stopSession(sessionId: string): Promise<ISession | null> {
        const session = await Session.findOne({ sessionId });
        if (!session) return null;

        const endedAt = new Date();
        const duration = (endedAt.getTime() - session.startedAt.getTime()) / 1000;

        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'STOPPED',
                endedAt,
                duration
            },
            { new: true }
        );
    }


    async updateSession(sessionId: string, data: Partial<ISession>): Promise<ISession | null> {
        return await Session.findOneAndUpdate({ sessionId }, data, { new: true });
    }

    async deleteSession(sessionId: string): Promise<boolean> {
        const result = await Session.deleteOne({ sessionId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\simulation_client.ts
```typescript
import axios from 'axios';

const SIMULATION_API_URL = process.env.SIMULATION_API_URL || 'http://localhost:8000';

export class SimulationClient {

    static async healthCheck(): Promise<boolean> {
        try {
            const response = await axios.get(`${SIMULATION_API_URL}/health`);
            return response.data.status === 'ok';
        } catch (error) {
            console.error('Simulation API unhealthy:', error.message);
            return false;
        }
    }

    static async startSimulation(config: any): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/start`, config);
            return response.data.status === 'started';
        } catch (error) {
            console.error('Failed to start simulation:', error.message);
            return false;
        }
    }

    static async stopSimulation(): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/stop`);
            return response.data.status === 'stopped';
        } catch (error) {
            console.error('Failed to stop simulation:', error.message);
            return false;
        }
    }
}

```

#### server\src\services\SocketService.ts
```typescript
import { Server, Socket } from 'socket.io';
import jwt from 'jsonwebtoken';

class SocketService {
    private io: Server | null = null;

    init(io: Server) {
        this.io = io;
        this.setupListeners();
    }

    private setupListeners() {
        if (!this.io) return;

        // Authentication Middleware
        this.io.use((socket, next) => {
            const token = socket.handshake.auth.token || socket.handshake.query.token;

            if (!token) {
                return next(new Error('Authentication required'));
            }

            try {
                const secret = process.env.JWT_SECRET;
                if (!secret) {
                    console.error('❌ CRITICAL: JWT_SECRET environment variable is missing! Falling back to dev secret (INSECURE)');
                }
                const decoded = jwt.verify(token as string, secret || 'dev_secret_do_not_use_in_prod');
                (socket as any).user = decoded;
                next();
            } catch (err) {
                next(new Error('Invalid token'));
            }
        });

        this.setupHandlers();
    }

    private setupHandlers() {
        if (!this.io) return;

        this.io.on('connection', (socket: Socket) => {
            const user = (socket as any).user;
            console.log(`Client connected: ${socket.id} (User: ${user?.email || 'Unknown'})`);

            socket.on('disconnect', () => {
                console.log('Client disconnected:', socket.id);
            });

            // Handle subscriptions
            socket.on('subscribe:session', (data) => {
                console.log(`Client ${socket.id} subscribed to session ${data.sessionId}`);
                socket.join(`session:${data.sessionId}`);
            });

            socket.on('subscribe:node', (data) => {
                console.log(`Client ${socket.id} subscribed to node ${data.nodeId}`);
                socket.join(`node:${data.nodeId}`);
            });
        });
    }

    emit(event: string, data: any, room?: string) {
        if (!this.io) {
            console.warn('SocketService not initialized');
            return;
        }

        if (room) {
            this.io.to(room).emit(event, data);
        } else {
            this.io.emit(event, data);
        }
    }
}

export const socketService = new SocketService();

```

#### server\src\__tests__\integration\session-flow.test.ts
```typescript
import request from 'supertest';
// Mocking app import since we might not export it correctly for testing in index.ts
// In a real setup, we'd export `app` from app.ts and import it in index.ts
// For now, pseudo-integration test or need to refactor index.ts
// Refactoring index.ts to export app is best practice.

describe('Session Flow Integration', () => {
    it('placeholder for integration test', async () => {
        expect(true).toBe(true);
    });
});

```

#### server\src\__tests__\services\NodeService.test.ts
```typescript
import { NodeService } from '../../services/NodeService';
import { Node } from '../../models/Node';

// Mock the Mongoose Model
jest.mock('../../models/Node');

describe('NodeService', () => {
    let nodeService: NodeService;

    beforeEach(() => {
        nodeService = new NodeService();
        jest.clearAllMocks();
    });

    it('should create a node successfully', async () => {
        const mockNodeData = {
            nodeId: 'TEST_001',
            name: 'Test Node',
            position: { x: 0, y: 0, z: 0 },
            status: 'active'
        };

        // Mock findOne to return null (not found)
        (Node.findOne as jest.Mock).mockResolvedValue(null);

        // Mock create
        (Node.create as jest.Mock).mockResolvedValue(mockNodeData);

        const result = await nodeService.createNode(mockNodeData);

        expect(Node.findOne).toHaveBeenCalledWith({ nodeId: 'TEST_001' });
        expect(Node.create).toHaveBeenCalledWith(mockNodeData);
        expect(result).toEqual(mockNodeData);
    });

    it('should throw error if node already exists', async () => {
        const mockNodeData = { nodeId: 'DUPLICATE_001', name: 'Dup' };

        // Mock findOne to return existing doc
        (Node.findOne as jest.Mock).mockResolvedValue({ nodeId: 'DUPLICATE_001' });

        await expect(nodeService.createNode(mockNodeData))
            .rejects
            .toThrow('Node with this ID already exists');
    });

    it('should get all nodes', async () => {
        const mockNodes = [{ nodeId: 'N1' }, { nodeId: 'N2' }];
        (Node.find as jest.Mock).mockResolvedValue(mockNodes);

        const result = await nodeService.getAllNodes();

        expect(Node.find).toHaveBeenCalled();
        expect(result).toHaveLength(2);
    });
});

```

## 4. Simulation

#### simulation\Dockerfile
```
FROM python:3.10 AS base

WORKDIR /app

RUN apt-get update && apt-get install -y \
    libgl1 \
    libglib2.0-0 \
    libopenblas-dev \
    liblapack-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM base AS development
COPY . .
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

FROM base AS production
COPY src ./src
ENV PYTHONUNBUFFERED=1
EXPOSE 8000
CMD ["sh", "-c", "uvicorn src.api.server:app --host 0.0.0.0 --port ${PORT:-8080}"]

```

#### simulation\requirements.txt
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
numpy==1.24.3
opencv-python-headless==4.8.1.78

pymongo==4.6.0
motor==3.3.2
python-dateutil==2.8.2
pytz==2023.3

```

#### simulation\src\__init__.py
```python

```

#### simulation\src\anomalies\detector.py
```python
from typing import List

class AnomalyDetector:
    def detect(self, entities: List[dict]) -> List[dict]:
        anomalies = []
        
        # 1. Check Crowd Compression
        # Radius check -> if many entities in small area
        
        # 2. Check Speed
        for e in entities:
             if abs(e.get('velocity', {}).get('x', 0)) > 10: # >10m/s
                 anomalies.append({
                     'id': f"SPEED_{e['id']}",
                     'type': 'KINETICS',
                     'headline': f"High Speed Detected: {e['id']}",
                     'severity': 'MEDIUM'
                 })
                 
        return anomalies

```

#### simulation\src\anomalies\generator.py
```python
import numpy as np
from typing import List, Dict, Optional
import uuid
from datetime import datetime

class AnomalyGenerator:
    """
    Generates realistic anomalies based on entity behavior and scenario context.
    """
    
    def __init__(self):
        self.baselines = {}  # Zone -> baseline metrics
        self.anomaly_rate = 2.0  # anomalies per minute (configurable)
        self.last_anomaly_time = 0
        self.min_anomaly_interval = 5.0  # seconds between anomalies
        
    def detect(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """
        Check for anomalies based on entity behavior.
        Returns list of anomaly dicts.
        """
        anomalies = []
        
        # Update baselines
        self._update_baselines(entities, scenario)
        
        # 1. Crowd Compression (Geographics + Proxemics)
        for zone in scenario.zones:
            compression = self._check_crowd_compression(entities, zone, timestamp)
            if compression:
                anomalies.append(compression)
        
        # 2. Speed Violations (Kinetics)
        speed_anomalies = self._check_speed_anomalies(entities, timestamp)
        anomalies.extend(speed_anomalies)
        
        # 3. Loitering (Atmospherics)
        loitering = self._check_loitering(entities, timestamp)
        anomalies.extend(loitering)
        
        # 4. Restricted Zone Entry (Geographics)
        trespass = self._check_restricted_zones(entities, scenario, timestamp)
        anomalies.extend(trespass)
        
        # Apply Rule of Three
        anomalies = self._apply_rule_of_three(anomalies, timestamp)
        
        return anomalies
    
    def _check_crowd_compression(self, entities: List[Dict], zone, timestamp: float) -> Optional[Dict]:
        """Detect crowd compression/crush risk."""
        # Filter entities in this zone
        entities_in_zone = [
            e for e in entities 
            if self._entity_in_zone(e, zone)
        ]
        
        if not entities_in_zone:
            return None
        
        # Calculate density
        area = zone.area
        density = len(entities_in_zone) / area
        
        # Get baseline
        baseline_key = f"{zone.name}_density"
        baseline_density = self.baselines.get(baseline_key, 0.5)
        
        # Threshold: 2.5× baseline or >4 people/m² (crowd crush risk)
        threshold = max(baseline_density * 2.5, 4.0)
        
        if density > threshold:
            severity = 'CRITICAL' if density > 6.0 else 'HIGH'
            
            return {
                'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                'type': 'GEOGRAPHICS',
                'subtype': 'CROWD_COMPRESSION',
                'severity': severity,
                'scenario': 'CRUSH',
                'headline': f'{zone.name} Crowd Compression Risk',
                'description': f'Density {density:.1f} people/m², {density/baseline_density:.1f}× baseline',
                'baselineText': f'Normal density: {baseline_density:.1f} people/m²',
                'anomalyText': f'Current density: {density:.1f} people/m² ({len(entities_in_zone)} in {area:.0f}m²)',
                'zone': zone.name,
                'location': zone.center if hasattr(zone, 'center') else {'x': 0, 'y': 0, 'z': 0},
                'entityIds': [e['id'] for e in entities_in_zone],
                'metrics': {
                    'baselineDelta': ((density / baseline_density) - 1) * 100,
                    'confidence': 0.95,
                    'riskScore': min(density * 15, 100)
                },
                'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                'ruleOfThreeHit': False
            }
        
        return None
    
    def _check_speed_anomalies(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect excessive speed violations."""
        anomalies = []
        
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            vel = entity.get('velocity', {'x': 0, 'y': 0, 'z': 0})
            speed = np.sqrt(vel['x']**2 + vel['y']**2)  # Horizontal speed
            
            # Thresholds based on role
            role = entity.get('role', 'SPECTATOR')
            if role == 'PLAYER':
                max_speed = 10.0  # m/s (fast sprinting)
            elif role == 'OFFICIAL':
                max_speed = 5.0   # m/s
            else:
                max_speed = 2.0   # m/s (walking speed for spectators)
            
            if speed > max_speed * 1.5:  # 1.5× threshold
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'KINETICS',
                    'subtype': 'SPEED_VIOLATION',
                    'severity': 'MEDIUM',
                    'headline': f'Excessive Speed: {entity["id"]}',
                    'description': f'Entity moving at {speed:.1f} m/s, {(speed/max_speed):.1f}× expected',
                    'baselineText': f'Expected max speed: {max_speed:.1f} m/s for {role}',
                    'anomalyText': f'Current speed: {speed:.1f} m/s',
                    'zone': 'UNKNOWN',  # TODO: Determine zone from position
                    'location': entity['position'],
                    'entityIds': [entity['id']],
                    'metrics': {
                        'baselineDelta': ((speed / max_speed) - 1) * 100,
                        'confidence': 0.88,
                        'riskScore': min(speed * 8, 100)
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
        
        return anomalies
    
    def _check_loitering(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect loitering patterns (entities staying in same small area for too long)."""
        anomalies = []
        
        # Initialize history if not present
        if not hasattr(self, 'position_history'):
            self.position_history = {} # entity_id -> list of (timestamp, pos)
            
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            eid = entity['id']
            pos = entity['position']
            
            # Update history
            if eid not in self.position_history:
                self.position_history[eid] = []
                
            self.position_history[eid].append((timestamp, pos))
            
            # Prune old history (> 60 seconds)
            cutoff = timestamp - 60.0
            self.position_history[eid] = [p for p in self.position_history[eid] if p[0] > cutoff]
            
            # Check for loitering if we have enough data (e.g. > 10 seconds)
            history = self.position_history[eid]
            if len(history) < 30: # Assuming ~3fps check rate, need 10s
                continue
                
            # Calculate bounding box of movement over last window
            xs = [p[1]['x'] for p in history]
            ys = [p[1]['y'] for p in history]
            
            if not xs or not ys:
                continue
                
            x_range = max(xs) - min(xs)
            y_range = max(ys) - min(ys)
            
            # If stayed within 3m box for > 15s (approx len check)
            if x_range < 3.0 and y_range < 3.0 and (history[-1][0] - history[0][0]) > 15.0:
                # Check if already flagged recently to avoid spam is hard without state, 
                # but Rule of Three handles clustering.
                
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'ATMOSPHERICS',
                    'subtype': 'LOITERING',
                    'severity': 'LOW',
                    'headline': f'Loitering Detected: {eid}',
                    'description': f'Entity remained in 3m radius for > 15s',
                    'baselineText': 'Normal transit time: < 10s',
                    'anomalyText': f'Stationary duration: {history[-1][0] - history[0][0]:.1f}s',
                    'zone': 'UNKNOWN', 
                    'location': pos,
                    'entityIds': [eid],
                    'metrics': {
                        'baselineDelta': 50,
                        'confidence': 0.85,
                        'riskScore': 40
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
                
        return anomalies
    
    def _check_restricted_zones(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """Detect entities entering restricted zones."""
        anomalies = []
        
        restricted_zones = [z for z in scenario.zones if z.type == 'RESTRICTED']
        
        for zone in restricted_zones:
            for entity in entities:
                if entity.get('role') == 'PLAYER':
                    continue  # Players allowed in restricted zones
                    
                if self._entity_in_zone(entity, zone):
                    anomalies.append({
                        'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                        'type': 'GEOGRAPHICS',
                        'subtype': 'RESTRICTED_ZONE_ENTRY',
                        'severity': 'HIGH',
                        'headline': f'Unauthorized Entry: {zone.name}',
                        'description': f'{entity["id"]} entered restricted zone',
                        'baselineText': f'Zone {zone.name} is restricted',
                        'anomalyText': f'{entity["role"]} entity detected in zone',
                        'zone': zone.name,
                        'location': entity['position'],
                        'entityIds': [entity['id']],
                        'metrics': {
                            'baselineDelta': 100,
                            'confidence': 0.92,
                            'riskScore': 75
                        },
                        'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                        'ruleOfThreeHit': False
                    })
        
        return anomalies
    
    def _apply_rule_of_three(self, anomalies: List[Dict], timestamp: float) -> List[Dict]:
        """
        Apply Rule of Three: flag when 3+ independent anomaly types
        converge in same space-time.
        """
        # Group anomalies by proximity
        spatial_threshold = 10.0  # meters
        temporal_threshold = 30.0  # seconds
        
        groups = []
        for anomaly in anomalies:
            placed = False
            for group in groups:
                # Check if anomaly belongs to this group
                representative = group[0]
                
                # Spatial proximity
                loc1 = anomaly['location']
                loc2 = representative['location']
                dist = np.sqrt(
                    (loc1['x'] - loc2['x'])**2 + 
                    (loc1['y'] - loc2['y'])**2
                )
                
                # Temporal proximity
                time_diff = abs(
                    anomaly['occurredAt'].timestamp() - 
                    representative['occurredAt'].timestamp()
                )
                
                if dist < spatial_threshold and time_diff < temporal_threshold:
                    group.append(anomaly)
                    placed = True
                    break
            
            if not placed:
                groups.append([anomaly])
        
        # Check each group for Rule of Three
        for group in groups:
            distinct_types = set(a['type'] for a in group)
            
            if len(distinct_types) >= 3:
                # Mark all anomalies in group
                for anomaly in group:
                    anomaly['ruleOfThreeHit'] = True
                    anomaly['severity'] = 'CRITICAL'  # Escalate
                    anomaly['relatedAnomalies'] = [
                        a['anomalyId'] for a in group if a != anomaly
                    ]
        
        return anomalies
    
    def _update_baselines(self, entities: List[Dict], scenario):
        """Update baseline metrics using exponential moving average."""
        # TODO: Implement proper baseline learning
        # For now, use static baselines
        for zone in scenario.zones:
            baseline_key = f"{zone.name}_density"
            if baseline_key not in self.baselines:
                self.baselines[baseline_key] = 1.0  # 1 person/m² default
    
    def _entity_in_zone(self, entity: Dict, zone) -> bool:
        """Check if entity is inside zone bounds."""
        pos = entity['position']
        bounds = zone.bounds  # (x_min, y_min, x_max, y_max)
        
        return (
            bounds[0] <= pos['x'] <= bounds[2] and
            bounds[1] <= pos['y'] <= bounds[3]
        )

```

#### simulation\src\api\server.py
```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import uvicorn
import os

from src.core.orchestrator import SimulationOrchestrator

orchestrator = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global orchestrator
    # Initialize with default config
    orchestrator = SimulationOrchestrator({})
    print("Simulation Engine Starting...")
    yield
    # Shutdown
    if orchestrator:
        orchestrator.stop()
    print("Simulation Engine Stopping...")

app = FastAPI(lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "simulation-engine"}

@app.post("/simulation/start")
async def start_simulation(config: dict):
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.load_scenario(config.get('sport', 'BASKETBALL'), config)
    orchestrator.start()
    return {"status": "started"}

@app.post("/simulation/stop")
async def stop_simulation():
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.stop()
    return {"status": "stopped"}

    return StreamingResponse(
        orchestrator.get_video_stream(node_id), 
        media_type="multipart/x-mixed-replace; boundary=frame"
    )

@app.post("/nodes/{node_id}/calibrate")
async def calibrate_node(node_id: str):
    """Simulate calibration for a node."""
    if not orchestrator:
         raise HTTPException(status_code=503, detail="Orchestrator not initialized")
    
    import random
    import time
    return {
        "nodeId": node_id,
        "calibration": {
            "reprojectionError": random.uniform(0.01, 0.05),
            "status": "SUCCESS",
            "timestamp": time.time()
        }
    }

@app.get("/")
async def root():
    return {"message": "Motion Intelligence Simulation Engine v1.0"}

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("src.api.server:app", host="0.0.0.0", port=port, reload=True)

```

#### simulation\src\calibration\utils.py
```python
import numpy as np

def generate_default_calibration():
    # Intrinsic (Camera)
    # 1920x1080, FOV ~90 deg
    fx = 1000
    fy = 1000
    cx = 960
    cy = 540
    camera_matrix = [
        [fx, 0, cx],
        [0, fy, cy],
        [0, 0, 1]
    ]
    
    # Extrinsic (Identity for now)
    rotation = np.eye(3).tolist()
    translation = [0, 0, 0]
    
    # Lidar to Camera (Example: Camera is 10cm above LIDAR)
    lidar_to_camera = np.eye(4)
    lidar_to_camera[1, 3] = -0.1 # y-axis translation
    
    return {
        'intrinsic': {
            'cameraMatrix': camera_matrix,
            'distortion': [0, 0, 0, 0, 0]
        },
        'extrinsic': {
            'rotationMatrix': rotation,
            'translationVector': translation
        },
        'lidarToCameraTransform': lidar_to_camera.tolist(),
        'calibrationQuality': 100,
        'calibratedAt': '2025-12-16T12:00:00Z'
    }

```

#### simulation\src\core\orchestrator.py
```python
import os
import time
import threading
from typing import List, Optional, Dict
import numpy as np

from .physics_engine import PhysicsEngine
from .scenario_manager import ScenarioManager
from ..nodes.edge_node import EdgeNode
from ..anomalies.generator import AnomalyGenerator
from ..utils.ptp_sync import PTPClock

class SimulationOrchestrator:
    def __init__(self, config: dict):
        self.config = config
        self.running = False
        self.paused = False
        self.thread = None
        
        # Core components
        self.physics_engine = PhysicsEngine()
        self.scenario = None
        self.anomaly_generator = AnomalyGenerator()
        self.clock = PTPClock(is_master=True)
        
        # State
        self.nodes: List[EdgeNode] = []
        self.entities: List[Dict] = []
        self.current_time = 0.0
        self.frame_count = 0
        self.target_fps = 30
        self.actual_fps = 0.0
        
    def load_scenario(self, sport: str, config: dict):
        """Load sport-specific scenario."""
        self.scenario = ScenarioManager.create_scenario(sport, config)
        self.scenario.initialize(self.entities)
        print(f"Loaded scenario: {sport} with {len(self.entities)} entities")
        
    def add_node(self, node_config: dict) -> EdgeNode:
        """Add a sensor node to the simulation."""
        node = EdgeNode(
            node_id=node_config['nodeId'],
            position=np.array([
                node_config['position']['x'],
                node_config['position']['y'],
                node_config['position']['z']
            ]),
            orientation=np.array([
                node_config['orientation']['pitch'],
                node_config['orientation']['yaw'],
                node_config['orientation']['roll']
            ]),
            sensors=node_config['sensors'],
            calibration=node_config.get('calibration', {})
        )
        self.nodes.append(node)
        print(f"Added node: {node_config['nodeId']}")
        return node
        
    def start(self):
        """Start the simulation loop."""
        if self.running:
            return
            
        if not self.scenario:
            # Fallback for empty start
            try:
                self.load_scenario('BASKETBALL', {})
            except:
                print("Failed to load default scenario")
            
        self.running = True
        self.paused = False
        self.thread = threading.Thread(target=self._loop, daemon=True)
        self.thread.start()
        print("Simulation started")
        
    def stop(self):
        """Stop the simulation."""
        self.running = False
        if self.thread:
            self.thread.join()
        print("Simulation stopped")
        
    def pause(self):
        """Pause the simulation."""
        self.paused = True
        
    def resume(self):
        """Resume the simulation."""
        self.paused = False
        
    def _loop(self):
        """Main simulation loop - runs at 30 FPS."""
        target_dt = 1.0 / self.target_fps
        last_fps_check = time.time()
        fps_frame_count = 0
        
        while self.running:
            if self.paused:
                time.sleep(0.1)
                continue
                
            loop_start = time.time()
            
            # 1. Update simulation time (PTP clock)
            self.current_time = self.clock.get_time() / 1e9  # Convert ns to seconds
            
            # 2. Update entity behaviors (scenario-specific)
            if self.scenario:
                self.scenario.update(self.entities, target_dt)
            
            # 3. Update physics (entity movement)
            self.physics_engine.step(self.entities, target_dt)
            
            # 4. Generate sensor data from all nodes
            # For this MVP, we just generate generating logs or frames
            # Logic to publish via WebSocket would go here
            # 4. Generate sensor data from all nodes
            for node in self.nodes:
                # This updates internal buffers like last_camera_frame
                node.generate_frame(
                    entities=self.entities,
                    timestamp=self.current_time
                )
            
            # 5. Detect anomalies
            if self.scenario:
                anomalies = self.anomaly_generator.detect(
                    entities=self.entities,
                    scenario=self.scenario,
                    timestamp=self.current_time
                )
                for anomaly in anomalies:
                    self._publish_anomaly(anomaly)
            
            # 6. Update frame counter
            self.frame_count += 1
            fps_frame_count += 1
            
            # 7. Calculate actual FPS every second
            now = time.time()
            if now - last_fps_check >= 1.0:
                self.actual_fps = fps_frame_count / (now - last_fps_check)
                fps_frame_count = 0
                last_fps_check = now
                # print(f"Simulation FPS: {self.actual_fps:.1f} | Entities: {len(self.entities)}")
            
            # 8. Sleep to maintain frame rate
            elapsed = time.time() - loop_start
            if elapsed < target_dt:
                time.sleep(target_dt - elapsed)
                
            # Broadcast updates (Every 3 frames approx 10Hz)
            if self.frame_count % 3 == 0:
                self._publish_entities()

    def _publish_entities(self):
        """Send entity positions to API."""
        try:
            # Basic validation
            if not self.entities:
                return

            payload = {
                'sessionId': None, # TODO: Pass session ID if managed
                'stats': {
                    'fps': self.actual_fps,
                    'frame': self.frame_count,
                    'time': self.current_time
                },
                'sentAt': time.time(),
                'entities': [
                    {
                        'id': e.get('id'),
                        'type': e.get('type'),
                        'role': e.get('role'),
                        'team': e.get('team'),
                        'position': e.get('position'),
                        'velocity': e.get('velocity'),
                        'color': e.get('color'),
                        'radius': e.get('radius'),
                        'severity': e.get('severity')
                    }
                    for e in self.entities
                ]
            }
            
            # Fire and forget POST
            # Using threads or async here would be better for performance, 
            # but for this simulation loop strictness, a short timeout is acceptable logic 
            # if we assume local network.
            try:
                import requests
                api_url = os.getenv('API_URL', 'http://api:3001')
                response = requests.post(
                    f"{api_url}/internal/entity-update",
                    json=payload,
                    timeout=0.2 
                )
                if response.status_code != 200:
                    print(f"Warning: API returned status {response.status_code} for entity-update")
            except ImportError:
                print("requests module not found")
            except Exception as e:
                # print(f"Failed to publish entities: {e}")
                pass # Still suppress to avoid loop crash, but could log periodically
                
        except Exception as e:
            print(f"Error publishing entities: {e}")

    def _publish_anomaly(self, anomaly):
        """Publish detected anomaly."""
        try:
            import requests
            requests.post(
                f"{os.getenv('API_URL', 'http://api:3001')}/internal/anomaly",
                json={
                    'sessionId': None,
                    'anomaly': anomaly
                },
                timeout=0.1
            )
        except Exception as e:
            print(f"Failed to publish anomaly: {e}")

    def get_video_stream(self, node_id: str):
        """Generator for MJPEG stream from a specific node."""
        node = next((n for n in self.nodes if n.node_id == node_id), None)
        if not node:
            return

        while self.running:
            frame = node.last_camera_frame
            if frame:
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
            
            # rate limit to approx 30 fps to avoid busy loop
            time.sleep(0.033)



```

#### simulation\src\core\physics_engine.py
```python
import numpy as np
from typing import List

class PhysicsEngine:
    def __init__(self):
        self.gravity = -9.81
        self.friction_coeff = 0.5

    def step(self, entities: List[dict], dt: float):
        """
        Update entity positions based on velocity and forces.
        """
        for entity in entities:
            # Simple Euler integration
            vel = np.array(entity.get('velocity', [0, 0, 0]), dtype=float)
            pos = np.array(entity.get('position', [0, 0, 0]), dtype=float)
            
            # Apply friction (damping)
            vel = vel * (1.0 - self.friction_coeff * dt)
            
            # Update position
            pos += vel * dt
            
            # Floor constraint (z >= 0)
            if pos[2] < 0:
                pos[2] = 0
                vel[2] = 0
            
            # Update entity state
            entity['position'] = {
                'x': float(pos[0]),
                'y': float(pos[1]),
                'z': float(pos[2])
            }
            entity['velocity'] = {
                'x': float(vel[0]),
                'y': float(vel[1]),
                'z': float(vel[2])
            }

```

#### simulation\src\core\scenario_manager.py
```python
from typing import List, Dict, Optional
import numpy as np

class Zone:
    def __init__(self, name: str, bounds: tuple, area: float, type: str):
        self.name = name
        self.bounds = bounds # (x_min, y_min, x_max, y_max)
        self.area = area
        self.type = type
        self.center = {
            'x': (bounds[0] + bounds[2]) / 2,
            'y': (bounds[1] + bounds[3]) / 2,
            'z': 0
        }

class Scenario:
    def __init__(self):
        self.zones: List[Zone] = []
        self.entities: List[dict] = []
        self.sport = 'UNKNOWN'

    def initialize(self, entities: List[dict]):
        """Populate initial entities"""
        pass

    def update(self, entities: List[dict], dt: float):
        """Update entity behaviors"""
        pass

class ScenarioManager:
    @staticmethod
    def create_scenario(sport: str, config: dict) -> Scenario:
        if sport == 'BASKETBALL':
            from ..sports.basketball import BasketballScenario
            return BasketballScenario(config)
        else:
            raise ValueError(f"Unknown sport: {sport}")

```

#### simulation\src\nodes\camera_simulator.py
```python
import numpy as np
import cv2
import time
from typing import List, Tuple, Optional

class CameraSimulator:
    def __init__(self, resolution: dict, fps: int, fov: float):
        self.width = resolution['width']
        self.height = resolution['height']
        self.fps = fps
        self.fov = fov
        self.last_frame_time = 0
        self.frame_interval = 1.0 / fps

    def render(self, entities: List[dict], timestamp: float) -> Optional[bytes]:
        """
        Render a frame if enough time has passed.
        Returns JPEG bytes or None.
        """
        # Simple frame rate control
        if timestamp - self.last_frame_time < self.frame_interval:
            return None
            
        self.last_frame_time = timestamp
        
        # Create blank image (dark gray background)
        image = np.full((self.height, self.width, 3), 30, dtype=np.uint8)
        
        # Draw entities (simplified 2D projection for now)
        for entity in entities:
             # Basic projection logic (placeholder)
             # In a real 3D sim, we'd use a projection matrix
             pos = entity.get('position', {'x':0, 'y':0, 'z':0})
             
             # Map x/y to screen coordinates (very rough approx)
             cx = int(self.width / 2 + pos['x'] * 50) 
             cy = int(self.height / 2 + pos['y'] * 50)
             
             if 0 <= cx < self.width and 0 <= cy < self.height:
                 cv2.circle(image, (cx, cy), 10, (0, 255, 0), -1)
                 cv2.putText(image, entity.get('id', '?'), (cx+15, cy), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        # Add noise
        noise = np.random.normal(0, 5, image.shape).astype(np.uint8)
        image = cv2.add(image, noise)
        
        # Encode to JPEG
        _, encoded = cv2.imencode('.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 80])
        return encoded.tobytes()

```

#### simulation\src\nodes\edge_node.py
```python
from typing import List, Dict, Any
import numpy as np
from .camera_simulator import CameraSimulator
from .lidar_simulator import LidarSimulator
from .imu_simulator import IMUSimulator

class EdgeNode:
    def __init__(self, node_id: str, position: np.ndarray, orientation: np.ndarray, sensors: dict, calibration: dict):
        self.node_id = node_id
        self.position = position
        self.orientation = orientation
        self.calibration = calibration
        self.last_camera_frame = None
        
        # Initialize Sensors
        self.camera = None
        if sensors.get('camera', {}).get('enabled'):
            cam_config = sensors['camera']
            self.camera = CameraSimulator(
                resolution=cam_config.get('resolution', {'width': 1920, 'height': 1080}),
                fps=cam_config.get('fps', 30),
                fov=cam_config.get('fov', 90)
            )
            
        self.lidar = None
        if sensors.get('lidar', {}).get('enabled'):
            lid_config = sensors['lidar']
            self.lidar = LidarSimulator(
                model=lid_config.get('model', 'VLP-16'),
                channels=lid_config.get('channels', 16),
                range_m=lid_config.get('range', 100)
            )
            
        self.imu = None
        if sensors.get('imu', {}).get('enabled'):
            self.imu = IMUSimulator(sample_rate=100)

    def generate_frame(self, entities: List[dict], timestamp: float) -> Dict[str, Any]:
        """Generate a synchronized frame from all enabled sensors."""
        frame = {
            'nodeId': self.node_id,
            'timestamp': timestamp,
            'sensors': {}
        }
        
        # Transform entities to node-local coordinates if needed
        # For now, simulators handle global entities
        
        if self.camera:
            image_data = self.camera.render(entities, timestamp)
            if image_data:
                frame['sensors']['camera'] = image_data # In real app, this would be a path or heavy blob
                self.last_camera_frame = image_data
        
        if self.lidar:
            point_cloud = self.lidar.scan(entities, timestamp)
            frame['sensors']['lidar'] = point_cloud # Numpy array
            
        if self.imu:
            imu_data = self.imu.read(timestamp, self.position) # Simplified IMU read
            frame['sensors']['imu'] = imu_data
            
        return frame

```

#### simulation\src\nodes\fusion_engine.py
```python
import numpy as np
from typing import List, Dict

class FusionEngine:
    """
    Fuses camera + LIDAR data at edge node.
    Core learning objective: demonstrates sensor fusion concepts.
    """
    
    def __init__(self, camera_matrix=None, lidar_to_camera_transform=None):
        # Defaults if not provided
        self.camera_matrix = camera_matrix if camera_matrix is not None else np.eye(3)
        self.transform = lidar_to_camera_transform if lidar_to_camera_transform is not None else np.eye(4)
        
    def _project_lidar_to_image(self, points):
        """Project 3D LIDAR points to 2D camera coordinates."""
        if len(points) == 0:
            return np.array([])
            
        # 1. Transform Lidar -> Camera frame
        # We assume standard Camera frame: X right, Y down, Z forward
        # Simple simulation hack: rotate points to align with camera Z
        # R_lidar_cam = np.array([[0, -1, 0], [0, 0, -1], [1, 0, 0]])
        # points_cam = points @ R_lidar_cam.T + np.array([0, 0, 0])
        
        # For simplicity in this demo, treat world X,Y as 'flat' image plane scaling
        focal_length = 1000
        
        u = focal_length * (points[:, 0] / (points[:, 1] + 1e-6)) + 960  # Center X
        v = focal_length * (points[:, 2] / (points[:, 1] + 1e-6)) + 540  # Center Y (Z is up in input, Y down in image)
        
        # Filter points behind camera (Y < 0)
        valid_mask = points[:, 1] > 0
        
        projected = np.zeros((len(points), 3))
        projected[:, 0] = u
        projected[:, 1] = v
        projected[:, 2] = valid_mask
        
        return projected

    def _iou(self, point, bbox):
        """Check if point is inside bbox."""
        x, y = point[0], point[1]
        x1, y1, x2, y2 = bbox
        return x1 <= x <= x2 and y1 <= y <= y2

    def fuse(self, camera_image, lidar_points, entities):
        """
        Perform fusion of camera and LIDAR data.
        Returns: List of detected entities with 3D positions derived from LIDAR clusters.
        """
        detections = []
        
        # 1. Project LIDAR points to camera image
        projected_points_2d = self._project_lidar_to_image(lidar_points[:, :3])
        
        # 2. Run 2D object detection (Simulated)
        bboxes = self._detect_objects_2d(camera_image, entities)
        
        # 3. Associate and Fuse
        for bbox_data in bboxes:
            bbox = bbox_data['bbox']
            
            # Find points inside this bbox
            points_inside_indices = []
            for i, pt in enumerate(projected_points_2d):
                if pt[2] > 0 and self._iou(pt, bbox): # Check validity and bounds
                    points_inside_indices.append(i)
            
            # Fuse: Compute centroid of associated LIDAR points
            if points_inside_indices:
                cluster = lidar_points[points_inside_indices]
                fused_pos = np.mean(cluster[:, :3], axis=0)
                confidence = 0.9 + (len(points_inside_indices) / 100.0) # More points = higher confidence
            else:
                # Fallback if no LIDAR hits (e.g. occlusion): use purely visual estimate or prior
                # For simulaton, fallback to entity truth + large noise
                target_entity = next((e for e in entities if e['id'] == bbox_data['entity_id']), None)
                if target_entity:
                    pos = target_entity['position']
                    fused_pos = np.array([pos['x'], pos['y'], pos['z']]) + np.random.normal(0, 0.5, 3)
                    confidence = 0.5
                else:
                    continue

            detections.append({
                'entityId': bbox_data['entity_id'],
                'position3d': fused_pos.tolist(),
                'velocity': [0, 0, 0], # Kalman filter would determine this over time
                'confidence': min(confidence, 1.0),
                'bbox2d': bbox
            })
        
        return detections

    def _detect_objects_2d(self, image, entities):
        """Simulate YOLO detection."""
        bboxes = []
        for entity in entities:
            # Simple manual projection for bounding box simulation
            pos = entity['position']
            # Scale world coords to 'pixel' coords roughly
            cx = 960 + (pos['x'] * 50) 
            cy = 540 - (pos['z'] * 50) 
            w, h = 60 / (pos['y']*0.1 + 1), 120 / (pos['y']*0.1 + 1)
            
            bboxes.append({
                'entity_id': entity['id'],
                'bbox': [cx - w/2, cy - h/2, cx + w/2, cy + h/2],
                'confidence': 0.95
            })
        return bboxes

```

#### simulation\src\nodes\imu_simulator.py
```python
import numpy as np

class IMUSimulator:
    def __init__(self, sample_rate: int):
        self.sample_rate = sample_rate
        self.accel_bias = np.random.normal(0, 0.01, 3)
        self.gyro_bias = np.random.normal(0, 0.001, 3)

    def sample(self, timestamp: float, motion: dict) -> dict:
        """
        Generate IMU reading based on actual motion.
        """
        true_accel = motion.get('acceleration', np.zeros(3))
        true_gyro = motion.get('angular_velocity', np.zeros(3))
        
        # Add noise and bias
        accel_noise = np.random.normal(0, 0.01, 3)
        gyro_noise = np.random.normal(0, 0.001, 3)
        
        accel = true_accel + self.accel_bias + accel_noise
        gyro = true_gyro + self.gyro_bias + gyro_noise
        
        # Add gravity (assuming z is up)
        accel[2] += 9.81
        
        return {
            'acceleration': accel.tolist(),
            'gyroscope': gyro.tolist(),
            'temperature': 45.0 + np.random.normal(0, 0.1)
        }

```

#### simulation\src\nodes\lidar_simulator.py
```python
import numpy as np
from typing import List, Tuple

class LidarSimulator:
    def __init__(self, model: str, channels: int, range_m: float):
        self.model = model
        self.channels = channels
        self.range = range_m
        self.points_per_second = 300000

    def scan(self, entities: List[dict], timestamp: float) -> np.ndarray:
        """
        Generate a point cloud.
        Returns numpy array of (x, y, z, intensity).
        """
        # Generate background points (ground plane)
        # Simplified: Grid of points
        x = np.linspace(-20, 20, 100)
        y = np.linspace(-20, 20, 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X) # Ground is at z=0
        
        # Flatten
        ground_points = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1)
        
        entity_points = []
        for entity in entities:
            pos = entity.get('position', {'x':0, 'y':0, 'z':0})
            # Generate a cluster of points for the entity
            num_points = 50
            # Gaussian distribution around entity position
            ep = np.random.normal([pos['x'], pos['y'], pos['z']], 0.2, (num_points, 3))
            entity_points.append(ep)
            
        if entity_points:
            all_entity_points = np.vstack(entity_points)
            points = np.vstack([ground_points, all_entity_points])
        else:
            points = ground_points

        # Add intensity (random for now)
        intensities = np.random.rand(len(points), 1)
        
        return np.hstack([points, intensities]).astype(np.float32)

```

#### simulation\src\sports\basketball.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class BasketballScenario(Scenario):
    """NBA-style basketball simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'BASKETBALL'
        
        # Court dimensions (NBA standard in meters)
        self.court_length = 28.65
        self.court_width = 15.24
        
        # Zones
        self.zones = [
            Zone(
                name='COURT',
                bounds=self._court_bounds(),
                area=self.court_length * self.court_width,
                type='FIELD'
            ),
            Zone(
                name='HOME_BENCH',
                bounds=(0, 0, 5, 2),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='AWAY_BENCH',
                bounds=(0, self.court_width - 2, 5, self.court_width),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='PAINT_HOME',
                bounds=(0, self.court_width/2 - 2.44, 5.8, self.court_width/2 + 2.44),
                area=28.3,
                type='RESTRICTED'
            )
        ]
        
        self.crowd_count = config.get('crowdCount', 5000) if config else 5000
        
    def initialize(self, entities: List[Dict]):
        """Set up players, refs, ball, crowd."""
        
        # Home team (5 players)
        for i in range(5):
            pos = self._get_formation_position('HOME', i)
            entity = {
                'id': f'HOME_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'HOME',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (255, 0, 0),  # Red
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Away team (5 players)
        for i in range(5):
            pos = self._get_formation_position('AWAY', i)
            entity = {
                'id': f'AWAY_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'AWAY',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (0, 0, 255),  # Blue
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Referees (3)
        for i in range(3):
            entity = {
                'id': f'REF_{i+1}',
                'type': 'PERSON',
                'role': 'OFFICIAL',
                'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 1.8,
                'color': (128, 128, 128),  # Gray
                'reflectance': 0.4,
                'behavior': 'referee'
            }
            entities.append(entity)
        
        # Basketball
        entity = {
            'id': 'BALL',
            'type': 'OBJECT',
            'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 1.5},
            'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
            'radius': 0.12,
            'color': (255, 165, 0),  # Orange
            'reflectance': 0.6
        }
        entities.append(entity)
        
        # Crowd (simplified - grouped entities)
        self._generate_crowd(entities, self.crowd_count)
        
        print(f"Basketball scenario initialized: {len(entities)} entities")
        
    def update(self, entities: List[Dict], dt: float):
        """Update entity behaviors each frame."""
        for entity in entities:
            behavior = entity.get('behavior')
            
            if behavior == 'basketball_player':
                self._update_player_behavior(entity, entities, dt)
            elif behavior == 'referee':
                self._update_referee_behavior(entity, entities, dt)
        
        # Update ball physics (bouncing, possession)
        self._update_ball(entities, dt)
        
    def _get_formation_position(self, team: str, index: int) -> tuple:
        """Get initial position for player in formation."""
        # Simple positioning - half court
        if team == 'HOME':
            x_base = self.court_length * 0.25
        else:
            x_base = self.court_length * 0.75
            
        # Spread players across court width
        y = (self.court_width / 6) * (index + 1)
        
        return (x_base, y)
        
    def _update_player_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Basic basketball player AI."""
        # Find ball
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Move towards ball (simplified)
        dx = ball['position']['x'] - entity['position']['x']
        dy = ball['position']['y'] - entity['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 0.5:  # Not at ball
            # Move towards ball
            speed = 3.0  # m/s
            entity['velocity']['x'] = (dx / dist) * speed
            entity['velocity']['y'] = (dy / dist) * speed
        else:
            # At ball - slow down
            entity['velocity']['x'] *= 0.5
            entity['velocity']['y'] *= 0.5
            
    def _update_referee_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Referee follows play."""
        # Similar to player but slower
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if ball:
            dx = ball['position']['x'] - entity['position']['x']
            dy = ball['position']['y'] - entity['position']['y']
            dist = np.sqrt(dx**2 + dy**2)
            
            if dist > 3.0:
                speed = 2.0
                entity['velocity']['x'] = (dx / dist) * speed
                entity['velocity']['y'] = (dy / dist) * speed
                
    def _update_ball(self, entities: List[Dict], dt: float):
        """Update ball physics."""
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Gravity
        ball['velocity']['z'] -= 9.81 * dt
        
        # Bounce on floor
        if ball['position']['z'] <= 0.12:  # Ball radius
            ball['position']['z'] = 0.12
            ball['velocity']['z'] = -ball['velocity']['z'] * 0.7  # Bounce with loss
            
    def _court_bounds(self) -> tuple:
        """Return (x_min, y_min, x_max, y_max)."""
        return (0, 0, self.court_length, self.court_width)
        
    def _generate_crowd(self, entities: List[Dict], count: int):
        """Generate crowd entities (simplified grouping)."""
        # Stands are outside court boundaries
        # Create grouped "crowd sections" rather than individual spectators
        num_sections = 8
        people_per_section = count // num_sections
        
        for i in range(num_sections):
            entity = {
                'id': f'CROWD_SECTION_{i+1}',
                'type': 'GROUP',
                'role': 'SPECTATOR',
                'count': people_per_section,
                'position': {
                    'x': np.random.uniform(-5, self.court_length + 5),
                    'y': np.random.uniform(-5, self.court_width + 5),
                    'z': 0.0
                },
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 2.0,  # Group radius
                'color': (100, 100, 200),
                'reflectance': 0.3
            }
            entities.append(entity)

```

#### simulation\src\sports\combat.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class CombatScenario(Scenario):
    """MMA/Boxing style simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'COMBAT'
        self.ring_size = 9.0 # meters
        
        self.zones = [
            Zone(name='RING', bounds=(0,0,self.ring_size,self.ring_size), area=81, type='RING'),
            Zone(name='RINGSIDE', bounds=(-2,-2,self.ring_size+2,self.ring_size+2), area=150, type='RESTRICTED')
        ]

    def initialize(self, entities: List[Dict]):
        # Fighter 1
        entities.append({
            'id': 'FIGHTER_1', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (255, 0, 0)
        })
        
        # Fighter 2
        entities.append({
            'id': 'FIGHTER_2', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size*2/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (0, 0, 255)
        })
        
        # Referee
        entities.append({
            'id': 'REF', 'type': 'PERSON', 'role': 'OFFICIAL',
            'position': {'x': self.ring_size/2, 'y': self.ring_size/4, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.75, 'color': (200, 200, 200)
        })

    def update(self, entities: List[Dict], dt: float):
        f1 = next(e for e in entities if e['id'] == 'FIGHTER_1')
        f2 = next(e for e in entities if e['id'] == 'FIGHTER_2')
        
        # Circle each other
        center_x = (f1['position']['x'] + f2['position']['x']) / 2
        center_y = (f1['position']['y'] + f2['position']['y']) / 2
        
        for f in [f1, f2]:
            dx = center_x - f['position']['x']
            dy = center_y - f['position']['y']
            # Add orbit logic here... simplified
            f['velocity']['x'] += (np.random.rand()-0.5) * 2.0
            f['velocity']['y'] += (np.random.rand()-0.5) * 2.0
            
            # Keep in ring
            next_x = f['position']['x'] + f['velocity']['x'] * dt
            next_y = f['position']['y'] + f['velocity']['y'] * dt
            
            if next_x < 0 or next_x > self.ring_size:
                f['velocity']['x'] *= -1
            if next_y < 0 or next_y > self.ring_size:
                f['velocity']['y'] *= -1

```

#### simulation\src\sports\soccer.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class SoccerScenario(Scenario):
    """FIFA-style soccer simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'SOCCER'
        
        # Field dimensions (Standard 105m x 68m)
        self.field_length = 105.0
        self.field_width = 68.0
        
        # Zones
        self.zones = [
            Zone(
                name='FIELD',
                bounds=(0, 0, self.field_length, self.field_width),
                area=self.field_length * self.field_width,
                type='FIELD'
            ),
             Zone(
                name='PENALTY_AREA_HOME',
                bounds=(0, self.field_width/2 - 20.15, 16.5, self.field_width/2 + 20.15),
                area=665.0, # Approx
                type='RESTRICTED'
            ),
             Zone(
                name='PENALTY_AREA_AWAY',
                bounds=(self.field_length - 16.5, self.field_width/2 - 20.15, self.field_length, self.field_width/2 + 20.15),
                area=665.0,
                type='RESTRICTED'
            )
        ]
        
    def initialize(self, entities: List[Dict]):
        # Home Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('HOME', i)
            entities.append(self._create_player(f'HOME_{i+1}', 'HOME', pos, (255, 0, 0)))

        # Away Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('AWAY', i)
            entities.append(self._create_player(f'AWAY_{i+1}', 'AWAY', pos, (0, 0, 255)))
            
        # Ball
        entities.append({
            'id': 'BALL', 'type': 'OBJECT', 
            'position': {'x': self.field_length/2, 'y': self.field_width/2, 'z': 0.11},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.11, 'color': (255, 255, 255)
        })

    def update(self, entities: List[Dict], dt: float):
        # Very simple AI: chase ball
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball: return
        
        for e in entities:
            if e.get('role') == 'PLAYER':
                self._update_player(e, ball, dt)

    def _create_player(self, pid, team, pos, color):
        return {
            'id': pid, 'type': 'PERSON', 'role': 'PLAYER', 'team': team,
            'position': {'x': pos[0], 'y': pos[1], 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.8, 'color': color, 'behavior': 'soccer_player'
        }

    def _get_formation_position(self, team, index):
        # 4-4-2 Formation stub
        base_x = 10 if team == 'HOME' else self.field_length - 10
        direction = 1 if team == 'HOME' else -1
        
        if index == 0: # GK
            return (base_x, self.field_width/2)
        elif index < 5: # Defenders
            return (base_x + 15*direction, self.field_width * (index/5))
        elif index < 9: # Midfielders
            return (base_x + 35*direction, self.field_width * ((index-4)/5))
        else: # Forwards
            return (base_x + 55*direction, self.field_width * ((index-8)/3))

    def _update_player(self, player, ball, dt):
        # Determine if this player is closest to ball for their team
        # In a full sim, we'd check all teammates.
        # For efficiency here, we'll just check distance vs fixed threshold
        
        dx_ball = ball['position']['x'] - player['position']['x']
        dy_ball = ball['position']['y'] - player['position']['y']
        dist_ball = np.sqrt(dx_ball**2 + dy_ball**2)
        
        # Calculate formation target
        pid_parts = player['id'].split('_')
        idx = int(pid_parts[1]) - 1 if len(pid_parts) > 1 else 0
        form_pos = self._get_formation_position(player['team'], idx)
        
        # Formation force
        dx_form = form_pos[0] - player['position']['x']
        dy_form = form_pos[1] - player['position']['y']
        dist_form = np.sqrt(dx_form**2 + dy_form**2)
        
        # Logic: If close to ball (within 15m), chase ball. Else, hold formation.
        if dist_ball < 15.0:
            target_dx, target_dy, target_dist = dx_ball, dy_ball, dist_ball
            speed = 5.0 # Sprint
        else:
            target_dx, target_dy, target_dist = dx_form, dy_form, dist_form
            speed = 2.0 # Jog
            
        if target_dist > 0.5:
            player['velocity']['x'] = (target_dx / target_dist) * speed
            player['velocity']['y'] = (target_dy / target_dist) * speed
        else:
            player['velocity']['x'] = 0
            player['velocity']['y'] = 0

```

#### simulation\src\utils\ptp_sync.py
```python
import time
import numpy as np

class PTPClock:
    """
    IEEE 1588 Precision Time Protocol simulation.
    Simulates clock drift and offset correction.
    """
    
    def __init__(self, is_master: bool = True):
        self.is_master = is_master
        self.epoch = time.time_ns()
        self.crystal_frequency = 1e9  # 1 GHz nominal
        # Simulate hardware clock drift (parts per million)
        self.ppm_drift = np.random.uniform(-30, 30) if not is_master else 0.0
        self.offset_ns = 0
        
    def get_time(self) -> int:
        """Get current PTP time in nanoseconds."""
        elapsed = time.time_ns() - self.epoch
        # Apply simulated drift
        drift_factor = 1.0 + (self.ppm_drift / 1e6)
        
        return int(elapsed * drift_factor) + self.offset_ns + self.epoch
    
    def get_time_sec(self) -> float:
        """Get current PTP time in seconds."""
        return self.get_time() / 1e9
    
    def sync_with_master(self, master_time: int):
        """Synchronize slave clock with master time sample."""
        if self.is_master:
            return
            
        current_time = self.get_time()
        offset = master_time - current_time
        
        # Simple PI controller for smooth clock discipline
        # In a real PTP stack this is much more complex
        self.offset_ns += int(offset * 0.5)

```

#### simulation\tests\test_camera_simulator.py
```python
import unittest
import numpy as np
from src.nodes.camera_simulator import CameraSimulator

class TestCameraSimulator(unittest.TestCase):
    def setUp(self):
        self.camera = CameraSimulator(
            resolution={'width': 1920, 'height': 1080},
            fps=30,
            fov=90
        )
    
    def test_render_returns_bytes_when_due(self):
        # Timestamp 0.0 -> should render
        # Timestamp 0.001 -> should NOT render (too soon for 30fps)
        
        entities = [{'id': 'E1', 'position': {'x': 0, 'y': 0, 'z': 5}}]
        
        # First frame
        frame1 = self.camera.render(entities, timestamp=1.0)
        self.assertIsNotNone(frame1)
        self.assertIsInstance(frame1, bytes)
        
        # Too soon
        frame2 = self.camera.render(entities, timestamp=1.01)
        self.assertIsNone(frame2)
        
        # Next frame due (approx 33ms later)
        frame3 = self.camera.render(entities, timestamp=1.04)
        self.assertIsNotNone(frame3)

if __name__ == '__main__':
    unittest.main()

```

#### simulation\tests\test_performance.py
```python
import time
import unittest
from src.core.orchestrator import SimulationOrchestrator

class TestPerformance(unittest.TestCase):
    def test_fps_stability(self):
        # This test ensures the loop runs at ~30 FPS
        # We'll just run a few iter and check time
        
        # Mock orchestrator behavior without threading for test
        orch = SimulationOrchestrator()
        
        start_time = time.time()
        frames = 30
        
        for i in range(frames):
            orch._generate_sensor_data()
            orch._detect_anomalies()
            time.sleep(1/30) # Simulate loop wait
            
        elapsed = time.time() - start_time
        fps = frames / elapsed
        
        print(f"Measured FPS: {fps}")
        self.assertTrue(25 < fps < 35, f"FPS {fps} out of range")

if __name__ == '__main__':
    unittest.main()

```

## 5. Frontend

#### frontend\Dockerfile
```
# Build Stage
FROM node:18-slim AS builder
WORKDIR /app
COPY package.json ./
RUN npm install
COPY . .
# Skip type check based on previous tsconfig relaxation, but run build
RUN npm run build

# Serve Stage
FROM node:18-slim
WORKDIR /app
RUN npm install -g serve
COPY --from=builder /app/dist ./dist
EXPOSE 80
CMD ["serve", "-s", "dist", "-l", "80"]

```

#### frontend\index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motion Intelligence Grid</title>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

#### frontend\package.json
```json
{
    "name": "motiongrid-frontend",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.1",
        "three": "^0.160.0",
        "@react-three/fiber": "^8.15.12",
        "@react-three/drei": "^9.92.4",
        "socket.io-client": "^4.6.2",
        "recharts": "^2.10.3",
        "axios": "^1.6.2",
        "date-fns": "^2.30.0",
        "zustand": "^4.4.7",
        "clsx": "^2.0.0",
        "tailwind-merge": "^2.1.0",
        "lucide-react": "^0.294.0",
        "class-variance-authority": "^0.7.0"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@types/three": "^0.160.0",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.3.6",
        "typescript": "^5.2.2",
        "vite": "^5.0.8"
    }
}
```

#### frontend\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "module": "ESNext",
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        /* Linting */
        "strict": false,
        "noImplicitAny": false,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": [
        "src"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
```

#### frontend\tsconfig.node.json
```json
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "vite.config.ts"
    ]
}
```

#### frontend\vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        host: true,
        allowedHosts: true, // Allow Cloud Run domains
        port: 5173,
        proxy: {
            '/api': {
                target: 'http://localhost:3001',
                changeOrigin: true
            }
        }
    }
})

```

#### frontend\src\App.tsx
```typescript
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AppShell } from './components/layout/AppShell';
import { AuthProvider, useAuth } from './context/AuthContext';
import { Login } from './views/Login';

import Dashboard from './views/Dashboard/Dashboard';
import SystemConfig from './views/SystemConfig/SystemConfig';

import { LiveMonitoring } from './views/LiveMonitoring/index';
import { SessionReplay } from './views/SessionReplay/SessionReplay';
import { AnalyticsDashboard } from './views/Analytics/AnalyticsDashboard';

import { PlaceholderView } from './components/common/PlaceholderView';

import { SessionsList } from './views/Sessions/SessionsList';
import { AnomalyTriage } from './views/Triage/AnomalyTriage';
import { EntityProfile } from './views/Entities/EntityProfile';
import { EntitiesList } from './views/Entities/EntitiesList';

const RequireAuth = ({ children }: { children: JSX.Element }) => {
    const { isAuthenticated } = useAuth();
    const location = useLocation();

    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }
    return children;
};

function App() {
    return (
        <AuthProvider>
            <Router>
                <Routes>
                    <Route path="/login" element={<Login />} />

                    <Route path="/*" element={
                        <RequireAuth>
                            <AppShell>
                                <Routes>
                                    <Route path="/" element={<Dashboard />} />
                                    <Route path="/live" element={<LiveMonitoring />} />
                                    <Route path="/replay/:id" element={<SessionReplay />} />
                                    <Route path="/analytics" element={<AnalyticsDashboard />} />
                                    <Route path="/config" element={<SystemConfig />} />

                                    {/* New Features - No Longer Placeholders */}
                                    <Route path="/sessions" element={<SessionsList />} />
                                    <Route path="/sessions/:id" element={<SessionReplay />} />
                                    <Route path="/triage" element={<AnomalyTriage />} />
                                    <Route path="/entities" element={<EntitiesList />} />
                                    <Route path="/entities/:id" element={<EntityProfile />} />

                                    <Route path="/automation" element={<PlaceholderView title="Automation Rules" />} />

                                    {/* Fallback */}
                                    <Route path="*" element={<PlaceholderView title="404: Page Not Found" description="The page you are looking for does not exist." />} />
                                </Routes>
                            </AppShell>
                        </RequireAuth>
                    } />
                </Routes>
            </Router>
        </AuthProvider>
    )
}

export default App

```

#### frontend\src\index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  background-color: #020617;
  /* navy-950 */
  color: #f8fafc;
  /* light text */
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
```

#### frontend\src\main.tsx
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

```

#### frontend\src\vite-env.d.ts
```typescript
/// <reference types="vite/client" />

```

#### frontend\src\components\common\PlaceholderView.tsx
```typescript
import React from 'react';
import { Construction } from 'lucide-react';
import { Card } from '../ui/Card';

interface PlaceholderViewProps {
    title: string;
    description?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
    title,
    description = "This feature is currently under development. Check back soon for updates."
}) => {
    return (
        <div className="p-6 h-full flex items-center justify-center">
            <Card className="max-w-md w-full p-8 text-center flex flex-col items-center gap-4 bg-navy-800 border-navy-700">
                <div className="w-16 h-16 bg-navy-900 rounded-full flex items-center justify-center border border-navy-700 shadow-inner">
                    <Construction className="w-8 h-8 text-primary-400" />
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white mb-2">{title}</h2>
                    <p className="text-slate-400 leading-relaxed">
                        {description}
                    </p>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\components\layout\AppShell.tsx
```typescript
import { Sidebar } from './Sidebar';
import { TopBar } from './TopBar';

interface AppShellProps {
    children: React.ReactNode;
}

export function AppShell({ children }: AppShellProps) {
    return (
        <div className="min-h-screen bg-navy-950 text-slate-200 font-sans selection:bg-secondary-500/30">
            <TopBar />
            <Sidebar />

            <main className="pl-[260px] pt-[80px] min-h-screen transition-all duration-300">
                <div className="max-w-[1920px] mx-auto p-6 animate-in fade-in duration-500 slide-in-from-bottom-4">
                    {children}
                </div>
            </main>
        </div>
    );
}

```

#### frontend\src\components\layout\Sidebar.tsx
```typescript
import {
    LayoutDashboard,
    Radio,
    Server,
    Settings,
    Bell,
    Search,
    Menu,
    Play,
    LayoutGrid,
    Activity,
    Video,
    BarChart3,
    Zap,
    AlertTriangle,
    Users,
    HelpCircle,
    LogOut
} from 'lucide-react';
import { NavLink } from 'react-router-dom';
import { cn } from '../../utils/cn';

const NAV_ITEMS = [
    { label: 'Overview', path: '/', icon: LayoutGrid },
    { label: 'Live Intelligence', path: '/live', icon: Activity },
    { label: 'Session Replay', path: '/replay/mock-session-1', icon: Play }, // Added for easy access
    { label: 'System Config', path: '/config', icon: Settings },
    { label: 'Sessions', path: '/sessions', icon: Video },
    { label: 'Analytics', path: '/analytics', icon: BarChart3 },
    { label: 'Automation', path: '/automation', icon: Zap },
    { label: 'Triage', path: '/triage', icon: AlertTriangle },
    { label: 'Entities', path: '/entities', icon: Users },
];

export function Sidebar() {
    return (
        <aside className="w-[260px] bg-navy-900 border-r border-navy-800 fixed left-0 top-0 bottom-0 pt-[80px] flex flex-col z-40">
            <div className="flex-1 overflow-y-auto py-6 px-3 space-y-1">
                <div className="text-xs font-bold text-slate-500 uppercase px-4 mb-2 tracking-wider">Menu</div>
                {NAV_ITEMS.map((item) => (
                    <NavLink
                        key={item.path}
                        to={item.path}
                        className={({ isActive }) => cn(
                            "flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200",
                            isActive
                                ? "bg-secondary-600/10 text-secondary-400 border border-secondary-600/20 shadow-[0_0_15px_rgba(99,102,241,0.1)]"
                                : "text-slate-400 hover:bg-navy-800 hover:text-slate-200"
                        )}
                    >
                        <item.icon className="w-5 h-5" />
                        {item.label}
                    </NavLink>
                ))}
            </div>

            <div className="p-4 border-t border-navy-800 space-y-1">
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-navy-800 hover:text-slate-200 transition-colors">
                    <HelpCircle className="w-5 h-5" />
                    Help & Docs
                </button>
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-red-900/20 hover:text-red-400 transition-colors">
                    <LogOut className="w-5 h-5" />
                    Logout
                </button>
            </div>
        </aside>
    );
}

```

#### frontend\src\components\layout\TopBar.tsx
```typescript
import { Bell, Settings, User, Search } from 'lucide-react';
import { Button } from '../ui/Button';

export function TopBar() {
    return (
        <header className="h-[80px] bg-navy-950 border-b border-navy-800 flex items-center justify-between px-6 fixed top-0 left-0 right-0 z-50">
            {/* Left: Logo & Context */}
            <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-lg flex items-center justify-center shadow-lg shadow-primary-500/20">
                        <svg className="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <span className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-400 to-secondary-400">
                        MotionGrid
                    </span>
                </div>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div className="flex items-center gap-2 text-slate-400 bg-navy-900 py-2 px-4 rounded-lg border border-navy-800">
                    <Search className="w-4 h-4" />
                    <span className="text-sm">Global Search...</span>
                </div>
            </div>

            {/* Right: Actions & Profile */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" className="relative" onClick={() => alert("Notifications coming soon!")}>
                    <Bell className="w-5 h-5 text-slate-400" />
                    <span className="absolute top-2 right-2 w-2 h-2 bg-status-critical rounded-full animate-pulse" />
                </Button>
                <Button variant="ghost" size="icon" onClick={() => alert("Settings panel coming soon!")}>
                    <Settings className="w-5 h-5 text-slate-400" />
                </Button>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div
                    className="flex items-center gap-3 pl-2 cursor-pointer hover:bg-navy-900 p-2 rounded-lg transition-colors"
                    onClick={() => alert("User profile management coming soon!")}
                >
                    <div className="text-right hidden md:block">
                        <div className="text-sm font-semibold text-white">Admin User</div>
                        <div className="text-xs text-primary-400">OPERATOR</div>
                    </div>
                    <div className="w-10 h-10 bg-navy-800 rounded-full flex items-center justify-center border border-navy-700">
                        <User className="w-5 h-5 text-slate-300" />
                    </div>
                </div>
            </div>
        </header>
    );
}

```

#### frontend\src\components\ui\Badge.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const badgeVariants = cva(
    "inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide transition-colors",
    {
        variants: {
            variant: {
                default: "bg-navy-700 text-white",
                critical: "bg-status-critical text-white shadow-[0_0_10px_rgba(220,38,38,0.4)]",
                high: "bg-status-high text-white",
                medium: "bg-status-medium text-white",
                low: "bg-status-low text-white",
                success: "bg-status-success text-white",
                outline: "border border-navy-700 text-slate-400 bg-transparent",
            },
            size: {
                sm: "text-[10px] px-2 py-0.5",
                md: "text-xs px-3 py-1",
                lg: "text-sm px-4 py-1.5",
            }
        },
        defaultVariants: {
            variant: "default",
            size: "md",
        }
    }
);

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof badgeVariants> { }

export function Badge({ className, variant, size, ...props }: BadgeProps) {
    return (
        <span className={badgeVariants({ variant, size, className })} {...props} />
    );
}

```

#### frontend\src\components\ui\Button.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';
import React from 'react';

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-lg text-sm font-semibold transition-all focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none active:scale-95",
    {
        variants: {
            variant: {
                primary: "bg-secondary-600 text-white hover:bg-secondary-500 shadow-lg shadow-secondary-900/20",
                secondary: "border border-navy-700 bg-transparent text-slate-300 hover:bg-navy-800",
                danger: "bg-status-critical text-white hover:bg-red-700",
                ghost: "bg-transparent text-slate-400 hover:text-white hover:bg-navy-800",
                icon: "p-2 bg-transparent text-slate-400 hover:bg-navy-800 hover:text-white rounded-md",
            },
            size: {
                sm: "px-3 py-1.5 text-xs",
                md: "px-4 py-2",
                lg: "px-6 py-3 text-base",
                icon: "h-9 w-9 p-0",
            },
            fullWidth: {
                true: "w-full",
            }
        },
        defaultVariants: {
            variant: "primary",
            size: "md",
            fullWidth: false,
        }
    }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, fullWidth, ...props }, ref) => {
        return (
            <button
                ref={ref}
                className={buttonVariants({ variant, size, fullWidth, className })}
                {...props}
            />
        );
    }
);
Button.displayName = "Button";

```

#### frontend\src\components\ui\Card.tsx
```typescript
import { cn } from '../../utils/cn';
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    hover?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
    ({ className, hover = true, children, ...props }, ref) => {
        return (
            <div
                ref={ref}
                className={cn(
                    "bg-navy-800 border border-navy-700 rounded-xl shadow-md p-5",
                    "transition-all duration-200 ease-out",
                    hover && "hover:-translate-y-0.5 hover:shadow-lg hover:shadow-black/20 hover:border-navy-600",
                    className
                )}
                {...props}
            >
                {children}
            </div>
        );
    }
);
Card.displayName = "Card";

export function CardHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("mb-4 flex items-center justify-between", className)} {...props}>
            {children}
        </div>
    );
}

export function CardTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
    return (
        <h3 className={cn("text-lg font-bold text-white", className)} {...props}>
            {children}
        </h3>
    );
}

export function CardContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("text-sm text-slate-300 leading-relaxed", className)} {...props}>
            {children}
        </div>
    );
}

```

#### frontend\src\context\AuthContext.tsx
```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import { api } from '../services/api';

interface User {
    id: string;
    email: string;
    role: string;
    username: string;
}

interface AuthContextType {
    user: User | null;
    token: string | null;
    login: (token: string, user: User) => void;
    logout: () => void;
    isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [token, setToken] = useState<string | null>(null);

    useEffect(() => {
        // Init from local storage
        const storedToken = localStorage.getItem('token');
        const storedUser = localStorage.getItem('user');

        if (storedToken && storedUser) {
            try {
                setToken(storedToken);
                setUser(JSON.parse(storedUser));
                // Set default header
                api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
            } catch (e) {
                console.error("Failed to parse stored user", e);
                localStorage.clear();
            }
        }
    }, []);

    const login = (newToken: string, newUser: User) => {
        setToken(newToken);
        setUser(newUser);
        localStorage.setItem('token', newToken);
        localStorage.setItem('user', JSON.stringify(newUser));
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
    };

    const logout = () => {
        setToken(null);
        setUser(null);
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        delete api.defaults.headers.common['Authorization'];
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout, isAuthenticated: !!token }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

```

#### frontend\src\services\api.ts
```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';

export const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

export const Api = {
    // Nodes
    getNodes: async () => (await api.get('/nodes')).data,
    getNode: async (id: string) => (await api.get(`/nodes/${id}`)).data,
    createNode: async (data: any) => (await api.post('/nodes', data)).data,
    updateNode: async (id: string, data: any) => (await api.patch(`/nodes/${id}`, data)).data,
    deleteNode: async (id: string) => (await api.delete(`/nodes/${id}`)).data,
    calibrateNode: async (id: string) => (await api.post(`/nodes/${id}/calibrate`)).data,

    // Sessions
    getSessions: async () => (await api.get('/sessions')).data,
    getSession: async (id: string) => (await api.get(`/sessions/${id}`)).data,
    createSession: async (data: any) => (await api.post('/sessions', data)).data,
    updateSession: async (id: string, data: any) => (await api.patch(`/sessions/${id}`, data)).data,
    deleteSession: async (id: string) => (await api.delete(`/sessions/${id}`)).data,
    startSession: async (id: string) => (await api.post(`/sessions/${id}/start`)).data,
    stopSession: async (id: string) => (await api.post(`/sessions/${id}/stop`)).data,

    // Simulation
    startSimulation: async (config: any) => (await api.post('/simulation/start', config)).data,
    stopSimulation: async () => (await api.post('/simulation/stop')).data,
    getSimulationStatus: async () => (await api.get('/simulation/status')).data,

    // Entities
    getEntities: async () => (await api.get('/entities')).data,

    // Analytics
    getStats: async () => (await api.get('/analytics/stats')).data
};

```

#### frontend\src\services\websocket.ts
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketService {
    private socket: Socket | null = null;
    private callbacks: Map<string, Function[]> = new Map();

    connect(url: string) {
        const token = localStorage.getItem('auth_token');
        this.socket = io(url, {
            transports: ['websocket'],
            reconnection: true,
            auth: { token }
        });

        this.socket.on('connect', () => {
            console.log('WebSocket connected');
            // Re-subscribe if we had active subscriptions? 
            // For now, simpler to leave it to the components.
        });

        this.socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        // Register for all expected events
        ['sensor:frame', 'anomaly:detected', 'entity:tracking', 'session:stats', 'node:status']
            .forEach(event => {
                this.socket!.on(event, (data: any) => {
                    const cbs = this.callbacks.get(event) || [];
                    cbs.forEach(cb => cb(data));
                });
            });
    }

    subscribeToSession(sessionId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:session', { sessionId });
    }

    subscribeToNode(nodeId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:node', { nodeId });
    }

    on(event: string, callback: Function) {
        if (!this.callbacks.has(event)) {
            this.callbacks.set(event, []);
        }
        this.callbacks.get(event)!.push(callback);
    }

    off(event: string, callback: Function) {
        if (!this.callbacks.has(event)) return;
        const cbs = this.callbacks.get(event) || [];
        this.callbacks.set(event, cbs.filter(cb => cb !== callback));
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
}

export const wsService = new WebSocketService();

```

#### frontend\src\utils\cn.ts
```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

```

#### frontend\src\views\Login.tsx
```typescript
import React, { useState } from 'react';
import { useAuth } from '../context/AuthContext';
import { api } from '../services/api';
import { useNavigate, useLocation } from 'react-router-dom';
import { KeyRound, Mail, User, Loader2 } from 'lucide-react';

export const Login: React.FC = () => {
    const { login } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    // Redirect to where they came from (or dashboard)
    const from = (location.state as any)?.from?.pathname || '/';

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            const response = await api.post('/auth/login', { email, password });
            const { token, user } = response.data;
            login(token, user);
            navigate(from, { replace: true });
        } catch (err: any) {
            console.error(err);
            setError(err.response?.data?.error || 'Login failed. Please check your credentials.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-slate-950 flex items-center justify-center p-4">
            <div className="bg-slate-900 border border-slate-800 rounded-xl max-w-md w-full p-8 shadow-2xl">
                <div className="text-center mb-8">
                    <div className="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-4 shadow-lg shadow-blue-900/50">
                        <KeyRound className="w-8 h-8 text-white" />
                    </div>
                    <h2 className="text-3xl font-bold text-white mb-2">Welcome Back</h2>
                    <p className="text-slate-400">Sign in to Motion Intelligence Grid</p>
                </div>

                {error && (
                    <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4 mb-6 text-red-500 text-sm">
                        {error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Email Address</label>
                        <div className="relative">
                            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="operator@motiongrid.com"
                            />
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Password</label>
                        <div className="relative">
                            <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="••••••••"
                            />
                        </div>
                    </div>

                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg transition shadow-lg shadow-blue-900/20 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                    >
                        {loading ? (
                            <>
                                <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                                Signing in...
                            </>
                        ) : (
                            'Sign In'
                        )}
                    </button>
                </form>

                <div className="mt-6 text-center text-sm text-slate-500">
                    <p>Default Admin: admin@freeforge.com / nimda</p>
                </div>
            </div>
        </div>
    );
};

```

#### frontend\src\views\Analytics\AnalyticsDashboard.tsx
```typescript
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';

export const AnalyticsDashboard = () => {
    return (
        <div className="p-6 space-y-6 text-white h-full overflow-y-auto">
            <h1 className="text-2xl font-bold mb-4">System Analytics</h1>

            {/* KPI Grid */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <KPICard title="Total Sessions" value="1,284" trend="+12%" />
                <KPICard title="Avg. Anomaly Rate" value="0.4/hr" trend="-5%" trendGood />
                <KPICard title="Active Nodes" value="24/24" trend="100%" />
                <KPICard title="Data Throughput" value="1.2 GB/s" trend="+8%" />
            </div>

            {/* Charts Section */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">Anomaly Distribution by Type</h3>
                    <div className="flex items-end justify-around h-60 gap-4 pb-2 border-b border-slate-700">
                        <Bar height="30%" label="Speed" color="bg-blue-500" />
                        <Bar height="60%" label="Crowd" color="bg-purple-500" />
                        <Bar height="15%" label="Zone" color="bg-yellow-500" />
                        <Bar height="45%" label="Formation" color="bg-green-500" />
                    </div>
                </Card>

                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">System Load (24h)</h3>
                    {/* Simple SVG Line Chart */}
                    <div className="h-60 w-full relative">
                        <svg className="w-full h-full overflow-visible">
                            <defs>
                                <linearGradient id="grad" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="#0ea5e9" stopOpacity="0.5" />
                                    <stop offset="100%" stopColor="#0ea5e9" stopOpacity="0" />
                                </linearGradient>
                            </defs>
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20 V150 H0 Z"
                                fill="url(#grad)"
                            />
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20"
                                fill="none"
                                stroke="#0ea5e9"
                                strokeWidth="3"
                            />
                        </svg>
                        <div className="absolute bottom-0 w-full text-xs text-slate-500 flex justify-between">
                            <span>00:00</span>
                            <span>06:00</span>
                            <span>12:00</span>
                            <span>18:00</span>
                            <span>24:00</span>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const KPICard = ({ title, value, trend, trendGood = false }: any) => (
    <Card className="p-4">
        <div className="text-slate-400 text-sm">{title}</div>
        <div className="text-2xl font-bold mt-1">{value}</div>
        <div className={`text-xs mt-2 ${trendGood || trend.startsWith('+') ? 'text-green-400' : 'text-slate-500'}`}>
            {trend} vs last week
        </div>
    </Card>
);

const Bar = ({ height, label, color }: any) => (
    <div className="flex flex-col items-center flex-1 h-full justify-end group">
        <div className={`w-full max-w-[40px] rounded-t-sm ${color} transition-all duration-500`} style={{ height }}></div>
        <div className="text-xs text-slate-400 mt-2">{label}</div>
    </div>
);

```

#### frontend\src\views\Dashboard\Dashboard.tsx
```typescript
import { AnomalyPanel } from './components/AnomalyPanel';
import { DashboardControls } from './components/DashboardControls';
import { StadiumMap } from './components/StadiumMap';
import { DashboardSparkline } from './components/DashboardSparkline';

const Dashboard = () => {
    return (
        <div className="space-y-6">
            <DashboardControls />

            <div className="flex flex-col lg:flex-row gap-6">
                {/* Main View: Stadium Map */}
                <div className="flex-1">
                    <StadiumMap />

                    {/* Bottom Sparkline */}
                    <div className="mt-6 h-[100px] bg-navy-900 border border-navy-800 rounded-xl relative overflow-hidden p-2">
                        <DashboardSparkline />
                    </div>
                </div>

                {/* Right Panel: Anomalies */}
                <AnomalyPanel />
            </div>
        </div>
    );
};

export default Dashboard;

```

#### frontend\src\views\Dashboard\components\AnomalyPanel.tsx
```typescript
import { Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { Badge } from '../../../components/ui/Badge';

const ANOMALIES = [
    { id: 1, time: '11:22', zone: 'Gate B', type: 'Crowd Compression', severity: 'critical', score: 87, delta: '+150%' },
    { id: 2, time: '11:20', zone: 'Concourse N', type: 'Rapid Movement', severity: 'high', score: 65, delta: '+80%' },
    { id: 3, time: '11:15', zone: 'Field', type: 'Unauthorized Access', severity: 'medium', score: 45, delta: 'N/A' },
    { id: 4, time: '11:10', zone: 'Gate A', type: 'Loitering', severity: 'low', score: 20, delta: '+15%' },
];

export function AnomalyPanel() {
    return (
        <div className="w-full lg:w-[360px] bg-navy-900 border border-navy-800 rounded-2xl flex flex-col h-[600px]">
            {/* Header */}
            <div className="p-4 border-b border-navy-800 flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-bold text-white">Active Anomalies</h3>
                    <div className="text-xs text-slate-400">23 Detected • <span className="text-status-critical">4 Critical</span></div>
                </div>
                <div className="flex gap-2">
                    <Button variant="ghost" size="icon"><Filter className="w-4 h-4" /></Button>
                    <Button variant="ghost" size="icon"><MoreHorizontal className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* List */}
            <div className="flex-1 overflow-y-auto p-3 space-y-3">
                {ANOMALIES.map((item) => (
                    <div
                        key={item.id}
                        className="group bg-navy-800 rounded-xl p-3 border border-navy-700 hover:border-indigo-500/50 hover:bg-navy-800/80 transition-all cursor-pointer relative overflow-hidden"
                    >
                        {/* Severity Indicator Bar */}
                        <div className={`absolute left-0 top-0 bottom-0 w-1 ${item.severity === 'critical' ? 'bg-status-critical' :
                            item.severity === 'high' ? 'bg-status-high' :
                                item.severity === 'medium' ? 'bg-status-medium' : 'bg-status-low'
                            }`} />

                        <div className="pl-3">
                            <div className="flex justify-between items-start mb-1">
                                <Badge variant={item.severity as any} size="sm">{item.severity}</Badge>
                                <span className="text-xs font-mono text-slate-500">{item.time}</span>
                            </div>

                            <h4 className="font-bold text-white text-sm mb-1 group-hover:text-indigo-300 transition-colors">{item.type}</h4>
                            <div className="flex justify-between items-center text-xs">
                                <span className="text-slate-400 uppercase tracking-wide font-semibold">{item.zone}</span>
                                <div className="flex gap-3 text-slate-500">
                                    <span>Risk: <span className={item.score > 80 ? 'text-red-400' : 'text-slate-300'}>{item.score}</span></span>
                                    <span>Δ: {item.delta}</span>
                                </div>
                            </div>
                        </div>

                        {/* Hover Actions Overlay (Simulated) */}
                        <div className="absolute right-2 bottom-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button size="sm" variant="secondary" className="h-7 text-xs px-2">View</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-navy-800 bg-navy-950/50 rounded-b-2xl">
                <Button variant="primary" fullWidth size="md">View All Anomalies</Button>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardControls.tsx
```typescript
import { Calendar, ChevronDown } from 'lucide-react';

export function DashboardControls() {
    return (
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6 bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
            {/* Event Selector */}
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-indigo-500/20 rounded-lg flex items-center justify-center text-indigo-400">
                    <Calendar className="w-5 h-5" />
                </div>
                <div>
                    <div className="text-xs text-slate-400 uppercase font-bold tracking-wide">Current Event</div>
                    <div className="flex items-center gap-2 text-white font-semibold cursor-pointer hover:text-indigo-400 transition-colors">
                        Match Day: Team A vs Team B
                        <ChevronDown className="w-4 h-4" />
                    </div>
                </div>
            </div>

            {/* Time Range Chips */}
            <div className="flex bg-navy-900 rounded-lg p-1 border border-navy-700">
                {['Now', 'Last 30m', 'Last 2h', '24h', 'Custom'].map((range, idx) => (
                    <button
                        key={range}
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${idx === 0
                            ? 'bg-secondary-600 text-white shadow-md'
                            : 'text-slate-400 hover:text-white hover:bg-navy-700'
                            }`}
                    >
                        {range}
                    </button>
                ))}
            </div>

            {/* System Status */}
            <div className="flex items-center gap-2 px-4 py-2 bg-status-success/10 border border-status-success/20 rounded-lg text-status-success">
                <span className="relative flex h-2.5 w-2.5">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
                </span>
                <span className="text-sm font-bold tracking-wide">SYSTEM OPTIMAL</span>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardSparkline.tsx
```typescript
import { Area, AreaChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts';

const generateMockData = () => {
    const data = [];
    for (let i = 0; i < 24; i++) {
        data.push({
            time: `${i}:00`,
            events: Math.floor(Math.random() * 50) + 10,
            anomalies: Math.floor(Math.random() * 5),
        });
    }
    return data;
};

const data = generateMockData();

export function DashboardSparkline() {
    return (
        <div className="w-full h-full">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={data}>
                    <defs>
                        <linearGradient id="colorEvents" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#818cf8" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#818cf8" stopOpacity={0} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis hide />
                    <Tooltip
                        contentStyle={{ backgroundColor: '#1e293b', borderColor: '#334155', color: '#f8fafc' }}
                        itemStyle={{ color: '#818cf8' }}
                        labelStyle={{ color: '#94a3b8' }}
                    />
                    <Area
                        type="monotone"
                        dataKey="events"
                        stroke="#818cf8"
                        fillOpacity={1}
                        fill="url(#colorEvents)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\StadiumMap.tsx
```typescript
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ZONES = [
    { id: 'gate-a', name: 'GATE A', type: 'GATE', status: 'critical', x: '10%', y: '20%' },
    { id: 'gate-b', name: 'GATE B', type: 'GATE', status: 'normal', x: '80%', y: '20%' },
    { id: 'field', name: 'FIELD', type: 'FIELD', status: 'normal', x: '45%', y: '45%' },
    { id: 'concourse-n', name: 'CONCOURSE N', type: 'CONCOURSE', status: 'high', x: '45%', y: '10%' },
    { id: 'concourse-s', name: 'CONCOURSE S', type: 'CONCOURSE', status: 'normal', x: '45%', y: '80%' },
];

export function StadiumMap() {
    return (
        <div className="relative w-full h-[600px] bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden shadow-inner">
            {/* Grid Pattern Background */}
            <div className="absolute inset-0 opacity-10"
                style={{ backgroundImage: 'radial-gradient(circle, #334155 1px, transparent 1px)', backgroundSize: '30px 30px' }}
            />

            {/* Stadium Visual Placeholder - Simple SVG representation */}
            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 600">
                {/* Field */}
                <rect x="250" y="150" width="500" height="300" rx="40" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <circle cx="500" cy="300" r="50" fill="none" stroke="#334155" strokeWidth="2" />
                <line x1="500" y1="150" x2="500" y2="450" stroke="#334155" strokeWidth="2" />

                {/* Zones Outline */}
                <path d="M 150 100 Q 500 0 850 100 L 900 250 L 850 500 Q 500 600 150 500 L 100 250 Z"
                    fill="none" stroke="#4f46e5" strokeWidth="2" strokeDasharray="10 5" opacity="0.3" />
            </svg>

            {/* Zone Cards Overlay */}
            {ZONES.map((zone) => (
                <div
                    key={zone.id}
                    className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer transition-transform hover:scale-105 hover:z-10"
                    style={{ left: zone.x, top: zone.y }}
                >
                    <Card className={`w-48 p-3 bg-navy-800/90 backdrop-blur-sm border-l-4 ${zone.status === 'critical' ? 'border-l-status-critical shadow-[0_0_20px_rgba(220,38,38,0.2)]' :
                            zone.status === 'high' ? 'border-l-status-high' :
                                'border-l-status-success'
                        }`}>
                        <div className="flex justify-between items-start mb-2">
                            <span className="text-xs font-bold text-slate-300 tracking-wider">{zone.name}</span>
                            <Badge variant={zone.status as any} size="sm">{zone.status}</Badge>
                        </div>
                        <div className="space-y-1">
                            <div className="text-xs text-slate-400">Last event: 2m ago</div>
                            <div className="text-xs text-slate-400">Anomalies: <span className="text-white font-mono">3</span></div>
                        </div>
                    </Card>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\Entities\EntitiesList.tsx
```typescript

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Search, Filter, Eye } from 'lucide-react';
import { api } from '../../services/api';

interface Entity {
    id: string;
    type: string;
    role?: string;
    team?: string;
    lastSeen: number;
    status: 'ACTIVE' | 'INACTIVE';
}

export const EntitiesList = () => {
    const navigate = useNavigate();
    const [entities, setEntities] = useState<Entity[]>([]);
    const [search, setSearch] = useState('');

    useEffect(() => {
        const fetchEntities = async () => {
            try {
                // Mock endpoint or real if available
                const data = await api.get('/entities');
                if (Array.isArray(data)) setEntities(data);
            } catch (err) {
                // Determine mock data if API fails (for demo robustness)
                setEntities([
                    { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'HOME_PLAYER_2', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'REF_1', type: 'PERSON', role: 'REFEREE', team: 'NEUTRAL', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'BALL', type: 'OBJECT', role: 'game_ball', lastSeen: Date.now(), status: 'ACTIVE' },
                ]);
            }
        }
        fetchEntities();
    }, []);

    const filtered = entities.filter(e => e.id.toLowerCase().includes(search.toLowerCase()));

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Entity Directory</h1>
                <div className="flex gap-2">
                    <div className="relative">
                        <Search className="absolute left-3 top-2.5 w-4 h-4 text-slate-400" />
                        <input
                            type="text"
                            placeholder="Search entities..."
                            className="bg-slate-900 border border-slate-700 rounded-md pl-9 pr-4 py-2 text-sm focus:outline-none focus:border-blue-500 w-64"
                            value={search}
                            onChange={(e) => setSearch(e.target.value)}
                        />
                    </div>
                    <Button variant="outline"><Filter className="w-4 h-4 mr-2" /> Filter</Button>
                </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filtered.map(entity => (
                    <Card key={entity.id} className="hover:border-blue-500/50 transition-colors cursor-pointer" onClick={() => navigate(`/entities/${entity.id}`)}>
                        <div className="flex justify-between items-start mb-4">
                            <Badge variant={entity.team === 'HOME' ? 'critical' : entity.team === 'AWAY' ? 'primary' : 'outline'}>
                                {entity.role || entity.type}
                            </Badge>
                            <div className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]" />
                        </div>
                        <h3 className="text-lg font-bold mb-1">{entity.id}</h3>
                        <div className="text-slate-400 text-sm mb-4">
                            Last seen: {new Date(entity.lastSeen).toLocaleTimeString()}
                        </div>
                        <div className="flex justify-end">
                            <Button variant="ghost" size="sm">
                                <Eye className="w-4 h-4 mr-2" /> View Profile
                            </Button>
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\Entities\EntityProfile.tsx
```typescript
import { useParams, useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { ArrowLeft, Activity, Shield, MapPin } from 'lucide-react';

export const EntityProfile = () => {
    const { id } = useParams();
    const navigate = useNavigate();

    return (
        <div className="p-6 text-white max-w-5xl mx-auto">
            <Button variant="ghost" size="sm" onClick={() => navigate(-1)} className="mb-4">
                <ArrowLeft className="w-4 h-4 mr-2" /> Back
            </Button>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Profile Header */}
                <Card className="md:col-span-3 p-6 flex items-center gap-6">
                    <div className="w-24 h-24 rounded-full bg-slate-800 flex items-center justify-center text-3xl font-bold text-blue-400">
                        {id?.substring(0, 2).toUpperCase() || 'E'}
                    </div>
                    <div>
                        <h1 className="text-3xl font-bold">{id || 'Unknown Entity'}</h1>
                        <div className="text-slate-400 flex gap-4 mt-2">
                            <span className="flex items-center gap-1"><Shield className="w-4 h-4" /> Security Staff</span>
                            <span className="flex items-center gap-1"><MapPin className="w-4 h-4" /> Zone B</span>
                            <span className="flex items-center gap-1 text-green-400"><Activity className="w-4 h-4" /> Active</span>
                        </div>
                    </div>
                </Card>

                {/* Stats */}
                <Card className="p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Movement Stats</h3>
                    <div className="space-y-4">
                        <Stat label="Avg Speed" value="1.4 m/s" />
                        <Stat label="Distance" value="4.2 km" />
                        <Stat label="Zone Violations" value="0" />
                    </div>
                </Card>

                {/* Recent Activity */}
                <Card className="md:col-span-2 p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Recent Activity Timeline</h3>
                    <div className="space-y-4">
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:45</div>
                            <div>Entered Zone B (North Gate)</div>
                        </div>
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:30</div>
                            <div>Shift Started</div>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const Stat = ({ label, value }: any) => (
    <div className="flex justify-between items-center border-b border-slate-800 pb-2">
        <span className="text-slate-400 text-sm">{label}</span>
        <span className="font-mono">{value}</span>
    </div>
);

```

#### frontend\src\views\LiveMonitoring\AlertPanel.tsx
```typescript
import { useEffect, useState } from 'react';
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';
import { wsService } from '../../services/websocket';

interface Anomaly {
    id: string;
    headline: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    time: string;
}

export const AlertPanel = () => {
    const [alerts, setAlerts] = useState<Anomaly[]>([]);

    useEffect(() => {
        // Connect if not already (MeshView also connects, but idempotent)
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            console.log('Anomaly received:', data);

            // Map Python payload to frontend model
            // Python sends: { anomalyId, headline, severity, occurredAt, ... }
            const newAlert: Anomaly = {
                id: data.anomalyId || 'unknown',
                headline: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                // occurredAt is ISO string now
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };

            setAlerts(prev => [newAlert, ...prev].slice(0, 50)); // Keep last 50
        });

        return () => {
            // Unsubscribe logic if wsService supports it, or just let it exist
        };
    }, []);

    return (
        <div className="bg-gray-800 border-l border-gray-700 w-80 flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-red-400" />
                    Active Alerts
                </h3>
            </div>

            <div className="flex-1 overflow-auto p-4 space-y-3">
                {alerts.length === 0 && (
                    <div className="text-gray-500 text-center text-sm py-8">
                        No active alerts.
                    </div>
                )}
                {alerts.map(alert => (
                    <div key={alert.id} className="bg-gray-700/50 rounded-lg p-3 border border-gray-600 hover:border-gray-500 transition-colors">
                        <div className="flex justify-between items-start mb-2">
                            <span className={`text-xs font-bold px-1.5 py-0.5 rounded ${alert.severity === 'CRITICAL' ? 'bg-red-500/20 text-red-300' :
                                alert.severity === 'HIGH' ? 'bg-orange-500/20 text-orange-300' : 'bg-blue-500/20 text-blue-300'
                                }`}>
                                {alert.severity}
                            </span>
                            <span className="text-xs text-gray-400">{alert.time}</span>
                        </div>
                        <h4 className="text-sm font-medium mb-2">{alert.headline}</h4>

                        {/* Triage Actions */}
                        <div className="flex gap-2 mt-2">
                            <button className="flex-1 flex items-center justify-center gap-1 bg-green-900/30 hover:bg-green-900/50 text-green-300 py-1 rounded text-xs transition-colors">
                                <CheckCircle className="h-3 w-3" /> Confirm
                            </button>
                            <button className="flex-1 flex items-center justify-center gap-1 bg-gray-600/30 hover:bg-gray-600/50 text-gray-300 py-1 rounded text-xs transition-colors">
                                <XCircle className="h-3 w-3" /> Dismiss
                            </button>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\CameraGrid.tsx
```typescript

import { useEffect, useState } from 'react';
import { Camera } from 'lucide-react';
import { VideoPlaceholder } from './components/VideoPlaceholder';
import { Api } from '../../../services/api';

interface CameraNode {
    id: string; // real ID (uuid)
    nodeId: string; // human readable (CAM_01)
    status: string;
}

export const CameraGrid = () => {
    const [cameras, setCameras] = useState<CameraNode[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                // Map backend nodes to camera view
                // Backend node has: nodeId (string), id (uuid), config...
                const mapped = data.nodes.map((n: any) => ({
                    id: n._id,
                    nodeId: n.nodeId,
                    status: 'ONLINE' // Assume online if fetched for now
                }));

                if (mapped.length > 0) {
                    setCameras(mapped);
                } else {
                    // Fallback to placeholders if no real nodes found (for demo preservation)
                    setCameras([
                        { id: 'mock1', nodeId: 'CAM_01 (Sim)', status: 'ONLINE' },
                        { id: 'mock2', nodeId: 'CAM_02 (Sim)', status: 'ONLINE' },
                    ]);
                }
            } catch (e) {
                console.error("Failed to fetch camera nodes", e);
                // Fallback
                setCameras([
                    { id: 'mock1', nodeId: 'CAM_01 (Offline)', status: 'OFFLINE' },
                    { id: 'mock2', nodeId: 'CAM_02 (Offline)', status: 'OFFLINE' },
                ]);
            } finally {
                setLoading(false);
            }
        };

        fetchNodes();
    }, []);

    if (loading) {
        return <div className="text-white text-center p-4">Loading streams...</div>;
    }

    return (
        <div className="grid grid-cols-2 gap-2 h-full">
            {cameras.map(cam => (
                <div key={cam.id} className="relative bg-black rounded overflow-hidden group">
                    <div className="absolute inset-0 flex items-center justify-center text-gray-700">
                        {cam.status === 'ONLINE' ? (
                            <div className="flex-1 bg-black relative w-full h-full">
                                {/* Pass nodeId only if it's not a mock ID, or handle mock logic inside VideoPlaceholder? 
                                    Actually, if we want real stream, we need real nodeId (CAM_01 etc from sim).
                                    If mapped from real API, cam.nodeId is what we want.
                                */}
                                <VideoPlaceholder
                                    label={cam.nodeId}
                                    // Use cam.nodeId as endpoint parameter. 
                                    // If it's a mock fallback, this might fail to stream (404) and component will fallback to noise.
                                    nodeId={cam.nodeId}
                                />
                            </div>) : (
                            <div className="flex flex-col items-center">
                                <Camera className="h-8 w-8 mb-2 opacity-50" />
                                <span className="text-xs">OFFLINE</span>
                            </div>
                        )}
                    </div>

                    {/* Overlay */}
                    <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white backdrop-blur-sm">
                        {cam.nodeId}
                    </div>
                    <div className={`absolute top-2 right-2 w-2 h-2 rounded-full ${cam.status === 'ONLINE' ? 'bg-green-500' : 'bg-red-500'}`} />
                </div>
            ))}
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\index.tsx
```typescript
import { useEffect } from 'react';
import { MeshView3D } from './MeshView3D';
import { LayerControls } from './components/LayerControls';
import { LiveAlerts } from './components/LiveAlerts';
import { CameraStrip } from './components/CameraStrip';
import { wsService } from '../../services/websocket';
import { Button } from '../../components/ui/Button';
import { Pause, RefreshCw } from 'lucide-react';

export const LiveMonitoring = () => {
    useEffect(() => {
        const wsUrl = (import.meta as any).env?.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app';
        wsService.connect(wsUrl);
    }, []);

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] gap-4">
            {/* Top Controls */}
            <div className="flex items-center justify-between pb-2 border-b border-navy-800">
                <div className="flex gap-4 items-center">
                    <h2 className="text-lg font-bold text-white">Zone A: Main Concourse</h2>
                    <div className="flex gap-1">
                        <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span className="text-xs text-green-400 font-mono">LIVE FEED</span>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="icon" variant="ghost"><RefreshCw className="w-4 h-4" /></Button>
                    <Button size="icon" variant="secondary"><Pause className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* Main Content Area */}
            <div className="flex flex-1 gap-4 overflow-hidden">
                {/* Left: Layers */}
                <div className="flex-shrink-0">
                    <LayerControls />
                </div>

                {/* Center: 3D View */}
                <div className="flex-1 bg-black rounded-2xl border border-navy-800 relative overflow-hidden group">
                    <MeshView3D />

                    {/* Camera Strip Overlay */}
                    <div className="translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                        <CameraStrip />
                    </div>
                </div>

                {/* Right: Alerts */}
                <div className="flex-shrink-0">
                    <LiveAlerts />
                </div>
            </div>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\MeshView3D.tsx
```typescript
import { useEffect, useState, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text, Html } from '@react-three/drei';
import * as THREE from 'three';
import { wsService } from '../../services/websocket';

interface Entity {
    id: string;
    type: string;
    position: { x: number; y: number; z: number };
    velocity: { x: number; y: number; z: number };
    radius?: number;
    color?: number[];
    severity?: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
}

const EntityMesh = ({ entity }: { entity: Entity }) => {
    // Convert array color or hex to THREE.Color
    const color = useMemo(() => {
        if (Array.isArray(entity.color)) {
            return new THREE.Color(entity.color[0] / 255, entity.color[1] / 255, entity.color[2] / 255);
        }
        return new THREE.Color(entity.color || 'white');
    }, [entity.color]);

    const VelocityArrow = ({ velocity }: { velocity: { x: number; y: number; z: number } }) => {
        const length = Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);
        if (length < 0.1) return null;
        // Normalize direction
        const dir = new THREE.Vector3(velocity.x, velocity.y, velocity.z).normalize();
        return (
            <arrowHelper args={[dir, new THREE.Vector3(0, 0, 0), Math.min(length, 2), 0xffff00]} />
        );
    };

    const RiskHalo = ({ severity }: { severity?: string }) => {
        if (!severity || severity === 'LOW') return null;
        const color = severity === 'CRITICAL' ? 'red' : severity === 'HIGH' ? 'orange' : 'yellow';
        return (
            <mesh position={[0, -0.9, 0]} rotation={[0, 0, 0]}>
                <ringGeometry args={[0.5, 0.7, 32]} />
                <meshBasicMaterial color={color} transparent opacity={0.5} side={THREE.DoubleSide} />
            </mesh>
        );
    };

    return (
        <group position={[entity.position.x, entity.position.y, entity.position.z]}>
            {/* Entity Body */}
            <mesh castShadow receiveShadow>
                <capsuleGeometry args={[entity.radius || 0.3, 1.8, 4, 8]} />
                <meshStandardMaterial color={color} roughness={0.3} metalness={0.1} />
            </mesh>

            <RiskHalo severity={entity.severity} />
            <VelocityArrow velocity={entity.velocity} />

            {/* ID Tag */}
            <Html position={[0, 2.2, 0]} center distanceFactor={15}>
                <div className={`text-[10px] px-1.5 py-0.5 rounded backdrop-blur-md whitespace-nowrap border font-mono
                    ${entity.severity === 'CRITICAL' ? 'bg-red-500/20 border-red-500 text-red-200' :
                        entity.severity === 'HIGH' ? 'bg-orange-500/20 border-orange-500 text-orange-200' :
                            'bg-slate-900/60 border-slate-700 text-slate-300'}`}>
                    {entity.id}
                </div>
            </Html>
        </group>
    );
};

const Floor = () => {
    return (
        <mesh receiveShadow rotation={[0, 0, 0]} position={[0, 0, -0.01]}>
            <planeGeometry args={[100, 100]} />
            <meshStandardMaterial color="#0f172a" roughness={0.8} metalness={0.2} />
            <gridHelper args={[100, 50, 0x334155, 0x1e293b]} rotation={[Math.PI / 2, 0, 0]} />
        </mesh>
    );
};

export const MeshView3D = () => {
    const [entities, setEntities] = useState<Entity[]>([]);
    const [stats, setStats] = useState({ fps: 0, frame: 0, time: 0 });

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');
        const unsubscribe = wsService.on('entity:tracking', (data: { entities: Entity[], stats?: any }) => {
            if (data && data.entities) setEntities(data.entities);
            if (data && data.stats) setStats(data.stats);
        });
        return () => { }; // Connection managed globally or by context in real app
    }, []);

    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden border border-slate-800 relative shadow-inner">
            <div className="absolute top-4 left-4 z-10 space-y-2">
                <div className="bg-slate-900/90 p-3 rounded-lg border border-slate-800 text-xs text-slate-300 backdrop-blur shadow-lg space-y-2">
                    <div className="font-bold text-slate-100 mb-1 border-b border-slate-700 pb-1">Live Telemetry</div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Entities</span>
                        <span className="font-mono text-white text-right">{entities.length}</span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sim FPS</span>
                        <span className={`font-mono text-right ${stats.fps < 25 ? 'text-yellow-400' : 'text-green-400'}`}>
                            {stats.fps.toFixed(1)}
                        </span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sync</span>
                        <div className="flex items-center gap-1.5 justify-end">
                            <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" />
                            <span className="font-mono text-white">ACTIVE</span>
                        </div>
                    </div>
                </div>
            </div>

            <Canvas shadows camera={{ position: [0, -30, 20], fov: 50, up: [0, 0, 1] }}>
                <color attach="background" args={['#020617']} />
                <fog attach="fog" args={['#020617', 20, 90]} />

                <ambientLight intensity={0.4} />
                <directionalLight
                    position={[10, -20, 20]}
                    intensity={1.2}
                    castShadow
                    shadow-mapSize={[1024, 1024]}
                />
                <pointLight position={[-10, 10, 5]} intensity={0.5} color="#3b82f6" />

                <OrbitControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2.1} />

                <Floor />
                <axesHelper args={[2]} position={[0, 0, 0.1]} />

                {entities.map(e => (
                    <EntityMesh key={e.id} entity={e} />
                ))}
            </Canvas>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\components\CameraStrip.tsx
```typescript
export function CameraStrip() {
    return (
        <div className="absolute bottom-4 left-4 right-4 flex gap-4 overflow-x-auto pb-2 scrollbar-hide">
            {[1, 2, 3, 4, 5].map(cam => (
                <div key={cam} className="w-40 h-24 bg-black rounded-lg border border-navy-700 relative flex-shrink-0 group cursor-pointer hover:border-indigo-500 transition-colors">
                    <div className="absolute top-1 left-1 bg-black/50 px-1 rounded text-[10px] text-slate-300">CAM-0{cam}</div>
                    <div className="w-full h-full flex items-center justify-center text-slate-700 text-xs">NO SIGNAL</div>
                    <div className="absolute top-1 right-1 h-2 w-2 bg-green-500 rounded-full shadow-[0_0_5px_rgba(34,197,94,0.5)]"></div>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LayerControls.tsx
```typescript
import { Layers, Eye, Activity, Map, Users, Zap } from 'lucide-react';
import { Card } from '../../../components/ui/Card';

const LAYERS = [
    { id: 'entities', label: 'Entities', icon: Users, default: true },
    { id: 'risk', label: 'Risk Halos', icon: Zap, default: true },
    { id: 'velocity', label: 'Velocity Vectors', icon: Activity, default: false },
    { id: 'trails', label: 'Path Trails', icon: Map, default: false },
    { id: 'social', label: 'Social Radar', icon: Users, default: false },
    { id: 'terrain', label: 'Behavior Terrain', icon: Layers, default: true },
];

export function LayerControls() {
    return (
        <Card className="w-64 bg-navy-900 border-navy-800 flex flex-col gap-4 h-full">
            <div className="flex items-center gap-2 mb-2 pb-2 border-b border-navy-800">
                <Layers className="w-4 h-4 text-indigo-400" />
                <h3 className="font-bold text-white text-sm">View Layers</h3>
            </div>

            <div className="space-y-3">
                {LAYERS.map(layer => (
                    <label key={layer.id} className="flex items-center justify-between group cursor-pointer">
                        <div className="flex items-center gap-3 text-slate-300 group-hover:text-white transition-colors">
                            <layer.icon className="w-4 h-4 text-slate-500 group-hover:text-indigo-400" />
                            <span className="text-sm font-medium">{layer.label}</span>
                        </div>
                        <div className="relative inline-block w-8 h-4 rounded-full cursor-pointer">
                            <input type="checkbox" className="sr-only peer" defaultChecked={layer.default} />
                            <div className="w-8 h-4 bg-navy-800 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-indigo-600"></div>
                        </div>
                    </label>
                ))}
            </div>

            <div className="mt-auto pt-4 border-t border-navy-800">
                <div className="text-xs text-slate-500 mb-2 uppercase font-bold">Camera Overlay</div>
                <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <Eye className="w-4 h-4" /> Show FOV Cones
                    <input type="checkbox" className="ml-auto accent-indigo-500" defaultChecked />
                </label>
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LiveAlerts.tsx
```typescript
import { AlertTriangle, Clock } from 'lucide-react';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ALERTS = [
    { id: 1, type: 'Crowd Crush', risk: 92, time: '10s ago', zone: 'Gate B' },
    { id: 2, type: 'Fight Precursor', risk: 78, time: '32s ago', zone: 'Concourse' },
    { id: 3, type: 'Fallen Object', risk: 45, time: '1m ago', zone: 'Aisle 12' },
];

export function LiveAlerts() {
    return (
        <Card className="w-80 bg-navy-900 border-navy-800 flex flex-col h-full">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-navy-800">
                <div className="flex items-center gap-2">
                    <AlertTriangle className="w-4 h-4 text-status-critical" />
                    <h3 className="font-bold text-white text-sm">Live Alerts</h3>
                </div>
                <Badge variant="critical">3 Active</Badge>
            </div>

            <div className="flex-1 overflow-y-auto space-y-3">
                {ALERTS.map(alert => (
                    <div key={alert.id} className="bg-navy-800 p-3 rounded-lg border border-navy-700 hover:border-red-500/50 transition-colors cursor-pointer group">
                        <div className="flex justify-between items-start mb-1">
                            <span className="text-xs font-bold text-red-300">{alert.type}</span>
                            <span className="text-[10px] text-slate-500 flex items-center gap-1">
                                <Clock className="w-3 h-3" /> {alert.time}
                            </span>
                        </div>
                        <div className="flex justify-between items-end">
                            <div className="text-xs text-slate-400">{alert.zone}</div>
                            <div className="text-sm font-mono font-bold text-white">
                                {alert.risk}% <span className="text-xs font-sans font-normal text-slate-500">Risk</span>
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\VideoPlaceholder.tsx
```typescript
import { useEffect, useRef, useState } from 'react';
import { api } from '../../../services/api';

export function VideoPlaceholder({ label, nodeId }: { label: string, nodeId?: string }) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [useStream, setUseStream] = useState(!!nodeId);
    const [imgError, setImgError] = useState(false);

    // Construct stream URL
    // We need to access the baseURL from axios instance or env
    const baseURL = api.defaults.baseURL || import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';
    const token = localStorage.getItem('auth_token');
    const streamUrl = nodeId ? `${baseURL}/nodes/${nodeId}/stream?token=${token}` : '';

    useEffect(() => {
        if (useStream && !imgError && nodeId) return; // If using stream, don't run canvas animation

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId: number;
        let time = 0;

        const draw = () => {
            time += 0.05;
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a'; // bg-slate-900
            ctx.fillRect(0, 0, width, height);

            // Digital Noise / Scanlines
            for (let i = 0; i < height; i += 4) {
                ctx.fillStyle = `rgba(30, 41, 59, ${Math.random() * 0.5})`;
                ctx.fillRect(0, i, width, 1);
            }

            // Moving "Entities" (Simple Blobs)
            const x = (Math.sin(time) * 0.4 + 0.5) * width;
            const y = (Math.cos(time * 0.7) * 0.4 + 0.5) * height;

            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(79, 70, 229, 0.4)'; // Indigo
            ctx.fill();

            // Overlay Text
            ctx.font = '12px monospace';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('REC', width - 40, 20);
            ctx.fillText(new Date().toLocaleTimeString(), 10, height - 10);
            ctx.fillText(label, 10, 20);

            if (imgError) {
                ctx.fillStyle = '#ef4444';
                ctx.fillText('SIGNAL LOST', width / 2 - 30, height / 2);
            }

            // Recording Dot
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(width - 50, 15, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }

            animationFrameId = window.requestAnimationFrame(draw);
        };

        const resize = () => {
            if (canvas?.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        };

        window.addEventListener('resize', resize);
        resize(); // Initial resize
        draw();

        return () => {
            window.removeEventListener('resize', resize);
            window.cancelAnimationFrame(animationFrameId);
        };
    }, [label, useStream, imgError, nodeId]);

    if (useStream && !imgError && nodeId) {
        return (
            <div className="relative w-full h-full bg-black">
                <img
                    src={streamUrl}
                    alt={label}
                    className="w-full h-full object-cover"
                    onError={() => setImgError(true)}
                />
                {/* Overlay Text for Stream too */}
                <div className="absolute top-0 left-0 p-2 text-xs font-mono text-green-500 w-full flex justify-between">
                    <span>{label}</span>
                    <span>LIVE</span>
                </div>
            </div>
        );
    }

    return (
        <canvas ref={canvasRef} className="w-full h-full block" />
    );
}

```

#### frontend\src\views\SessionReplay\SessionReplay.tsx
```typescript
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button } from '../../components/ui/Button';
import { Card } from '../../components/ui/Card';
import { Play, Pause, SkipBack, SkipForward, ArrowLeft } from 'lucide-react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';

interface SessionData {
    id: string;
    name: string;
    sport: string;
    startTime: string;
    duration: number;
    status: string;
}

export const SessionReplay = () => {
    const { id } = useParams();
    const navigate = useNavigate();
    const [session, setSession] = useState<SessionData | null>(null);
    const [currentTime, setCurrentTime] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const playbackRef = useRef<number>();

    // Mock fetch session details
    useEffect(() => {
        // In real app: fetch(`/api/sessions/${id}`)
        setSession({
            id: id || '1',
            name: 'Championship Final Game 3',
            sport: 'BASKETBALL',
            startTime: new Date().toISOString(),
            duration: 1200, // 20 mins
            status: 'COMPLETED'
        });
    }, [id]);

    // Playback loop
    useEffect(() => {
        if (isPlaying) {
            playbackRef.current = window.setInterval(() => {
                setCurrentTime(prev => {
                    if (prev >= (session?.duration || 0)) {
                        setIsPlaying(false);
                        return prev;
                    }
                    return prev + 1;
                });
            }, 1000); // 1x Speed
        } else {
            clearInterval(playbackRef.current);
        }
        return () => clearInterval(playbackRef.current);
    }, [isPlaying, session]);

    const formatTime = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    return (
        <div className="flex flex-col h-full gap-4 p-4 text-white">
            {/* Header */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="sm" onClick={() => navigate('/sessions')}>
                    <ArrowLeft className="w-4 h-4 mr-2" /> Back
                </Button>
                <div>
                    <h1 className="text-xl font-bold">{session?.name || 'Loading...'}</h1>
                    <div className="text-sm text-slate-400">
                        {session?.sport} • {new Date(session?.startTime || '').toLocaleDateString()}
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 flex gap-4 min-h-0">
                {/* 3D Replay Viewport */}
                <div className="flex-1 bg-slate-950 rounded-xl overflow-hidden relative border border-slate-800">
                    <div className="absolute top-4 left-4 z-10 bg-black/50 px-2 py-1 rounded text-xs">
                        REPLAY MODE
                    </div>
                    <Canvas camera={{ position: [0, -40, 30] }}>
                        <ambientLight intensity={0.5} />
                        <gridHelper args={[100, 100, 0x334155, 0x0f172a]} rotation={[Math.PI / 2, 0, 0]} />
                        <OrbitControls />
                        {/* Placeholder for entities at currentTime */}
                        <mesh position={[Math.sin(currentTime * 0.1) * 5, Math.cos(currentTime * 0.1) * 5, 1]}>
                            <sphereGeometry args={[0.5]} />
                            <meshStandardMaterial color="orange" />
                        </mesh>
                    </Canvas>
                </div>

                {/* Sidebar Stats */}
                <div className="w-80 flex flex-col gap-4">
                    <Card className="flex-1">
                        <div className="p-4">
                            <h3 className="font-semibold mb-4">Events Log</h3>
                            <div className="space-y-2 text-sm text-slate-400">
                                <div className="flex justify-between">
                                    <span>Sync Start</span>
                                    <span>0:00</span>
                                </div>
                                <div className="flex justify-between text-yellow-400">
                                    <span>Anomaly Detected</span>
                                    <span>0:45</span>
                                </div>
                                <div className="flex justify-between text-red-400">
                                    <span>Speed Violation</span>
                                    <span>1:20</span>
                                </div>
                            </div>
                        </div>
                    </Card>
                </div>
            </div>

            {/* Controls Bar */}
            <Card className="p-4 bg-slate-900 border-t border-slate-800">
                <div className="flex flex-col gap-2">
                    {/* Scrubber */}
                    <div className="flex items-center gap-4 text-xs text-slate-400">
                        <span className="w-12 text-right">{formatTime(currentTime)}</span>
                        <input
                            type="range"
                            min="0"
                            max={session?.duration || 100}
                            value={currentTime}
                            onChange={(e) => setCurrentTime(Number(e.target.value))}
                            className="flex-1 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="w-12">{formatTime(session?.duration || 0)}</span>
                    </div>

                    {/* Buttons */}
                    <div className="flex items-center justify-center gap-4">
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.max(0, currentTime - 10))}>
                            <SkipBack className="w-5 h-5" />
                        </Button>
                        <Button
                            variant="primary"
                            size="icon"
                            className="w-12 h-12 rounded-full"
                            onClick={() => setIsPlaying(!isPlaying)}
                        >
                            {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6 ml-1" />}
                        </Button>
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.min(session?.duration || 0, currentTime + 10))}>
                            <SkipForward className="w-5 h-5" />
                        </Button>
                    </div>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\views\Sessions\SessionsList.tsx
```typescript
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Play, Loader2 } from 'lucide-react';
import { api } from '../../services/api';

interface Session {
    id: string;
    sessionId: string;
    startTime: number;
    endTime?: number;
    sport: string;
    anomalies: any[]; // Expecting count or array
}

export const SessionsList = () => {
    const navigate = useNavigate();
    const [sessions, setSessions] = useState<Session[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchSessions = async () => {
            try {
                const data = await api.get('/sessions');
                if (Array.isArray(data)) {
                    // Map or sort data if necessary (latest first)
                    const sorted = data.sort((a: any, b: any) => b.startTime - a.startTime);
                    setSessions(sorted);
                }
            } catch (error) {
                console.error('Failed to fetch sessions:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchSessions();
    }, []);

    const formatDuration = (start: number, end?: number) => {
        if (!end) return 'Live';
        const diff = end - start;
        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        return `${minutes}m ${seconds}s`;
    };

    const formatDate = (ts: number) => new Date(ts).toLocaleDateString() + ' ' + new Date(ts).toLocaleTimeString();

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Recorded Sessions</h1>
                <Button variant="primary" onClick={() => window.location.reload()}>Refresh</Button>
            </div>

            <Card className="overflow-hidden">
                {loading ? (
                    <div className="p-12 flex justify-center text-slate-500">
                        <Loader2 className="animate-spin w-8 h-8" />
                    </div>
                ) : (
                    <table className="w-full text-left text-sm">
                        <thead className="bg-slate-900 uppercase text-slate-400 font-semibold">
                            <tr>
                                <th className="p-4">Session ID</th>
                                <th className="p-4">Sport</th>
                                <th className="p-4">Date</th>
                                <th className="p-4">Duration</th>
                                <th className="p-4">Anomalies</th>
                                <th className="p-4">Status</th>
                                <th className="p-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-800">
                            {sessions.length === 0 && (
                                <tr>
                                    <td colSpan={7} className="p-8 text-center text-slate-500">No sessions found.</td>
                                </tr>
                            )}
                            {sessions.map((session) => (
                                <tr key={session.id || session.sessionId} className="hover:bg-slate-800/50 transition-colors">
                                    <td className="p-4 font-mono text-slate-300">{session.sessionId}</td>
                                    <td className="p-4 font-medium">{session.sport}</td>
                                    <td className="p-4 text-slate-400">{formatDate(session.startTime)}</td>
                                    <td className="p-4 text-slate-400">{formatDuration(session.startTime, session.endTime)}</td>
                                    <td className="p-4">
                                        <Badge variant={session.anomalies?.length > 0 ? 'critical' : 'success'}>
                                            {session.anomalies?.length || 0} Detected
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Badge variant={session.endTime ? 'outline' : 'warning'}>
                                            {session.endTime ? 'COMPLETED' : 'LIVE'}
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            onClick={() => navigate(`/sessions/${session.sessionId}`)}
                                        >
                                            <Play className="w-4 h-4 mr-2" /> Replay
                                        </Button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </Card>
        </div>
    );
};

```

#### frontend\src\views\SystemConfig\SystemConfig.tsx
```typescript
import { useState } from 'react';
import { Network, Activity, Crosshair } from 'lucide-react';
import { Button } from '../../components/ui/Button';
import { NodeTopology } from './components/NodeTopology';
import { SensorHealth } from './components/SensorHealth';
import { CalibrationWizard } from './components/CalibrationWizard';

type Tab = 'topology' | 'health' | 'calibration';

const SystemConfig = () => {
    const [activeTab, setActiveTab] = useState<Tab>('topology');

    return (
        <div className="space-y-6">
            {/* Top Bar Actions */}
            <div className="flex justify-between items-center bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
                <div className="flex gap-2">
                    <Button
                        variant={activeTab === 'topology' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('topology')}
                        className="gap-2"
                    >
                        <Network className="w-4 h-4" /> Node Topology
                    </Button>
                    <Button
                        variant={activeTab === 'health' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('health')}
                        className="gap-2"
                    >
                        <Activity className="w-4 h-4" /> Sensor Health
                    </Button>
                    <Button
                        variant={activeTab === 'calibration' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('calibration')}
                        className="gap-2"
                    >
                        <Crosshair className="w-4 h-4" /> Calibration
                    </Button>
                </div>
                <div className="flex gap-2">
                    <Button variant="secondary" size="sm">Export Config</Button>
                    <Button variant="primary" size="sm">Save Changes</Button>
                </div>
            </div>

            {/* Tab Content */}
            <div className="min-h-[600px]">
                {activeTab === 'topology' && <NodeTopology />}
                {activeTab === 'health' && <SensorHealth />}
                {activeTab === 'calibration' && <CalibrationWizard />}
            </div>
        </div>
    );
};

export default SystemConfig;

```

#### frontend\src\views\SystemConfig\components\CalibrationWizard.tsx
```typescript
import { useState, useEffect } from 'react';
import { Button } from '../../../components/ui/Button';
import { Camera, CheckCircle, RefreshCw, AlertTriangle } from 'lucide-react';
import { Api } from '../../../services/api';

type Step = 'SELECT' | 'CAPTURE' | 'VERIFY' | 'COMPLETE';

export function CalibrationWizard() {
    const [step, setStep] = useState<Step>('SELECT');
    const [progress, setProgress] = useState(0);
    const [selectedNode, setSelectedNode] = useState<string | null>(null);
    const [nodes, setNodes] = useState<any[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    // Fetch nodes
    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                setNodes(data.nodes);
            } catch (err) {
                console.error('Failed to fetch nodes for calibration', err);
            }
        };
        fetchNodes();
    }, []);

    const handleStart = async () => {
        if (!selectedNode) return;
        setStep('CAPTURE');
        setProgress(10);
        setError(null);

        try {
            // Start calibration on backend
            const result = await Api.calibrateNode(selectedNode);

            // Progress animation simulation while waiting or based on real status 
            // but for now we just show it finish
            setProgress(50);
            setTimeout(() => {
                setProgress(100);
                setStep('VERIFY');
            }, 1500);

        } catch (err: any) {
            setError(err.message || 'Calibration failed');
            setStep('SELECT');
        }
    };

    const reset = () => {
        setStep('SELECT');
        setProgress(0);
        setSelectedNode(null);
        setError(null);
    };

    return (
        <div className="h-[500px] bg-navy-900 border border-navy-800 rounded-xl p-6 flex flex-col">
            <div className="mb-6">
                <h3 className="text-xl font-bold text-white mb-2">Sensor Calibration</h3>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <span className={step === 'SELECT' ? 'text-indigo-400 font-bold' : ''}>1. Select Node</span>
                    <span>→</span>
                    <span className={step === 'CAPTURE' ? 'text-indigo-400 font-bold' : ''}>2. Capture</span>
                    <span>→</span>
                    <span className={step === 'VERIFY' ? 'text-indigo-400 font-bold' : ''}>3. Verify</span>
                </div>
            </div>

            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-navy-700 rounded-xl bg-navy-800/30 p-8">
                {step === 'SELECT' && (
                    <div className="text-center space-y-4 w-full">
                        <div className="bg-navy-700 p-4 rounded-full inline-block">
                            <Camera className="w-8 h-8 text-indigo-400" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Select a Node to Calibrate</h4>
                        {error && <div className="text-red-500 text-xs">{error}</div>}
                        <div className="grid grid-cols-2 gap-3 w-full max-w-md mx-auto">
                            {nodes.length > 0 ? nodes.map(node => (
                                <button
                                    key={node.nodeId}
                                    onClick={() => setSelectedNode(node.nodeId)}
                                    className={`p-3 rounded border text-sm truncate ${selectedNode === node.nodeId ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node.nodeId}
                                </button>
                            )) : (
                                <div className="col-span-2 text-slate-500 text-xs">No nodes found. Using demo nodes...</div>
                            )}

                            {/* DEMO FALLBACK if no real nodes */}
                            {nodes.length === 0 && ['CAM-01', 'CAM-02'].map(node => (
                                <button
                                    key={node}
                                    onClick={() => setSelectedNode(node)}
                                    className={`p-3 rounded border text-sm ${selectedNode === node ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node}
                                </button>
                            ))}
                        </div>
                        <Button
                            variant="primary"
                            disabled={!selectedNode}
                            onClick={handleStart}
                        >
                            Start Calibration
                        </Button>
                    </div>
                )}

                {step === 'CAPTURE' && (
                    <div className="text-center space-y-6 w-full max-w-md">
                        <RefreshCw className="w-12 h-12 text-indigo-400 animate-spin mx-auto" />
                        <div>
                            <h4 className="text-lg font-medium text-white mb-1">Calibrating {selectedNode}...</h4>
                            <p className="text-sm text-slate-400">Capturing extrinsic parameters and aligning with point cloud.</p>
                        </div>
                        <div className="w-full bg-navy-950 rounded-full h-2.5 overflow-hidden">
                            <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-100" style={{ width: `${progress}%` }}></div>
                        </div>
                        <p className="text-xs text-slate-500 font-mono">{progress}% Complete</p>
                    </div>
                )}

                {step === 'VERIFY' && (
                    <div className="text-center space-y-4">
                        <AlertTriangle className="w-12 h-12 text-amber-400 mx-auto" />
                        <h4 className="text-lg font-medium text-white">Verification Required</h4>
                        <p className="text-sm text-slate-400 max-w-xs mx-auto">
                            The calculated transform has a reprojection error of <span className="text-white font-mono">0.024m</span>. This is within acceptable limits.
                        </p>
                        <div className="flex gap-3 justify-center">
                            <Button variant="secondary" onClick={reset}>Discard</Button>
                            <Button variant="primary" onClick={() => setStep('COMPLETE')}>Apply Transform</Button>
                        </div>
                    </div>
                )}

                {step === 'COMPLETE' && (
                    <div className="text-center space-y-4">
                        <div className="bg-emerald-500/10 p-4 rounded-full inline-block">
                            <CheckCircle className="w-12 h-12 text-emerald-500" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Calibration Successful</h4>
                        <p className="text-sm text-slate-400">Node {selectedNode} is now active and aligned.</p>
                        <Button variant="ghost" onClick={reset}>Calibrate Another Node</Button>
                    </div>
                )}
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\NodeTopology.tsx
```typescript
import { Plus } from 'lucide-react';
import { TopologyCanvas } from './TopologyCanvas';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const NODES = [
    { id: 'NODE_001', name: 'Gate B Cam 1', status: 'online', type: 'Camera' },
    { id: 'NODE_002', name: 'Gate B LIDAR', status: 'offline', type: 'LIDAR' },
    { id: 'NODE_003', name: 'Field Cam Main', status: 'online', type: 'Camera' },
];

export function NodeTopology() {
    return (
        <div className="flex flex-col lg:flex-row gap-6 h-[700px]">
            {/* Left Panel: Node List */}
            <div className="w-full lg:w-[300px] flex flex-col gap-4">
                <Card className="flex-1 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-white">Nodes</h3>
                        <Button size="icon" variant="ghost"><Plus className="w-4 h-4" /></Button>
                    </div>

                    <div className="space-y-3 flex-1 overflow-y-auto">
                        {NODES.map(node => (
                            <div key={node.id} className="p-3 bg-navy-900 rounded-lg border border-navy-700 hover:border-indigo-500 cursor-pointer transition-colors">
                                <div className="flex justify-between items-start mb-1">
                                    <div className="font-mono text-xs text-slate-500">{node.id}</div>
                                    <Badge variant={node.status === 'online' ? 'success' : 'critical'} size="sm" className="h-2 w-2 p-0 rounded-full"> </Badge>
                                </div>
                                <div className="font-bold text-sm text-slate-200">{node.name}</div>
                                <div className="text-xs text-indigo-400 mt-1">{node.type}</div>
                            </div>
                        ))}
                    </div>

                    <Button variant="secondary" fullWidth className="mt-4">Add New Node</Button>
                </Card>
            </div>

            {/* Right Panel: 3D View */}
            <div className="flex-1 bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden relative">
                <TopologyCanvas />
                <div className="absolute top-4 right-4 bg-navy-800/80 p-2 rounded text-xs text-slate-400">
                    <p>Left Click: Rotate</p>
                    <p>Right Click: Pan</p>
                    <p>Scroll: Zoom</p>
                </div>

                {/* Overlay Controls */}
                <div className="absolute top-4 right-4 bg-navy-800/80 backdrop-blur p-3 rounded-lg border border-navy-700 space-y-2">
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show Frustums
                    </label>
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show LIDAR
                    </label>
                </div>
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\SensorHealth.tsx
```typescript
import { Badge } from '../../../components/ui/Badge';

export function SensorHealth() {
    return (
        <div className="bg-navy-800 rounded-xl border border-navy-700 overflow-hidden">
            <table className="w-full text-left text-sm">
                <thead className="bg-navy-900 text-slate-400 font-medium">
                    <tr>
                        <th className="p-4">Node ID</th>
                        <th className="p-4">Sensor</th>
                        <th className="p-4">Status</th>
                        <th className="p-4">FPS (Target)</th>
                        <th className="p-4">Latency</th>
                        <th className="p-4">Last Update</th>
                        <th className="p-4 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-navy-700">
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_001</td>
                        <td className="p-4">Camera</td>
                        <td className="p-4"><Badge variant="success">ONLINE</Badge></td>
                        <td className="p-4">30/30</td>
                        <td className="p-4 text-green-400">12ms</td>
                        <td className="p-4 text-slate-400">Just now</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_002</td>
                        <td className="p-4">LIDAR</td>
                        <td className="p-4"><Badge variant="critical">OFFLINE</Badge></td>
                        <td className="p-4 text-red-400">0/10</td>
                        <td className="p-4 text-slate-500">--</td>
                        <td className="p-4 text-red-400">5m ago</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\TopologyCanvas.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Grid, Center, Text } from '@react-three/drei';

const Node = ({ position, color, label }: { position: [number, number, number], color: string, label: string }) => {
    return (
        <group position={position}>
            {/* Node visual */}
            <mesh>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* Frustum Visual (Cone) */}
            <mesh position={[0, 0, 2]} rotation={[Math.PI / 2, 0, 0]}>
                <coneGeometry args={[1, 4, 32, 1, true]} />
                <meshStandardMaterial color={color} wireframe opacity={0.3} transparent />
            </mesh>

            {/* Label */}
            <Text position={[0, 1.2, 0]} fontSize={0.5} color="white" anchorX="center" anchorY="middle">
                {label}
            </Text>
        </group>
    );
};

export function TopologyCanvas() {
    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden">
            <Canvas>
                <PerspectiveCamera makeDefault position={[10, 10, 10]} fov={50} />
                <OrbitControls makeDefault />

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} />

                <Grid infiniteGrid fadeDistance={50} sectionColor="#4f46e5" cellColor="#4f46e5" sectionSize={5} cellSize={1} />

                <Center>
                    <Node position={[0, 2, 0]} color="#10b981" label="Cam-01" />
                    <Node position={[-5, 2, 5]} color="#3b82f6" label="Lidar-01" />
                    <Node position={[5, 2, 5]} color="#3b82f6" label="Lidar-02" />
                </Center>
            </Canvas>
        </div>
    );
}

```

#### frontend\src\views\Triage\AnomalyTriage.tsx
```typescript
import { useEffect, useState } from 'react';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { wsService } from '../../services/websocket';

interface TriageTask {
    id: string;
    title: string;
    time: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

export const AnomalyTriage = () => {
    const [newIncidents, setNewIncidents] = useState<TriageTask[]>([]);

    // Mock existing state for other columns
    const [investigating] = useState<TriageTask[]>([
        { id: 'A-099', title: 'Crowd Density Warning', time: '09:30 AM', severity: 'MEDIUM' },
    ]);
    const [resolved] = useState<TriageTask[]>([
        { id: 'A-055', title: 'Sensor Dropout', time: 'Yesterday', severity: 'LOW' },
    ]);

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            const newTask: TriageTask = {
                id: data.anomalyId || 'unknown',
                title: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };
            setNewIncidents(prev => [newTask, ...prev]);
        });
        return () => { };
    }, []);

    return (
        <div className="p-6 h-full text-white overflow-hidden flex flex-col">
            <h1 className="text-2xl font-bold mb-6">Anomaly Triage (Live)</h1>

            <div className="flex-1 flex gap-6 min-h-0 overflow-x-auto">
                <Column title="New Incidents" color="border-red-500" items={newIncidents} />
                <Column title="Investigating" color="border-yellow-500" items={investigating} />
                <Column title="Resolved" color="border-green-500" items={resolved} />
            </div>
        </div>
    );
};

const Column = ({ title, color, items }: any) => (
    <div className="flex-1 flex flex-col gap-4 min-w-[300px]">
        <div className={`font-semibold pb-2 border-b-2 ${color} flex justify-between`}>
            {title}
            <span className="text-slate-500 text-sm">{items.length}</span>
        </div>
        <div className="flex-1 bg-slate-900/50 rounded-lg p-2 space-y-3 overflow-y-auto">
            {items.map((item: any) => (
                <Card key={item.id} className="p-3 cursor-move hover:bg-slate-800 transition-colors">
                    <div className="flex justify-between items-start mb-2">
                        <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                        <Badge variant={item.severity.toLowerCase()}>{item.severity}</Badge>
                    </div>
                    <div className="font-medium text-sm mb-2">{item.title}</div>
                    <div className="text-xs text-slate-400">{item.time}</div>
                </Card>
            ))}
        </div>
    </div>
);

```

## 1. Root

#### deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting deployment for Motion Intelligence Grid..."

# 1. Build and Push Containers
Write-Host "Building and Pushing Containers..."
gcloud builds submit --config cloudbuild.yaml . --project $ProjectId

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# 2. Apply Terraform
Write-Host "Applying Terraform..."
cd infrastructure
terraform init
terraform apply `
    -var="project_id=$ProjectId" `
    -var="region=$Region" `
    -var="mongodb_uri=$env:MONGODB_URI" `
    -var="jwt_secret=$env:JWT_SECRET" `
    -var="admin_password=$env:ADMIN_PASSWORD" `
    -auto-approve

if ($LASTEXITCODE -ne 0) {
    Write-Error "Terraform failed!"
    exit 1
}

Write-Host "Deployment Complete!"

```

#### manual_deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting Robust Deployment for Motion Intelligence Grid..." -ForegroundColor Cyan

# Function to Build and Push
function Build-And-Push {
    param(
        [string]$ServiceName,
        [string]$Path
    )
    $ImageName = "gcr.io/$ProjectId/motiongrid-$ServiceName`:latest"
    Write-Host "Processing $ServiceName..." -ForegroundColor Yellow
    
    # Build
    Write-Host "  Building $ImageName..."
    docker build -t $ImageName $Path
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Build Failed"; exit 1 }
    
    # Push
    Write-Host "  Pushing $ImageName..."
    docker push $ImageName
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Push Failed"; exit 1 }
    
    Write-Host "  $ServiceName Done." -ForegroundColor Green
}

# 1. Server
Build-And-Push "api" "./server"

# 2. Simulation
Build-And-Push "simulation" "./simulation"

# 3. Frontend
Build-And-Push "frontend" "./frontend"

# 4. Terraform
Write-Host "Applying Infrastructure Updates..." -ForegroundColor Yellow
Set-Location "./infrastructure"
terraform init
terraform apply -var="project_id=$ProjectId" -var="region=$Region" -auto-approve -lock=false

if ($LASTEXITCODE -ne 0) { 
    Write-Error "Terraform Failed"
    exit 1 
}

Write-Host "Deployment Complete! 🚀" -ForegroundColor Green
Set-Location ..

```

#### cloudbuild.yaml
```yaml
steps:
  # Build API
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-api:latest', './server']
    
  # Build Simulation
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest', './simulation']
    
  # Build Frontend
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest', './frontend']

  # Push Images
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-api:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest']


options:
  machineType: 'N1_HIGHCPU_8'

```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # MongoDB database
  mongodb:
    image: mongo:6
    container_name: motiongrid-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: devpassword123
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - motiongrid-network
    command: --wiredTigerCacheSizeGB 1.5

  # Redis (optional, for caching)
  redis:
    image: redis:7-alpine
    container_name: motiongrid-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - motiongrid-network
    command: redis-server --appendonly yes

  # API Gateway (Node.js + Express + Socket.io)
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-api
    restart: unless-stopped
    environment:
      NODE_ENV: development
      PORT: 3001
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
      REDIS_URL: redis://redis:6379
      JWT_SECRET: dev-secret-key
      SIMULATION_API_URL: http://simulation:8000
    ports:
      - "3001:3001"
    volumes:
      - ./server/src:/app/src
    depends_on:
      - mongodb
      - redis
    networks:
      - motiongrid-network
    command: npm run dev

  # Simulation Engine (Python + FastAPI)
  simulation:
    build:
      context: ./simulation
      dockerfile: Dockerfile
    container_name: motiongrid-simulation
    restart: unless-stopped
    environment:
      PYTHONUNBUFFERED: 1
      API_PORT: 8000
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
    ports:
      - "8000:8000"
    volumes:
      - ./simulation/src:/app/src
    depends_on:
      - mongodb
    networks:
      - motiongrid-network
    command: uvicorn src.api.server:app --host 0.0.0.0 --port 8000 --reload

  # Frontend (React SPA)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_WS_URL: ws://localhost:3001
    ports:
      - "5173:5173"
    volumes:
      - ./frontend/src:/app/src
    networks:
      - motiongrid-network
    command: npm run dev

volumes:
  mongodb_data:
  redis_data:


networks:
  motiongrid-network:
    driver: bridge

```

#### .gcloudignore
```
node_modules/
.git/
.github/
infrastructure/.terraform/
.DS_Store
*.log
coverage/
dist/
tmp/
gcloud_temp/

```

## 2. Infrastructure

#### infrastructure\main.tf
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

resource "google_cloud_run_service" "api" {
  name     = "motiongrid-api"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-api:latest"
        ports {
            container_port = 8080
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
            name = "SIMULATION_API_URL"
            value = "https://motiongrid-simulation-rrsyyeqnbq-uc.a.run.app"
        }
        env {
          name  = "JWT_SECRET"
          value = var.jwt_secret
        }
        env {
          name  = "ADMIN_EMAIL"
          value = var.admin_email
        }
          env {
            name  = "ADMIN_PASSWORD"
            value = var.admin_password
          }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

resource "google_cloud_run_service" "simulation" {
  name     = "motiongrid-simulation"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-simulation:latest"
        ports {
            container_port = 8000
        }
        resources {
          limits = {
            cpu    = "2000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
          name  = "API_URL"
          value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service" "frontend" {
  name     = "motiongrid-frontend"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-frontend:latest"
        ports {
            container_port = 80
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        env {
            name = "VITE_API_URL"
            value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service_iam_member" "public_access_frontend" {
  service  = google_cloud_run_service.frontend.name
  location = google_cloud_run_service.frontend.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

# Storage Bucket for Session Recordings
resource "google_storage_bucket" "sessions" {
  name     = "${var.project_id}-sessions"
  location = var.region
  
  uniform_bucket_level_access = true
  
  lifecycle_rule {
    action { type = "Delete" }
    condition { age = 180 }  # Keep recordings 6 months
  }
}

resource "google_cloud_run_service_iam_member" "public_access_api" {
  service  = google_cloud_run_service.api.name
  location = google_cloud_run_service.api.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_simulation" {
  service  = google_cloud_run_service.simulation.name
  location = google_cloud_run_service.simulation.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "frontend_url" {
  value = google_cloud_run_service.frontend.status[0].url
}

```

#### infrastructure\variables.tf
```hcl
variable "project_id" {
  description = "GCP Project ID"
  type        = string
  default     = "freeforge-481415"
}

variable "region" {
  description = "GCP Region"
  type        = string
  default     = "us-central1"
}

variable "mongodb_uri" {
    description = "MongoDB Connection String"
    type = string
    sensitive = true
}

variable "jwt_secret" {
    description = "JWT Secret for authentication"
    type = string
    sensitive = true
}

variable "admin_email" {
    description = "Default admin email"
    type = string
    default = "admin@freeforge.com"
}

variable "admin_password" {
    description = "Default admin password"
    type = string
    sensitive = true
}


```

## 3. Server

#### server\Dockerfile
```
# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine AS production
WORKDIR /app
ENV NODE_ENV=production
COPY package*.json ./
RUN npm install --only=production
COPY --from=builder /app/dist ./dist
EXPOSE 8080
CMD ["node", "dist/index.js"]

```

#### server\package.json
```json
{
  "name": "motiongrid-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.2",
    "mongoose": "^8.0.3",
    "redis": "^4.6.11",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "axios": "^1.6.2",
    "typescript": "^5.3.3",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/express": "^4.17.21",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11"
  }
}
```

#### server\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2016",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": false,
        "noImplicitAny": false,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "noEmitOnError": false,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts"
    ]
}
```

#### server\src\database.ts
```typescript
import mongoose from 'mongoose';

export const connectDB = async () => {
    const uri = process.env.MONGODB_URI;

    if (!uri) {
        console.error('❌ MONGODB_URI environment variable is required');
        // In production, we might want to throw error, but for now we log error
        // throwing error would crash loop which is handled by index.ts
        throw new Error('MONGODB_URI environment variable is required');
    }

    if (uri === 'memory') {
        console.warn('⚠️ Running in IN-MEMORY mode (dev only). Persistence disabled.');
        return;
    }

    try {
        console.log(`[DATABASE] Connecting to MongoDB (URI ending in: ...${uri.slice(-4)})`);
        await mongoose.connect(uri, {
            serverSelectionTimeoutMS: 10000, // 10 seconds
        });
        console.log('✅ MongoDB connected successfully');
    } catch (error: any) {
        console.error('❌ MongoDB connection failed:', error.message);
        throw error;
    }
};

```

#### server\src\index.ts
```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { connectDB } from './database';
import { socketService } from './services/SocketService';
import { authenticate as authMiddleware } from './middleware/auth';

// Import routes at the top as per best practices
import authRouter from './routes/auth';
import nodesRouter from './routes/nodes';
import sessionsRouter from './routes/sessions';
import anomaliesRouter from './routes/anomalies';
import entitiesRouter from './routes/entities';
import simulationRouter from './routes/simulation';
import analyticsRouter from './routes/analytics';

// Load environment variables
dotenv.config();

console.log('🚀 [STARTUP] Motion Intelligence Grid API initiating...');
console.log(`[STARTUP] Environment: ${process.env.NODE_ENV || 'development'}`);

const app = express();
const httpServer = createServer(app);

// BIND PORT IMMEDIATELY FOR CLOUD RUN HEALTH CHECKS
const PORT = process.env.PORT || 8080;
httpServer.listen(PORT, () => {
    console.log(`✅ [STARTUP] API listening on port ${PORT}`);
});

const io = new Server(httpServer, {
    cors: {
        origin: process.env.CLIENT_URL || '*',
        methods: ['GET', 'POST'],
    },
});

// Initialize SocketService
socketService.init(io);

// Middleware
app.use(cors());
app.use(helmet());
app.use(express.json());

// Basic health check (Always available)
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date(),
        db: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        uptime: process.uptime()
    });
});

// Routes
app.use('/api/auth', authRouter);
app.use('/api/nodes', authMiddleware, nodesRouter);
app.use('/api/sessions', authMiddleware, sessionsRouter);
app.use('/api/anomalies', authMiddleware, anomaliesRouter);
app.use('/api/entities', authMiddleware, entitiesRouter);
app.use('/api/simulation', authMiddleware, simulationRouter);
app.use('/api/analytics', authMiddleware, analyticsRouter);

// Internal Endpoints for Simulation Bridge
app.post('/internal/entity-update', async (req, res) => {
    const { sessionId, entities, stats, sentAt } = req.body;
    const latencyMs = sentAt ? Math.round((Date.now() / 1000 - sentAt) * 1000) : 0;
    socketService.emit('entity:tracking', { entities, stats, latencyMs }, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

app.post('/internal/anomaly', async (req, res) => {
    const { sessionId, anomaly } = req.body;
    socketService.emit('anomaly:detected', anomaly, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

const startServer = async () => {
    try {
        console.log('[STARTUP] Connecting to database...');
        await connectDB();
        console.log('✅ [STARTUP] Database connected successfully.');

        if (mongoose.connection.readyState === 1) {
            const { User } = await import('./models/User');
            const adminEmail = process.env.ADMIN_EMAIL || 'admin@freeforge.com';
            const adminPassword = process.env.ADMIN_PASSWORD || 'nimda';

            console.log(`[STARTUP] Checking for admin: ${adminEmail}`);
            const adminUser = await User.findOne({ email: adminEmail });

            if (!adminUser) {
                console.log(`[STARTUP] Seeding default admin user: ${adminEmail} with password: ${adminPassword}...`);
                const newAdmin = new User({
                    email: adminEmail,
                    passwordHash: adminPassword,
                    username: 'admin',
                    role: 'ADMIN'
                });
                await newAdmin.save();
                console.log('✅ [STARTUP] Default admin created.');
            } else {
                console.log(`[STARTUP] Admin user ${adminEmail} exists. Updating password to environment current value...`);
                adminUser.passwordHash = adminPassword;
                await adminUser.save();
                console.log('✅ [STARTUP] Admin password updated successfully.');
            }
        }
    } catch (error) {
        console.error('❌ [STARTUP] initialization failed:', error);
    }
};

startServer();

```

#### server\src\middleware\auth.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface UserPayload {
    userId: string;
    role: string;
    email: string;
}

declare global {
    namespace Express {
        interface Request {
            user?: UserPayload;
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    // Skip auth for login/public routes if applying globally, 
    // but usually we apply this middleware to specific routes.

    const authHeader = req.headers.authorization;
    let token = '';

    if (authHeader) {
        token = authHeader.split(' ')[1]; // Bearer <token>
    } else if (req.query.token) {
        token = req.query.token as string;
    }

    if (!token) {
        return res.status(401).json({ error: 'Token missing or Authorization header missing' });
    }

    try {
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const decoded = jwt.verify(token, secret) as UserPayload;
        req.user = decoded;
        next();
    } catch (err) {
        return res.status(401).json({ error: 'Invalid or expired token' });
    }
};

export const requireRole = (roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        if (!req.user || !roles.includes(req.user.role)) {
            return res.status(403).json({ error: 'Insufficient permissions' });
        }
        next();
    };
};

```

#### server\src\middleware\validate.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

export const validateBody = (schema: Joi.Schema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({ error: error.details[0].message });
        }
        next();
    };
};

```

#### server\src\models\Anomaly.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IAnomaly extends Document {
    anomalyId: string;
    sessionId: mongoose.Types.ObjectId;
    entityIds: mongoose.Types.ObjectId[];
    nodeIds: string[];
    occurredAt: Date;
    duration: number;
    type: 'GEOGRAPHICS' | 'KINETICS' | 'PROXEMICS' | 'ATMOSPHERICS';
    subtype: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    scenario?: string;
    headline: string;
    description: string;
    baselineText: string;
    anomalyText: string;
    metrics: {
        baselineDelta: number;
        confidence: number;
        riskScore: number;
    };
    ruleOfThreeHit: boolean;
    relatedAnomalies: mongoose.Types.ObjectId[];
    zone: string;
    location: { x: number; y: number; z: number };
    triage: {
        status: 'UNREVIEWED' | 'CONFIRMED' | 'DOWNGRADED' | 'FALSE_POSITIVE';
        notes?: string;
    };
    tags: string[];
    createdAt: Date;
    updatedAt: Date;
}

const AnomalySchema: Schema = new Schema({
    anomalyId: { type: String, required: true, unique: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    entityIds: [{ type: Schema.Types.ObjectId, ref: 'Entity' }],
    nodeIds: [String],
    occurredAt: { type: Date, default: Date.now },
    duration: { type: Number, default: 0 },
    type: { type: String, enum: ['GEOGRAPHICS', 'KINETICS', 'PROXEMICS', 'ATMOSPHERICS'], required: true },
    subtype: String,
    severity: { type: String, enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'], default: 'LOW' },
    scenario: String,
    headline: String,
    description: String,
    baselineText: String,
    anomalyText: String,
    metrics: {
        baselineDelta: Number,
        confidence: Number,
        riskScore: Number
    },
    ruleOfThreeHit: { type: Boolean, default: false },
    relatedAnomalies: [{ type: Schema.Types.ObjectId, ref: 'Anomaly' }],
    zone: String,
    location: {
        x: Number,
        y: Number,
        z: Number
    },
    triage: {
        status: { type: String, enum: ['UNREVIEWED', 'CONFIRMED', 'DOWNGRADED', 'FALSE_POSITIVE'], default: 'UNREVIEWED' },
        notes: String,
        triageAt: Date,
        triagedBy: String
    },
    tags: [String]
}, { timestamps: true });

export const Anomaly = mongoose.model<IAnomaly>('Anomaly', AnomalySchema);

```

#### server\src\models\Entity.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IEntity extends Document {
    entityId: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    name?: string;
    lastPosition: { x: number; y: number; z: number };
    lastVelocity: { x: number; y: number; z: number };
    lastSeenAt: Date;
    sessionId?: string;
}

const EntitySchema: Schema = new Schema({
    entityId: { type: String, required: true, unique: true },
    type: { type: String, enum: ['PERSON', 'OBJECT'], required: true },
    role: { type: String, enum: ['PLAYER', 'OFFICIAL', 'SPECTATOR', 'BALL'], default: 'SPECTATOR' },
    team: { type: String, enum: ['HOME', 'AWAY'] },
    name: String,
    lastPosition: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastVelocity: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastSeenAt: { type: Date, default: Date.now },
    sessionId: String
}, { timestamps: true });

export const Entity = mongoose.model<IEntity>('Entity', EntitySchema);

```

#### server\src\models\Node.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INode extends Document {
    nodeId: string;
    name: string;
    type: 'EDGE_NODE';
    status: 'ONLINE' | 'OFFLINE' | 'DEGRADED';
    position: { x: number; y: number; z: number };
    orientation: { pitch: number; yaw: number; roll: number };
    sensors: {
        camera: {
            enabled: boolean;
            resolution: { width: number; height: number };
            fps: number;
            fov: number;
            exposure: number;
            gain: number;
        };
        lidar: {
            enabled: boolean;
            model: string;
            channels: number;
            pointsPerSecond: number;
            range: number;
            accuracy: number;
        };
        imu: {
            enabled: boolean;
            sampleRate: number;
            accelRange: number;
            gyroRange: number;
        };
    };
    calibration: {
        intrinsic: {
            cameraMatrix: number[][];
            distortion: number[];
        };
        extrinsic: {
            rotationMatrix: number[][];
            translationVector: number[];
        };
        lidarToCameraTransform: number[][];
        calibrationQuality: number;
        calibratedAt: Date;
    };
    network: {
        ipAddress: string;
        port: number;
        ptpDomain: number;
        clockOffset: number;
        lastSyncAt: Date;
    };
    sessionId?: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const NodeSchema: Schema = new Schema({
    nodeId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    type: { type: String, default: 'EDGE_NODE' },
    status: { type: String, enum: ['ONLINE', 'OFFLINE', 'DEGRADED'], default: 'OFFLINE' },
    position: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    orientation: {
        pitch: { type: Number, default: 0 },
        yaw: { type: Number, default: 0 },
        roll: { type: Number, default: 0 }
    },
    sensors: {
        camera: {
            enabled: { type: Boolean, default: true },
            resolution: {
                width: { type: Number, default: 1920 },
                height: { type: Number, default: 1080 }
            },
            fps: { type: Number, default: 30 },
            fov: { type: Number, default: 90 },
            exposure: { type: Number, default: 50 },
            gain: { type: Number, default: 0 }
        },
        lidar: {
            enabled: { type: Boolean, default: true },
            model: { type: String, default: 'VLP-16' },
            channels: { type: Number, default: 16 },
            pointsPerSecond: { type: Number, default: 300000 },
            range: { type: Number, default: 100 },
            accuracy: { type: Number, default: 0.03 }
        },
        imu: {
            enabled: { type: Boolean, default: true },
            sampleRate: { type: Number, default: 100 },
            accelRange: { type: Number, default: 16 },
            gyroRange: { type: Number, default: 2000 }
        }
    },
    calibration: {
        intrinsic: {
            cameraMatrix: [[Number]],
            distortion: [Number]
        },
        extrinsic: {
            rotationMatrix: [[Number]],
            translationVector: [Number]
        },
        lidarToCameraTransform: [[Number]],
        calibrationQuality: { type: Number, default: 0 },
        calibratedAt: Date
    },
    network: {
        ipAddress: String,
        port: Number,
        ptpDomain: { type: Number, default: 0 },
        clockOffset: { type: Number, default: 0 },
        lastSyncAt: Date
    },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session' }
}, { timestamps: true });

export const Node = mongoose.model<INode>('Node', NodeSchema);

```

#### server\src\models\SensorFrame.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISensorFrame extends Document {
    frameId: string;
    sessionId: mongoose.Types.ObjectId;
    nodeId: string;
    timestamp: Date;
    frameNumber: number;
    camera?: {
        imagePath: string;
        resolution: { width: number; height: number };
    };
    lidar?: {
        pointCloudPath: string;
        pointCount: number;
    };
    fusion?: {
        detectedEntities: any[];
        processingTime: number;
    };
    createdAt: Date;
}

const SensorFrameSchema: Schema = new Schema({
    frameId: { type: String, required: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    nodeId: { type: String, required: true },
    timestamp: { type: Date, required: true },
    frameNumber: Number,
    camera: {
        imagePath: String,
        resolution: { width: Number, height: Number }
    },
    lidar: {
        pointCloudPath: String,
        pointCount: Number
    },
    fusion: {
        detectedEntities: [],
        processingTime: Number
    }
}, {
    timeseries: {
        timeField: 'timestamp',
        metaField: 'nodeId',
        granularity: 'seconds'
    },
    expireAfterSeconds: 86400 * 7 // 7 days retention
});

export const SensorFrame = mongoose.model<ISensorFrame>('SensorFrame', SensorFrameSchema);

```

#### server\src\models\Session.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISession extends Document {
    sessionId: string;
    name: string;
    sport: 'BASKETBALL' | 'SOCCER' | 'COMBAT' | 'CUSTOM';
    venue: string;
    startedAt: Date;
    endedAt?: Date;
    duration: number;
    status: 'RECORDING' | 'STOPPED' | 'PROCESSING' | 'READY';
    nodeIds: string[];
    stats: {
        totalFrames: number;
        totalEntities: number;
        totalAnomalies: number;
        anomalyBreakdown: {
            critical: number;
            high: number;
            medium: number;
            low: number;
        };
        avgOccupancy: number;
        peakOccupancy: number;
        avgActivityIndex: number;
    };
    scenario: {
        entityCount: number;
        crowdDensity: number;
        anomalyRate: number;
        environmentConfig: {
            lighting: 'BRIGHT' | 'DIM' | 'VARIABLE';
            weather?: 'CLEAR' | 'RAIN' | 'SNOW';
        };
    };
    dataPath: string;
    thumbnailPath?: string;
    createdAt: Date;
    updatedAt: Date;
}

const SessionSchema: Schema = new Schema({
    sessionId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    sport: { type: String, enum: ['BASKETBALL', 'SOCCER', 'COMBAT', 'CUSTOM'], required: true },
    venue: String,
    startedAt: { type: Date, default: Date.now },
    endedAt: Date,
    duration: { type: Number, default: 0 },
    status: { type: String, enum: ['RECORDING', 'STOPPED', 'PROCESSING', 'READY'], default: 'RECORDING' },
    nodeIds: [String],
    stats: {
        totalFrames: { type: Number, default: 0 },
        totalEntities: { type: Number, default: 0 },
        totalAnomalies: { type: Number, default: 0 },
        anomalyBreakdown: {
            critical: { type: Number, default: 0 },
            high: { type: Number, default: 0 },
            medium: { type: Number, default: 0 },
            low: { type: Number, default: 0 }
        },
        avgOccupancy: { type: Number, default: 0 },
        peakOccupancy: { type: Number, default: 0 },
        avgActivityIndex: { type: Number, default: 0 }
    },
    scenario: {
        entityCount: { type: Number, default: 0 },
        crowdDensity: { type: Number, default: 0 },
        anomalyRate: { type: Number, default: 0 },
        environmentConfig: {
            lighting: { type: String, default: 'BRIGHT' },
            weather: String
        }
    },
    dataPath: String,
    thumbnailPath: String
}, { timestamps: true });

export const Session = mongoose.model<ISession>('Session', SessionSchema);

```

#### server\src\models\User.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
    username: string;
    email: string;
    passwordHash: string;
    role: 'OPERATOR' | 'ANALYST' | 'ADMIN';
    permissions: string[];
    preferences: {
        theme: 'DARK' | 'LIGHT';
    };
    createdAt: Date;
    updatedAt: Date;
    validatePassword(password: string): Promise<boolean>;
}

const UserSchema: Schema = new Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['OPERATOR', 'ANALYST', 'ADMIN'], default: 'OPERATOR' },
    permissions: [String],
    preferences: {
        theme: { type: String, default: 'DARK' }
    }
}, { timestamps: true });

UserSchema.pre<IUser>('save', async function (next) {
    if (!this.isModified('passwordHash')) return next();
    try {
        const salt = await bcrypt.genSalt(10);
        this.passwordHash = await bcrypt.hash(this.passwordHash, salt);
        next();
    } catch (err: any) {
        next(err);
    }
});

UserSchema.methods.validatePassword = async function (password: string): Promise<boolean> {
    return await bcrypt.compare(password, this.passwordHash);
};

export const User = mongoose.model<IUser>('User', UserSchema);

```

#### server\src\routes\analytics.ts
```typescript
import express from 'express';

const router = express.Router();

router.get('/stats', (req, res) => {
    // Return aggregated stats
    res.json({
        totalAnomalies: 42,
        activeEntities: 15,
        systemHealth: 98.6,
        uptimeSeconds: 3600
    });
});

router.get('/performance', (req, res) => {
    // Return system performance metrics (FPS, Latency)
    res.json({
        simulationFps: 29.8,
        networkLatencyMs: 12,
        processingTimeMs: 4
    });
});

export default router;

```

#### server\src\routes\anomalies.ts
```typescript
import express from 'express';
import { Anomaly } from '../models/Anomaly';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, severity, status } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (severity) query.severity = severity;
        if (status || req.query.triageStatus) query['triage.status'] = status || req.query.triageStatus;

        const anomalies = await Anomaly.find(query).sort({ occurredAt: -1 }).limit(100);
        res.json({ anomalies, count: anomalies.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id/triage', async (req, res) => {
    try {
        const { status, notes } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            {
                'triage.status': status,
                'triage.notes': notes,
                'triage.triageAt': new Date()
            },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/tag', async (req, res) => {
    try {
        const { tags } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            { $addToSet: { tags: { $each: tags } } },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\auth.ts
```typescript
import express from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/User';

const router = express.Router();

router.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        // Find user
        const user = await User.findOne({ email });
        if (!user) {
            console.log(`Login attempt failed: User not found (${email})`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Validate password
        const isValid = await user.validatePassword(password);
        if (!isValid) {
            console.log(`Login attempt failed: Invalid password for ${email}`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        console.log(`Login successful for ${email}`);

        // Generate Token
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const token = jwt.sign(
            {
                userId: user._id,
                role: user.role,
                email: user.email
            },
            secret,
            { expiresIn: '24h' }
        );

        res.json({
            token,
            user: {
                id: user._id,
                email: user.email,
                role: user.role,
                username: user.username
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.post('/register', async (req, res) => {
    // For MVP/Demo: Allow registration of first user as ADMIN, others as VIEWERS
    // Or just open registration for "OPERATOR"
    try {
        const { email, password, username } = req.body;

        const existing = await User.findOne({ $or: [{ email }, { username }] });
        if (existing) {
            return res.status(400).json({ error: 'User already exists' });
        }

        const count = await User.countDocuments();
        const role = count === 0 ? 'ADMIN' : 'OPERATOR';

        const user = new User({
            email,
            passwordHash: password, // Will be hashed by pre-save hook
            username,
            role
        });

        await user.save();

        res.status(201).json({ message: 'User created', userId: user._id });
    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({ error: 'Registration failed' });
    }
});

export default router;

```

#### server\src\routes\entities.ts
```typescript
import express from 'express';
import { Entity } from '../models/Entity';
import { SensorFrame } from '../models/SensorFrame';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, type, RKole } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (type) query.type = type;
        if (RKole) query.role = RKole;

        const entities = await Entity.find(query);
        res.json(entities);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const entity = await Entity.findOne({ entityId: req.params.id });
        if (!entity) return res.status(404).json({ error: 'Entity not found' });
        res.json(entity);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/track', async (req, res) => {
    try {
        const { id } = req.params;
        const { startTime, endTime } = req.query;

        // Find frames where this entity appears in fusion data
        // Note: This query depends on how SensorFrame stores fusion data
        const query: any = {
            'fusion.detectedEntities.id': id
        };

        if (startTime || endTime) {
            query.timestamp = {};
            if (startTime) query.timestamp.$gte = new Date(String(startTime));
            if (endTime) query.timestamp.$lte = new Date(String(endTime));
        }

        const frames = await SensorFrame.find(query)
            .select('timestamp fusion.detectedEntities')
            .sort({ timestamp: 1 })
            .limit(1000);

        // Extract just the relevant position data
        const path = frames.map(f => {
            const ent = f.toJSON().fusion?.detectedEntities?.find((e: any) => e.id === id);
            return {
                timestamp: f.timestamp,
                position: ent?.position
            };
        }).filter(p => p.position);

        res.json({
            entityId: id,
            path
        });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\nodes.ts
```typescript
import express from 'express';
import axios from 'axios';
import { NodeService } from '../services/NodeService';

const router = express.Router();
const nodeService = new NodeService();

router.post('/', async (req, res) => {
    try {
        const node = await nodeService.createNode(req.body);
        res.status(201).json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const nodes = await nodeService.getNodes(req.query);
        res.json({ nodes, count: nodes.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const node = await nodeService.getNode(req.params.id);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/stream', async (req, res) => {
    try {
        const nodeId = req.params.id;
        // Ideally use env var for simulation URL
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios({
            method: 'get',
            url: `${simulationUrl}/nodes/${nodeId}/stream`,
            responseType: 'stream'
        });

        // Forward content type (multipart/x-mixed-replace)
        res.setHeader('Content-Type', response.headers['content-type']);
        response.data.pipe(res);
    } catch (err: any) {
        // console.error('Stream proxy error:', err.message);
        res.status(503).send('Stream unavailable');
    }
});

router.post('/:id/calibrate', async (req, res) => {
    try {
        const nodeId = req.params.id;
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios.post(`${simulationUrl}/nodes/${nodeId}/calibrate`);
        const result = response.data;

        // Update node in database
        await nodeService.updateNode(nodeId, {
            calibration: result.calibration
        });

        res.json(result);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const node = await nodeService.updateNode(req.params.id, req.body);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await nodeService.deleteNode(req.params.id);
        if (!success) return res.status(404).json({ error: 'Node not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\sessions.ts
```typescript
import express from 'express';
import { SessionService } from '../services/SessionService';

const router = express.Router();
const sessionService = new SessionService();

router.post('/', async (req, res) => {
    try {
        const session = await sessionService.createSession(req.body);
        res.status(201).json(session);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const sessions = await sessionService.getSessions(req.query);
        res.json({ sessions, count: sessions.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/start', async (req, res) => {
    try {
        const session = await sessionService.startSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/stop', async (req, res) => {
    try {
        const session = await sessionService.stopSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const session = await sessionService.updateSession(req.params.id, req.body);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json(session);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await sessionService.deleteSession(req.params.id);
        if (!success) return res.status(404).json({ error: 'Session not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});


router.get('/:sessionId/frames', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const { startTime, endTime, limit = 100 } = req.query;

        // This relies on SensorFrame model being available. 
        // We might need to import it or use a service method.
        // Ideally checking SessionService first.
        const frames = await sessionService.getSessionFrames(sessionId, {
            startTime: startTime ? new Date(String(startTime)) : undefined,
            endTime: endTime ? new Date(String(endTime)) : undefined,
            limit: Number(limit)
        });

        res.json({ frames, count: frames.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:sessionId/export', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const { format = 'json' } = req.query;

        // Use any to bypass strict type check for now or import models
        const session = await sessionService.getSession(sessionId);
        if (!session) return res.status(404).json({ error: 'Session not found' });

        const frames = await sessionService.getSessionFrames(sessionId, { limit: 10000 });

        // We'd need an AnomalyService or direct DB call here. 
        // For simplicity reusing Frame logic but we will stub Anomaly export if Service doesn't support it yet
        // or import Anomaly model directly.
        // Let's import Anomaly model dynamically to avoid circular deps or service bloat for now
        const { Anomaly } = await import('../models/Anomaly');
        const anomalies = await Anomaly.find({ sessionId: session._id }).sort({ occurredAt: 1 });

        if (format === 'csv') {
            res.setHeader('Content-Type', 'text/csv');
            res.setHeader('Content-Disposition', `attachment; filename="session-${sessionId}.csv"`);

            let csv = 'Timestamp,Type,ID,Detail\n';
            frames.forEach((f: any) => {
                csv += `${f.timestamp.toISOString()},FRAME,${f.frameNumber},\n`;
            });
            anomalies.forEach((a: any) => {
                csv += `${a.occurredAt.toISOString()},ANOMALY,${a.anomalyId},${a.type}\n`;
            });

            res.send(csv);
        } else {
            res.json({
                session,
                frames,
                anomalies,
                stats: {
                    duration: session.duration,
                    totalFrames: frames.length,
                    totalAnomalies: anomalies.length
                }
            });
        }
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\simulation.ts
```typescript
import express from 'express';
import { SimulationClient } from '../services/simulation_client';

const router = express.Router();

router.post('/start', async (req, res) => {
    const config = req.body;
    const success = await SimulationClient.startSimulation(config);
    if (success) {
        res.json({ message: 'Simulation started' });
    } else {
        res.status(500).json({ error: 'Failed to start simulation' });
    }
});

router.post('/stop', async (req, res) => {
    const success = await SimulationClient.stopSimulation();
    if (success) {
        res.json({ message: 'Simulation stopped' });
    } else {
        res.status(500).json({ error: 'Failed to stop simulation' });
    }
});

router.get('/status', async (req, res) => {
    const isHealthy = await SimulationClient.healthCheck();
    res.json({
        status: isHealthy ? 'running' : 'stopped',
        service: 'python-engine'
    });
});

export default router;

```

#### server\src\services\AnalyticsService.ts
```typescript
import { Session } from '../models/Session';
import { Anomaly } from '../models/Anomaly';

export class AnalyticsService {
    async getSessionStats(sessionId: string) {
        const session = await Session.findOne({ sessionId });
        if (!session) throw new Error('Session not found');

        const anomalyCount = await Anomaly.countDocuments({ sessionId: session._id });
        const criticalAnomalies = await Anomaly.countDocuments({ sessionId: session._id, severity: 'CRITICAL' });

        return {
            ...session.toJSON().stats,
            anomalyCount,
            criticalAnomalies
        };
    }

    async getGlobalStats() {
        const totalSessions = await Session.countDocuments();
        const totalAnomalies = await Anomaly.countDocuments();

        return {
            totalSessions,
            totalAnomalies,
            systemHealth: 'HEALTHY' // Placeholder
        };
    }
}

```

#### server\src\services\NodeService.ts
```typescript
import { Node, INode } from '../models/Node';

export class NodeService {
    async createNode(data: Partial<INode>): Promise<INode> {
        // Validation: Check if nodeId exists
        const existing = await Node.findOne({ nodeId: data.nodeId });
        if (existing) {
            throw new Error('Node ID already exists');
        }

        const node = new Node(data);
        return await node.save();
    }

    async getNodes(filter: any = {}): Promise<INode[]> {
        return await Node.find(filter);
    }

    async getNode(nodeId: string): Promise<INode | null> {
        return await Node.findOne({ nodeId });
    }

    async updateNode(nodeId: string, data: Partial<INode>): Promise<INode | null> {
        return await Node.findOneAndUpdate({ nodeId }, data, { new: true });
    }

    async deleteNode(nodeId: string): Promise<boolean> {
        const result = await Node.deleteOne({ nodeId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\SessionService.ts
```typescript
import { Session, ISession } from '../models/Session';
import mongoose from 'mongoose';
import { SensorFrame } from '../models/SensorFrame';

export class SessionService {
    async createSession(data: Partial<ISession>): Promise<ISession> {
        const session = new Session({
            ...data,
            sessionId: `SES_${Date.now()}`
        });
        return await session.save();
    }

    async getSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOne({ sessionId });
    }

    async getSessions(filter: any = {}): Promise<ISession[]> {
        return await Session.find(filter).sort({ createdAt: -1 });
    }

    async getSessionFrames(sessionId: string, options: { startTime?: Date, endTime?: Date, limit?: number }): Promise<any[]> {
        const session = await Session.findOne({ sessionId });
        if (!session) return [];

        const query: any = { sessionId: session._id };
        if (options.startTime || options.endTime) {
            query.timestamp = {};
            if (options.startTime) query.timestamp.$gte = options.startTime;
            if (options.endTime) query.timestamp.$lte = options.endTime;
        }

        return await SensorFrame.find(query).sort({ timestamp: 1 }).limit(options.limit || 100);
    }

    async startSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'RECORDING',
                startedAt: new Date()
            },
            { new: true }
        );
    }

    async stopSession(sessionId: string): Promise<ISession | null> {
        const session = await Session.findOne({ sessionId });
        if (!session) return null;

        const endedAt = new Date();
        const duration = (endedAt.getTime() - session.startedAt.getTime()) / 1000;

        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'STOPPED',
                endedAt,
                duration
            },
            { new: true }
        );
    }


    async updateSession(sessionId: string, data: Partial<ISession>): Promise<ISession | null> {
        return await Session.findOneAndUpdate({ sessionId }, data, { new: true });
    }

    async deleteSession(sessionId: string): Promise<boolean> {
        const result = await Session.deleteOne({ sessionId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\simulation_client.ts
```typescript
import axios from 'axios';

const SIMULATION_API_URL = process.env.SIMULATION_API_URL || 'http://localhost:8000';

export class SimulationClient {

    static async healthCheck(): Promise<boolean> {
        try {
            const response = await axios.get(`${SIMULATION_API_URL}/health`);
            return response.data.status === 'ok';
        } catch (error) {
            console.error('Simulation API unhealthy:', error.message);
            return false;
        }
    }

    static async startSimulation(config: any): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/start`, config);
            return response.data.status === 'started';
        } catch (error) {
            console.error('Failed to start simulation:', error.message);
            return false;
        }
    }

    static async stopSimulation(): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/stop`);
            return response.data.status === 'stopped';
        } catch (error) {
            console.error('Failed to stop simulation:', error.message);
            return false;
        }
    }
}

```

#### server\src\services\SocketService.ts
```typescript
import { Server, Socket } from 'socket.io';
import jwt from 'jsonwebtoken';

class SocketService {
    private io: Server | null = null;

    init(io: Server) {
        this.io = io;
        this.setupListeners();
    }

    private setupListeners() {
        if (!this.io) return;

        // Authentication Middleware
        this.io.use((socket, next) => {
            const token = socket.handshake.auth.token || socket.handshake.query.token;

            if (!token) {
                return next(new Error('Authentication required'));
            }

            try {
                const secret = process.env.JWT_SECRET;
                if (!secret) {
                    console.error('❌ CRITICAL: JWT_SECRET environment variable is missing! Falling back to dev secret (INSECURE)');
                }
                const decoded = jwt.verify(token as string, secret || 'dev_secret_do_not_use_in_prod');
                (socket as any).user = decoded;
                next();
            } catch (err) {
                next(new Error('Invalid token'));
            }
        });

        this.setupHandlers();
    }

    private setupHandlers() {
        if (!this.io) return;

        this.io.on('connection', (socket: Socket) => {
            const user = (socket as any).user;
            console.log(`Client connected: ${socket.id} (User: ${user?.email || 'Unknown'})`);

            socket.on('disconnect', () => {
                console.log('Client disconnected:', socket.id);
            });

            // Handle subscriptions
            socket.on('subscribe:session', (data) => {
                console.log(`Client ${socket.id} subscribed to session ${data.sessionId}`);
                socket.join(`session:${data.sessionId}`);
            });

            socket.on('subscribe:node', (data) => {
                console.log(`Client ${socket.id} subscribed to node ${data.nodeId}`);
                socket.join(`node:${data.nodeId}`);
            });
        });
    }

    emit(event: string, data: any, room?: string) {
        if (!this.io) {
            console.warn('SocketService not initialized');
            return;
        }

        if (room) {
            this.io.to(room).emit(event, data);
        } else {
            this.io.emit(event, data);
        }
    }
}

export const socketService = new SocketService();

```

#### server\src\__tests__\integration\session-flow.test.ts
```typescript
import request from 'supertest';
// Mocking app import since we might not export it correctly for testing in index.ts
// In a real setup, we'd export `app` from app.ts and import it in index.ts
// For now, pseudo-integration test or need to refactor index.ts
// Refactoring index.ts to export app is best practice.

describe('Session Flow Integration', () => {
    it('placeholder for integration test', async () => {
        expect(true).toBe(true);
    });
});

```

#### server\src\__tests__\services\NodeService.test.ts
```typescript
import { NodeService } from '../../services/NodeService';
import { Node } from '../../models/Node';

// Mock the Mongoose Model
jest.mock('../../models/Node');

describe('NodeService', () => {
    let nodeService: NodeService;

    beforeEach(() => {
        nodeService = new NodeService();
        jest.clearAllMocks();
    });

    it('should create a node successfully', async () => {
        const mockNodeData = {
            nodeId: 'TEST_001',
            name: 'Test Node',
            position: { x: 0, y: 0, z: 0 },
            status: 'active'
        };

        // Mock findOne to return null (not found)
        (Node.findOne as jest.Mock).mockResolvedValue(null);

        // Mock create
        (Node.create as jest.Mock).mockResolvedValue(mockNodeData);

        const result = await nodeService.createNode(mockNodeData);

        expect(Node.findOne).toHaveBeenCalledWith({ nodeId: 'TEST_001' });
        expect(Node.create).toHaveBeenCalledWith(mockNodeData);
        expect(result).toEqual(mockNodeData);
    });

    it('should throw error if node already exists', async () => {
        const mockNodeData = { nodeId: 'DUPLICATE_001', name: 'Dup' };

        // Mock findOne to return existing doc
        (Node.findOne as jest.Mock).mockResolvedValue({ nodeId: 'DUPLICATE_001' });

        await expect(nodeService.createNode(mockNodeData))
            .rejects
            .toThrow('Node with this ID already exists');
    });

    it('should get all nodes', async () => {
        const mockNodes = [{ nodeId: 'N1' }, { nodeId: 'N2' }];
        (Node.find as jest.Mock).mockResolvedValue(mockNodes);

        const result = await nodeService.getAllNodes();

        expect(Node.find).toHaveBeenCalled();
        expect(result).toHaveLength(2);
    });
});

```

## 4. Simulation

#### simulation\Dockerfile
```
FROM python:3.10 AS base

WORKDIR /app

RUN apt-get update && apt-get install -y \
    libgl1 \
    libglib2.0-0 \
    libopenblas-dev \
    liblapack-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM base AS development
COPY . .
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

FROM base AS production
COPY src ./src
ENV PYTHONUNBUFFERED=1
EXPOSE 8000
CMD ["sh", "-c", "uvicorn src.api.server:app --host 0.0.0.0 --port ${PORT:-8080}"]

```

#### simulation\requirements.txt
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
numpy==1.24.3
opencv-python-headless==4.8.1.78

pymongo==4.6.0
motor==3.3.2
python-dateutil==2.8.2
pytz==2023.3

```

#### simulation\src\__init__.py
```python

```

#### simulation\src\anomalies\detector.py
```python
from typing import List

class AnomalyDetector:
    def detect(self, entities: List[dict]) -> List[dict]:
        anomalies = []
        
        # 1. Check Crowd Compression
        # Radius check -> if many entities in small area
        
        # 2. Check Speed
        for e in entities:
             if abs(e.get('velocity', {}).get('x', 0)) > 10: # >10m/s
                 anomalies.append({
                     'id': f"SPEED_{e['id']}",
                     'type': 'KINETICS',
                     'headline': f"High Speed Detected: {e['id']}",
                     'severity': 'MEDIUM'
                 })
                 
        return anomalies

```

#### simulation\src\anomalies\generator.py
```python
import numpy as np
from typing import List, Dict, Optional
import uuid
from datetime import datetime

class AnomalyGenerator:
    """
    Generates realistic anomalies based on entity behavior and scenario context.
    """
    
    def __init__(self):
        self.baselines = {}  # Zone -> baseline metrics
        self.anomaly_rate = 2.0  # anomalies per minute (configurable)
        self.last_anomaly_time = 0
        self.min_anomaly_interval = 5.0  # seconds between anomalies
        
    def detect(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """
        Check for anomalies based on entity behavior.
        Returns list of anomaly dicts.
        """
        anomalies = []
        
        # Update baselines
        self._update_baselines(entities, scenario)
        
        # 1. Crowd Compression (Geographics + Proxemics)
        for zone in scenario.zones:
            compression = self._check_crowd_compression(entities, zone, timestamp)
            if compression:
                anomalies.append(compression)
        
        # 2. Speed Violations (Kinetics)
        speed_anomalies = self._check_speed_anomalies(entities, timestamp)
        anomalies.extend(speed_anomalies)
        
        # 3. Loitering (Atmospherics)
        loitering = self._check_loitering(entities, timestamp)
        anomalies.extend(loitering)
        
        # 4. Restricted Zone Entry (Geographics)
        trespass = self._check_restricted_zones(entities, scenario, timestamp)
        anomalies.extend(trespass)
        
        # Apply Rule of Three
        anomalies = self._apply_rule_of_three(anomalies, timestamp)
        
        return anomalies
    
    def _check_crowd_compression(self, entities: List[Dict], zone, timestamp: float) -> Optional[Dict]:
        """Detect crowd compression/crush risk."""
        # Filter entities in this zone
        entities_in_zone = [
            e for e in entities 
            if self._entity_in_zone(e, zone)
        ]
        
        if not entities_in_zone:
            return None
        
        # Calculate density
        area = zone.area
        density = len(entities_in_zone) / area
        
        # Get baseline
        baseline_key = f"{zone.name}_density"
        baseline_density = self.baselines.get(baseline_key, 0.5)
        
        # Threshold: 2.5× baseline or >4 people/m² (crowd crush risk)
        threshold = max(baseline_density * 2.5, 4.0)
        
        if density > threshold:
            severity = 'CRITICAL' if density > 6.0 else 'HIGH'
            
            return {
                'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                'type': 'GEOGRAPHICS',
                'subtype': 'CROWD_COMPRESSION',
                'severity': severity,
                'scenario': 'CRUSH',
                'headline': f'{zone.name} Crowd Compression Risk',
                'description': f'Density {density:.1f} people/m², {density/baseline_density:.1f}× baseline',
                'baselineText': f'Normal density: {baseline_density:.1f} people/m²',
                'anomalyText': f'Current density: {density:.1f} people/m² ({len(entities_in_zone)} in {area:.0f}m²)',
                'zone': zone.name,
                'location': zone.center if hasattr(zone, 'center') else {'x': 0, 'y': 0, 'z': 0},
                'entityIds': [e['id'] for e in entities_in_zone],
                'metrics': {
                    'baselineDelta': ((density / baseline_density) - 1) * 100,
                    'confidence': 0.95,
                    'riskScore': min(density * 15, 100)
                },
                'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                'ruleOfThreeHit': False
            }
        
        return None
    
    def _check_speed_anomalies(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect excessive speed violations."""
        anomalies = []
        
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            vel = entity.get('velocity', {'x': 0, 'y': 0, 'z': 0})
            speed = np.sqrt(vel['x']**2 + vel['y']**2)  # Horizontal speed
            
            # Thresholds based on role
            role = entity.get('role', 'SPECTATOR')
            if role == 'PLAYER':
                max_speed = 10.0  # m/s (fast sprinting)
            elif role == 'OFFICIAL':
                max_speed = 5.0   # m/s
            else:
                max_speed = 2.0   # m/s (walking speed for spectators)
            
            if speed > max_speed * 1.5:  # 1.5× threshold
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'KINETICS',
                    'subtype': 'SPEED_VIOLATION',
                    'severity': 'MEDIUM',
                    'headline': f'Excessive Speed: {entity["id"]}',
                    'description': f'Entity moving at {speed:.1f} m/s, {(speed/max_speed):.1f}× expected',
                    'baselineText': f'Expected max speed: {max_speed:.1f} m/s for {role}',
                    'anomalyText': f'Current speed: {speed:.1f} m/s',
                    'zone': 'UNKNOWN',  # TODO: Determine zone from position
                    'location': entity['position'],
                    'entityIds': [entity['id']],
                    'metrics': {
                        'baselineDelta': ((speed / max_speed) - 1) * 100,
                        'confidence': 0.88,
                        'riskScore': min(speed * 8, 100)
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
        
        return anomalies
    
    def _check_loitering(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect loitering patterns (entities staying in same small area for too long)."""
        anomalies = []
        
        # Initialize history if not present
        if not hasattr(self, 'position_history'):
            self.position_history = {} # entity_id -> list of (timestamp, pos)
            
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            eid = entity['id']
            pos = entity['position']
            
            # Update history
            if eid not in self.position_history:
                self.position_history[eid] = []
                
            self.position_history[eid].append((timestamp, pos))
            
            # Prune old history (> 60 seconds)
            cutoff = timestamp - 60.0
            self.position_history[eid] = [p for p in self.position_history[eid] if p[0] > cutoff]
            
            # Check for loitering if we have enough data (e.g. > 10 seconds)
            history = self.position_history[eid]
            if len(history) < 30: # Assuming ~3fps check rate, need 10s
                continue
                
            # Calculate bounding box of movement over last window
            xs = [p[1]['x'] for p in history]
            ys = [p[1]['y'] for p in history]
            
            if not xs or not ys:
                continue
                
            x_range = max(xs) - min(xs)
            y_range = max(ys) - min(ys)
            
            # If stayed within 3m box for > 15s (approx len check)
            if x_range < 3.0 and y_range < 3.0 and (history[-1][0] - history[0][0]) > 15.0:
                # Check if already flagged recently to avoid spam is hard without state, 
                # but Rule of Three handles clustering.
                
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'ATMOSPHERICS',
                    'subtype': 'LOITERING',
                    'severity': 'LOW',
                    'headline': f'Loitering Detected: {eid}',
                    'description': f'Entity remained in 3m radius for > 15s',
                    'baselineText': 'Normal transit time: < 10s',
                    'anomalyText': f'Stationary duration: {history[-1][0] - history[0][0]:.1f}s',
                    'zone': 'UNKNOWN', 
                    'location': pos,
                    'entityIds': [eid],
                    'metrics': {
                        'baselineDelta': 50,
                        'confidence': 0.85,
                        'riskScore': 40
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
                
        return anomalies
    
    def _check_restricted_zones(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """Detect entities entering restricted zones."""
        anomalies = []
        
        restricted_zones = [z for z in scenario.zones if z.type == 'RESTRICTED']
        
        for zone in restricted_zones:
            for entity in entities:
                if entity.get('role') == 'PLAYER':
                    continue  # Players allowed in restricted zones
                    
                if self._entity_in_zone(entity, zone):
                    anomalies.append({
                        'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                        'type': 'GEOGRAPHICS',
                        'subtype': 'RESTRICTED_ZONE_ENTRY',
                        'severity': 'HIGH',
                        'headline': f'Unauthorized Entry: {zone.name}',
                        'description': f'{entity["id"]} entered restricted zone',
                        'baselineText': f'Zone {zone.name} is restricted',
                        'anomalyText': f'{entity["role"]} entity detected in zone',
                        'zone': zone.name,
                        'location': entity['position'],
                        'entityIds': [entity['id']],
                        'metrics': {
                            'baselineDelta': 100,
                            'confidence': 0.92,
                            'riskScore': 75
                        },
                        'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                        'ruleOfThreeHit': False
                    })
        
        return anomalies
    
    def _apply_rule_of_three(self, anomalies: List[Dict], timestamp: float) -> List[Dict]:
        """
        Apply Rule of Three: flag when 3+ independent anomaly types
        converge in same space-time.
        """
        # Group anomalies by proximity
        spatial_threshold = 10.0  # meters
        temporal_threshold = 30.0  # seconds
        
        groups = []
        for anomaly in anomalies:
            placed = False
            for group in groups:
                # Check if anomaly belongs to this group
                representative = group[0]
                
                # Spatial proximity
                loc1 = anomaly['location']
                loc2 = representative['location']
                dist = np.sqrt(
                    (loc1['x'] - loc2['x'])**2 + 
                    (loc1['y'] - loc2['y'])**2
                )
                
                # Temporal proximity
                time_diff = abs(
                    anomaly['occurredAt'].timestamp() - 
                    representative['occurredAt'].timestamp()
                )
                
                if dist < spatial_threshold and time_diff < temporal_threshold:
                    group.append(anomaly)
                    placed = True
                    break
            
            if not placed:
                groups.append([anomaly])
        
        # Check each group for Rule of Three
        for group in groups:
            distinct_types = set(a['type'] for a in group)
            
            if len(distinct_types) >= 3:
                # Mark all anomalies in group
                for anomaly in group:
                    anomaly['ruleOfThreeHit'] = True
                    anomaly['severity'] = 'CRITICAL'  # Escalate
                    anomaly['relatedAnomalies'] = [
                        a['anomalyId'] for a in group if a != anomaly
                    ]
        
        return anomalies
    
    def _update_baselines(self, entities: List[Dict], scenario):
        """Update baseline metrics using exponential moving average."""
        # TODO: Implement proper baseline learning
        # For now, use static baselines
        for zone in scenario.zones:
            baseline_key = f"{zone.name}_density"
            if baseline_key not in self.baselines:
                self.baselines[baseline_key] = 1.0  # 1 person/m² default
    
    def _entity_in_zone(self, entity: Dict, zone) -> bool:
        """Check if entity is inside zone bounds."""
        pos = entity['position']
        bounds = zone.bounds  # (x_min, y_min, x_max, y_max)
        
        return (
            bounds[0] <= pos['x'] <= bounds[2] and
            bounds[1] <= pos['y'] <= bounds[3]
        )

```

#### simulation\src\api\server.py
```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import uvicorn
import os

from src.core.orchestrator import SimulationOrchestrator

orchestrator = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global orchestrator
    # Initialize with default config
    orchestrator = SimulationOrchestrator({})
    print("Simulation Engine Starting...")
    yield
    # Shutdown
    if orchestrator:
        orchestrator.stop()
    print("Simulation Engine Stopping...")

app = FastAPI(lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "simulation-engine"}

@app.post("/simulation/start")
async def start_simulation(config: dict):
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.load_scenario(config.get('sport', 'BASKETBALL'), config)
    orchestrator.start()
    return {"status": "started"}

@app.post("/simulation/stop")
async def stop_simulation():
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.stop()
    return {"status": "stopped"}

@app.get("/nodes/{node_id}/stream")
async def get_stream(node_id: str):
    if not orchestrator:
        raise HTTPException(status_code=503, detail="Orchestrator not initialized")
    
    return StreamingResponse(
        orchestrator.get_video_stream(node_id), 
        media_type="multipart/x-mixed-replace; boundary=frame"
    )

@app.get("/simulation/status")
async def get_status():
    if not orchestrator:
        return {"running": False, "error": "Orchestrator not initialized"}
    
    return {
        "running": orchestrator.running,
        "paused": orchestrator.paused,
        "active_scenario": orchestrator.scenario.sport if orchestrator.scenario else None,
        "fps": getattr(orchestrator, 'actual_fps', 0),
        "target_fps": getattr(orchestrator, 'target_fps', 30),
        "entity_count": len(orchestrator.entities)
    }

@app.patch("/simulation/config")
async def update_config(config: dict):
    if not orchestrator:
         return {"error": "Orchestrator not initialized"}
    
    if 'targetFps' in config:
        orchestrator.target_fps = config['targetFps']
    
    if 'anomalyRate' in config and hasattr(orchestrator, 'anomaly_generator'):
        orchestrator.anomaly_generator.anomaly_rate = config['anomalyRate']

    return {"status": "updated", "config": config}

@app.post("/nodes/{node_id}/calibrate")
async def calibrate_node(node_id: str):
    """Simulate calibration for a node."""
    if not orchestrator:
         raise HTTPException(status_code=503, detail="Orchestrator not initialized")
    
    import random
    import time
    return {
        "nodeId": node_id,
        "calibration": {
            "reprojectionError": random.uniform(0.01, 0.05),
            "status": "SUCCESS",
            "timestamp": time.time()
        }
    }

@app.get("/")
async def root():
    return {"message": "Motion Intelligence Simulation Engine v1.0"}

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("src.api.server:app", host="0.0.0.0", port=port, reload=True)

```

#### simulation\src\calibration\utils.py
```python
import numpy as np

def generate_default_calibration():
    # Intrinsic (Camera)
    # 1920x1080, FOV ~90 deg
    fx = 1000
    fy = 1000
    cx = 960
    cy = 540
    camera_matrix = [
        [fx, 0, cx],
        [0, fy, cy],
        [0, 0, 1]
    ]
    
    # Extrinsic (Identity for now)
    rotation = np.eye(3).tolist()
    translation = [0, 0, 0]
    
    # Lidar to Camera (Example: Camera is 10cm above LIDAR)
    lidar_to_camera = np.eye(4)
    lidar_to_camera[1, 3] = -0.1 # y-axis translation
    
    return {
        'intrinsic': {
            'cameraMatrix': camera_matrix,
            'distortion': [0, 0, 0, 0, 0]
        },
        'extrinsic': {
            'rotationMatrix': rotation,
            'translationVector': translation
        },
        'lidarToCameraTransform': lidar_to_camera.tolist(),
        'calibrationQuality': 100,
        'calibratedAt': '2025-12-16T12:00:00Z'
    }

```

#### simulation\src\core\orchestrator.py
```python
import os
import time
import threading
from typing import List, Optional, Dict
import numpy as np

from .physics_engine import PhysicsEngine
from .scenario_manager import ScenarioManager
from ..nodes.edge_node import EdgeNode
from ..anomalies.generator import AnomalyGenerator
from ..utils.ptp_sync import PTPClock

class SimulationOrchestrator:
    def __init__(self, config: dict):
        self.config = config
        self.running = False
        self.paused = False
        self.thread = None
        
        # Core components
        self.physics_engine = PhysicsEngine()
        self.scenario = None
        self.anomaly_generator = AnomalyGenerator()
        self.clock = PTPClock(is_master=True)
        
        # State
        self.nodes: List[EdgeNode] = []
        self.entities: List[Dict] = []
        self.current_time = 0.0
        self.frame_count = 0
        self.target_fps = 30
        self.actual_fps = 0.0
        
    def load_scenario(self, sport: str, config: dict):
        """Load sport-specific scenario."""
        self.scenario = ScenarioManager.create_scenario(sport, config)
        self.scenario.initialize(self.entities)
        print(f"Loaded scenario: {sport} with {len(self.entities)} entities")
        
    def add_node(self, node_config: dict) -> EdgeNode:
        """Add a sensor node to the simulation."""
        node = EdgeNode(
            node_id=node_config['nodeId'],
            position=np.array([
                node_config['position']['x'],
                node_config['position']['y'],
                node_config['position']['z']
            ]),
            orientation=np.array([
                node_config['orientation']['pitch'],
                node_config['orientation']['yaw'],
                node_config['orientation']['roll']
            ]),
            sensors=node_config['sensors'],
            calibration=node_config.get('calibration', {})
        )
        self.nodes.append(node)
        print(f"Added node: {node_config['nodeId']}")
        return node
        
    def start(self):
        """Start the simulation loop."""
        if self.running:
            return
            
        if not self.scenario:
            # Fallback for empty start
            try:
                self.load_scenario('BASKETBALL', {})
            except:
                print("Failed to load default scenario")
            
        self.running = True
        self.paused = False
        self.thread = threading.Thread(target=self._loop, daemon=True)
        self.thread.start()
        print("Simulation started")
        
    def stop(self):
        """Stop the simulation."""
        self.running = False
        if self.thread:
            self.thread.join()
        print("Simulation stopped")
        
    def pause(self):
        """Pause the simulation."""
        self.paused = True
        
    def resume(self):
        """Resume the simulation."""
        self.paused = False
        
    def _loop(self):
        """Main simulation loop - runs at 30 FPS."""
        target_dt = 1.0 / self.target_fps
        last_fps_check = time.time()
        fps_frame_count = 0
        
        while self.running:
            if self.paused:
                time.sleep(0.1)
                continue
                
            loop_start = time.time()
            
            # 1. Update simulation time (PTP clock)
            self.current_time = self.clock.get_time() / 1e9  # Convert ns to seconds
            
            # 2. Update entity behaviors (scenario-specific)
            if self.scenario:
                self.scenario.update(self.entities, target_dt)
            
            # 3. Update physics (entity movement)
            self.physics_engine.step(self.entities, target_dt)
            
            # 4. Generate sensor data from all nodes
            # For this MVP, we just generate generating logs or frames
            # Logic to publish via WebSocket would go here
            # 4. Generate sensor data from all nodes
            for node in self.nodes:
                # This updates internal buffers like last_camera_frame
                node.generate_frame(
                    entities=self.entities,
                    timestamp=self.current_time
                )
            
            # 5. Detect anomalies
            if self.scenario:
                anomalies = self.anomaly_generator.detect(
                    entities=self.entities,
                    scenario=self.scenario,
                    timestamp=self.current_time
                )
                for anomaly in anomalies:
                    self._publish_anomaly(anomaly)
            
            # 6. Update frame counter
            self.frame_count += 1
            fps_frame_count += 1
            
            # 7. Calculate actual FPS every second
            now = time.time()
            if now - last_fps_check >= 1.0:
                self.actual_fps = fps_frame_count / (now - last_fps_check)
                fps_frame_count = 0
                last_fps_check = now
                # print(f"Simulation FPS: {self.actual_fps:.1f} | Entities: {len(self.entities)}")
            
            # 8. Sleep to maintain frame rate
            elapsed = time.time() - loop_start
            if elapsed < target_dt:
                time.sleep(target_dt - elapsed)
                
            # Broadcast updates (Every 3 frames approx 10Hz)
            if self.frame_count % 3 == 0:
                self._publish_entities()

    def _publish_entities(self):
        """Send entity positions to API."""
        try:
            # Basic validation
            if not self.entities:
                return

            payload = {
                'sessionId': None, # TODO: Pass session ID if managed
                'stats': {
                    'fps': self.actual_fps,
                    'frame': self.frame_count,
                    'time': self.current_time
                },
                'sentAt': time.time(),
                'entities': [
                    {
                        'id': e.get('id'),
                        'type': e.get('type'),
                        'role': e.get('role'),
                        'team': e.get('team'),
                        'position': e.get('position'),
                        'velocity': e.get('velocity'),
                        'color': e.get('color'),
                        'radius': e.get('radius'),
                        'severity': e.get('severity')
                    }
                    for e in self.entities
                ]
            }
            
            # Fire and forget POST
            # Using threads or async here would be better for performance, 
            # but for this simulation loop strictness, a short timeout is acceptable logic 
            # if we assume local network.
            try:
                import requests
                api_url = os.getenv('API_URL', 'http://api:3001')
                response = requests.post(
                    f"{api_url}/internal/entity-update",
                    json=payload,
                    timeout=0.2 
                )
                if response.status_code != 200:
                    print(f"Warning: API returned status {response.status_code} for entity-update")
            except ImportError:
                print("requests module not found")
            except Exception as e:
                # print(f"Failed to publish entities: {e}")
                pass # Still suppress to avoid loop crash, but could log periodically
                
        except Exception as e:
            print(f"Error publishing entities: {e}")

    def _publish_anomaly(self, anomaly):
        """Publish detected anomaly."""
        try:
            import requests
            requests.post(
                f"{os.getenv('API_URL', 'http://api:3001')}/internal/anomaly",
                json={
                    'sessionId': None,
                    'anomaly': anomaly
                },
                timeout=0.1
            )
        except Exception as e:
            print(f"Failed to publish anomaly: {e}")

    def get_video_stream(self, node_id: str):
        """Generator for MJPEG stream from a specific node."""
        node = next((n for n in self.nodes if n.node_id == node_id), None)
        if not node:
            return

        while self.running:
            frame = node.last_camera_frame
            if frame:
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
            
            # rate limit to approx 30 fps to avoid busy loop
            time.sleep(0.033)



```

#### simulation\src\core\physics_engine.py
```python
import numpy as np
from typing import List

class PhysicsEngine:
    def __init__(self):
        self.gravity = -9.81
        self.friction_coeff = 0.5

    def step(self, entities: List[dict], dt: float):
        """
        Update entity positions based on velocity and forces.
        """
        for entity in entities:
            # Simple Euler integration
            vel = np.array(entity.get('velocity', [0, 0, 0]), dtype=float)
            pos = np.array(entity.get('position', [0, 0, 0]), dtype=float)
            
            # Apply friction (damping)
            vel = vel * (1.0 - self.friction_coeff * dt)
            
            # Update position
            pos += vel * dt
            
            # Floor constraint (z >= 0)
            if pos[2] < 0:
                pos[2] = 0
                vel[2] = 0
            
            # Update entity state
            entity['position'] = {
                'x': float(pos[0]),
                'y': float(pos[1]),
                'z': float(pos[2])
            }
            entity['velocity'] = {
                'x': float(vel[0]),
                'y': float(vel[1]),
                'z': float(vel[2])
            }

```

#### simulation\src\core\scenario_manager.py
```python
from typing import List, Dict, Optional
import numpy as np

class Zone:
    def __init__(self, name: str, bounds: tuple, area: float, type: str):
        self.name = name
        self.bounds = bounds # (x_min, y_min, x_max, y_max)
        self.area = area
        self.type = type
        self.center = {
            'x': (bounds[0] + bounds[2]) / 2,
            'y': (bounds[1] + bounds[3]) / 2,
            'z': 0
        }

class Scenario:
    def __init__(self):
        self.zones: List[Zone] = []
        self.entities: List[dict] = []
        self.sport = 'UNKNOWN'

    def initialize(self, entities: List[dict]):
        """Populate initial entities"""
        pass

    def update(self, entities: List[dict], dt: float):
        """Update entity behaviors"""
        pass

class ScenarioManager:
    @staticmethod
    def create_scenario(sport: str, config: dict) -> Scenario:
        if sport == 'BASKETBALL':
            from ..sports.basketball import BasketballScenario
            return BasketballScenario(config)
        else:
            raise ValueError(f"Unknown sport: {sport}")

```

#### simulation\src\nodes\camera_simulator.py
```python
import numpy as np
import cv2
import time
from typing import List, Tuple, Optional

class CameraSimulator:
    def __init__(self, resolution: dict, fps: int, fov: float):
        self.width = resolution['width']
        self.height = resolution['height']
        self.fps = fps
        self.fov = fov
        self.last_frame_time = 0
        self.frame_interval = 1.0 / fps

    def render(self, entities: List[dict], timestamp: float) -> Optional[bytes]:
        """
        Render a frame if enough time has passed.
        Returns JPEG bytes or None.
        """
        # Simple frame rate control
        if timestamp - self.last_frame_time < self.frame_interval:
            return None
            
        self.last_frame_time = timestamp
        
        # Create blank image (dark gray background)
        image = np.full((self.height, self.width, 3), 30, dtype=np.uint8)
        
        # Draw entities (simplified 2D projection for now)
        for entity in entities:
             # Basic projection logic (placeholder)
             # In a real 3D sim, we'd use a projection matrix
             pos = entity.get('position', {'x':0, 'y':0, 'z':0})
             
             # Map x/y to screen coordinates (very rough approx)
             cx = int(self.width / 2 + pos['x'] * 50) 
             cy = int(self.height / 2 + pos['y'] * 50)
             
             if 0 <= cx < self.width and 0 <= cy < self.height:
                 cv2.circle(image, (cx, cy), 10, (0, 255, 0), -1)
                 cv2.putText(image, entity.get('id', '?'), (cx+15, cy), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        # Add noise
        noise = np.random.normal(0, 5, image.shape).astype(np.uint8)
        image = cv2.add(image, noise)
        
        # Encode to JPEG
        _, encoded = cv2.imencode('.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 80])
        return encoded.tobytes()

```

#### simulation\src\nodes\edge_node.py
```python
from typing import List, Dict, Any
import numpy as np
from .camera_simulator import CameraSimulator
from .lidar_simulator import LidarSimulator
from .imu_simulator import IMUSimulator

class EdgeNode:
    def __init__(self, node_id: str, position: np.ndarray, orientation: np.ndarray, sensors: dict, calibration: dict):
        self.node_id = node_id
        self.position = position
        self.orientation = orientation
        self.calibration = calibration
        self.last_camera_frame = None
        
        # Initialize Sensors
        self.camera = None
        if sensors.get('camera', {}).get('enabled'):
            cam_config = sensors['camera']
            self.camera = CameraSimulator(
                resolution=cam_config.get('resolution', {'width': 1920, 'height': 1080}),
                fps=cam_config.get('fps', 30),
                fov=cam_config.get('fov', 90)
            )
            
        self.lidar = None
        if sensors.get('lidar', {}).get('enabled'):
            lid_config = sensors['lidar']
            self.lidar = LidarSimulator(
                model=lid_config.get('model', 'VLP-16'),
                channels=lid_config.get('channels', 16),
                range_m=lid_config.get('range', 100)
            )
            
        self.imu = None
        if sensors.get('imu', {}).get('enabled'):
            self.imu = IMUSimulator(sample_rate=100)

    def generate_frame(self, entities: List[dict], timestamp: float) -> Dict[str, Any]:
        """Generate a synchronized frame from all enabled sensors."""
        frame = {
            'nodeId': self.node_id,
            'timestamp': timestamp,
            'sensors': {}
        }
        
        # Transform entities to node-local coordinates if needed
        # For now, simulators handle global entities
        
        if self.camera:
            image_data = self.camera.render(entities, timestamp)
            if image_data:
                frame['sensors']['camera'] = image_data # In real app, this would be a path or heavy blob
                self.last_camera_frame = image_data
        
        if self.lidar:
            point_cloud = self.lidar.scan(entities, timestamp)
            frame['sensors']['lidar'] = point_cloud # Numpy array
            
        if self.imu:
            imu_data = self.imu.read(timestamp, self.position) # Simplified IMU read
            frame['sensors']['imu'] = imu_data
            
        return frame

```

#### simulation\src\nodes\fusion_engine.py
```python
import numpy as np
from typing import List, Dict

class FusionEngine:
    """
    Fuses camera + LIDAR data at edge node.
    Core learning objective: demonstrates sensor fusion concepts.
    """
    
    def __init__(self, camera_matrix=None, lidar_to_camera_transform=None):
        # Defaults if not provided
        self.camera_matrix = camera_matrix if camera_matrix is not None else np.eye(3)
        self.transform = lidar_to_camera_transform if lidar_to_camera_transform is not None else np.eye(4)
        
    def _project_lidar_to_image(self, points):
        """Project 3D LIDAR points to 2D camera coordinates."""
        if len(points) == 0:
            return np.array([])
            
        # 1. Transform Lidar -> Camera frame
        # We assume standard Camera frame: X right, Y down, Z forward
        # Simple simulation hack: rotate points to align with camera Z
        # R_lidar_cam = np.array([[0, -1, 0], [0, 0, -1], [1, 0, 0]])
        # points_cam = points @ R_lidar_cam.T + np.array([0, 0, 0])
        
        # For simplicity in this demo, treat world X,Y as 'flat' image plane scaling
        focal_length = 1000
        
        u = focal_length * (points[:, 0] / (points[:, 1] + 1e-6)) + 960  # Center X
        v = focal_length * (points[:, 2] / (points[:, 1] + 1e-6)) + 540  # Center Y (Z is up in input, Y down in image)
        
        # Filter points behind camera (Y < 0)
        valid_mask = points[:, 1] > 0
        
        projected = np.zeros((len(points), 3))
        projected[:, 0] = u
        projected[:, 1] = v
        projected[:, 2] = valid_mask
        
        return projected

    def _iou(self, point, bbox):
        """Check if point is inside bbox."""
        x, y = point[0], point[1]
        x1, y1, x2, y2 = bbox
        return x1 <= x <= x2 and y1 <= y <= y2

    def fuse(self, camera_image, lidar_points, entities):
        """
        Perform fusion of camera and LIDAR data.
        Returns: List of detected entities with 3D positions derived from LIDAR clusters.
        """
        detections = []
        
        # 1. Project LIDAR points to camera image
        projected_points_2d = self._project_lidar_to_image(lidar_points[:, :3])
        
        # 2. Run 2D object detection (Simulated)
        bboxes = self._detect_objects_2d(camera_image, entities)
        
        # 3. Associate and Fuse
        for bbox_data in bboxes:
            bbox = bbox_data['bbox']
            
            # Find points inside this bbox
            points_inside_indices = []
            for i, pt in enumerate(projected_points_2d):
                if pt[2] > 0 and self._iou(pt, bbox): # Check validity and bounds
                    points_inside_indices.append(i)
            
            # Fuse: Compute centroid of associated LIDAR points
            if points_inside_indices:
                cluster = lidar_points[points_inside_indices]
                fused_pos = np.mean(cluster[:, :3], axis=0)
                confidence = 0.9 + (len(points_inside_indices) / 100.0) # More points = higher confidence
            else:
                # Fallback if no LIDAR hits (e.g. occlusion): use purely visual estimate or prior
                # For simulaton, fallback to entity truth + large noise
                target_entity = next((e for e in entities if e['id'] == bbox_data['entity_id']), None)
                if target_entity:
                    pos = target_entity['position']
                    fused_pos = np.array([pos['x'], pos['y'], pos['z']]) + np.random.normal(0, 0.5, 3)
                    confidence = 0.5
                else:
                    continue

            detections.append({
                'entityId': bbox_data['entity_id'],
                'position3d': fused_pos.tolist(),
                'velocity': [0, 0, 0], # Kalman filter would determine this over time
                'confidence': min(confidence, 1.0),
                'bbox2d': bbox
            })
        
        return detections

    def _detect_objects_2d(self, image, entities):
        """Simulate YOLO detection."""
        bboxes = []
        for entity in entities:
            # Simple manual projection for bounding box simulation
            pos = entity['position']
            # Scale world coords to 'pixel' coords roughly
            cx = 960 + (pos['x'] * 50) 
            cy = 540 - (pos['z'] * 50) 
            w, h = 60 / (pos['y']*0.1 + 1), 120 / (pos['y']*0.1 + 1)
            
            bboxes.append({
                'entity_id': entity['id'],
                'bbox': [cx - w/2, cy - h/2, cx + w/2, cy + h/2],
                'confidence': 0.95
            })
        return bboxes

```

#### simulation\src\nodes\imu_simulator.py
```python
import numpy as np

class IMUSimulator:
    def __init__(self, sample_rate: int):
        self.sample_rate = sample_rate
        self.accel_bias = np.random.normal(0, 0.01, 3)
        self.gyro_bias = np.random.normal(0, 0.001, 3)

    def sample(self, timestamp: float, motion: dict) -> dict:
        """
        Generate IMU reading based on actual motion.
        """
        true_accel = motion.get('acceleration', np.zeros(3))
        true_gyro = motion.get('angular_velocity', np.zeros(3))
        
        # Add noise and bias
        accel_noise = np.random.normal(0, 0.01, 3)
        gyro_noise = np.random.normal(0, 0.001, 3)
        
        accel = true_accel + self.accel_bias + accel_noise
        gyro = true_gyro + self.gyro_bias + gyro_noise
        
        # Add gravity (assuming z is up)
        accel[2] += 9.81
        
        return {
            'acceleration': accel.tolist(),
            'gyroscope': gyro.tolist(),
            'temperature': 45.0 + np.random.normal(0, 0.1)
        }

```

#### simulation\src\nodes\lidar_simulator.py
```python
import numpy as np
from typing import List, Tuple

class LidarSimulator:
    def __init__(self, model: str, channels: int, range_m: float):
        self.model = model
        self.channels = channels
        self.range = range_m
        self.points_per_second = 300000

    def scan(self, entities: List[dict], timestamp: float) -> np.ndarray:
        """
        Generate a point cloud.
        Returns numpy array of (x, y, z, intensity).
        """
        # Generate background points (ground plane)
        # Simplified: Grid of points
        x = np.linspace(-20, 20, 100)
        y = np.linspace(-20, 20, 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X) # Ground is at z=0
        
        # Flatten
        ground_points = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1)
        
        entity_points = []
        for entity in entities:
            pos = entity.get('position', {'x':0, 'y':0, 'z':0})
            # Generate a cluster of points for the entity
            num_points = 50
            # Gaussian distribution around entity position
            ep = np.random.normal([pos['x'], pos['y'], pos['z']], 0.2, (num_points, 3))
            entity_points.append(ep)
            
        if entity_points:
            all_entity_points = np.vstack(entity_points)
            points = np.vstack([ground_points, all_entity_points])
        else:
            points = ground_points

        # Add intensity (random for now)
        intensities = np.random.rand(len(points), 1)
        
        return np.hstack([points, intensities]).astype(np.float32)

```

#### simulation\src\sports\basketball.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class BasketballScenario(Scenario):
    """NBA-style basketball simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'BASKETBALL'
        
        # Court dimensions (NBA standard in meters)
        self.court_length = 28.65
        self.court_width = 15.24
        
        # Zones
        self.zones = [
            Zone(
                name='COURT',
                bounds=self._court_bounds(),
                area=self.court_length * self.court_width,
                type='FIELD'
            ),
            Zone(
                name='HOME_BENCH',
                bounds=(0, 0, 5, 2),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='AWAY_BENCH',
                bounds=(0, self.court_width - 2, 5, self.court_width),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='PAINT_HOME',
                bounds=(0, self.court_width/2 - 2.44, 5.8, self.court_width/2 + 2.44),
                area=28.3,
                type='RESTRICTED'
            )
        ]
        
        self.crowd_count = config.get('crowdCount', 5000) if config else 5000
        
    def initialize(self, entities: List[Dict]):
        """Set up players, refs, ball, crowd."""
        
        # Home team (5 players)
        for i in range(5):
            pos = self._get_formation_position('HOME', i)
            entity = {
                'id': f'HOME_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'HOME',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (255, 0, 0),  # Red
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Away team (5 players)
        for i in range(5):
            pos = self._get_formation_position('AWAY', i)
            entity = {
                'id': f'AWAY_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'AWAY',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (0, 0, 255),  # Blue
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Referees (3)
        for i in range(3):
            entity = {
                'id': f'REF_{i+1}',
                'type': 'PERSON',
                'role': 'OFFICIAL',
                'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 1.8,
                'color': (128, 128, 128),  # Gray
                'reflectance': 0.4,
                'behavior': 'referee'
            }
            entities.append(entity)
        
        # Basketball
        entity = {
            'id': 'BALL',
            'type': 'OBJECT',
            'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 1.5},
            'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
            'radius': 0.12,
            'color': (255, 165, 0),  # Orange
            'reflectance': 0.6
        }
        entities.append(entity)
        
        # Crowd (simplified - grouped entities)
        self._generate_crowd(entities, self.crowd_count)
        
        print(f"Basketball scenario initialized: {len(entities)} entities")
        
    def update(self, entities: List[Dict], dt: float):
        """Update entity behaviors each frame."""
        for entity in entities:
            behavior = entity.get('behavior')
            
            if behavior == 'basketball_player':
                self._update_player_behavior(entity, entities, dt)
            elif behavior == 'referee':
                self._update_referee_behavior(entity, entities, dt)
        
        # Update ball physics (bouncing, possession)
        self._update_ball(entities, dt)
        
    def _get_formation_position(self, team: str, index: int) -> tuple:
        """Get initial position for player in formation."""
        # Simple positioning - half court
        if team == 'HOME':
            x_base = self.court_length * 0.25
        else:
            x_base = self.court_length * 0.75
            
        # Spread players across court width
        y = (self.court_width / 6) * (index + 1)
        
        return (x_base, y)
        
    def _update_player_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Basic basketball player AI."""
        # Find ball
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Move towards ball (simplified)
        dx = ball['position']['x'] - entity['position']['x']
        dy = ball['position']['y'] - entity['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 0.5:  # Not at ball
            # Move towards ball
            speed = 3.0  # m/s
            entity['velocity']['x'] = (dx / dist) * speed
            entity['velocity']['y'] = (dy / dist) * speed
        else:
            # At ball - slow down
            entity['velocity']['x'] *= 0.5
            entity['velocity']['y'] *= 0.5
            
    def _update_referee_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Referee follows play."""
        # Similar to player but slower
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if ball:
            dx = ball['position']['x'] - entity['position']['x']
            dy = ball['position']['y'] - entity['position']['y']
            dist = np.sqrt(dx**2 + dy**2)
            
            if dist > 3.0:
                speed = 2.0
                entity['velocity']['x'] = (dx / dist) * speed
                entity['velocity']['y'] = (dy / dist) * speed
                
    def _update_ball(self, entities: List[Dict], dt: float):
        """Update ball physics."""
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Gravity
        ball['velocity']['z'] -= 9.81 * dt
        
        # Bounce on floor
        if ball['position']['z'] <= 0.12:  # Ball radius
            ball['position']['z'] = 0.12
            ball['velocity']['z'] = -ball['velocity']['z'] * 0.7  # Bounce with loss
            
    def _court_bounds(self) -> tuple:
        """Return (x_min, y_min, x_max, y_max)."""
        return (0, 0, self.court_length, self.court_width)
        
    def _generate_crowd(self, entities: List[Dict], count: int):
        """Generate crowd entities (simplified grouping)."""
        # Stands are outside court boundaries
        # Create grouped "crowd sections" rather than individual spectators
        num_sections = 8
        people_per_section = count // num_sections
        
        for i in range(num_sections):
            entity = {
                'id': f'CROWD_SECTION_{i+1}',
                'type': 'GROUP',
                'role': 'SPECTATOR',
                'count': people_per_section,
                'position': {
                    'x': np.random.uniform(-5, self.court_length + 5),
                    'y': np.random.uniform(-5, self.court_width + 5),
                    'z': 0.0
                },
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 2.0,  # Group radius
                'color': (100, 100, 200),
                'reflectance': 0.3
            }
            entities.append(entity)

```

#### simulation\src\sports\combat.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class CombatScenario(Scenario):
    """MMA/Boxing style simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'COMBAT'
        self.ring_size = 9.0 # meters
        
        self.zones = [
            Zone(name='RING', bounds=(0,0,self.ring_size,self.ring_size), area=81, type='RING'),
            Zone(name='RINGSIDE', bounds=(-2,-2,self.ring_size+2,self.ring_size+2), area=150, type='RESTRICTED')
        ]

    def initialize(self, entities: List[Dict]):
        # Fighter 1
        entities.append({
            'id': 'FIGHTER_1', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (255, 0, 0)
        })
        
        # Fighter 2
        entities.append({
            'id': 'FIGHTER_2', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size*2/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (0, 0, 255)
        })
        
        # Referee
        entities.append({
            'id': 'REF', 'type': 'PERSON', 'role': 'OFFICIAL',
            'position': {'x': self.ring_size/2, 'y': self.ring_size/4, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.75, 'color': (200, 200, 200)
        })

    def update(self, entities: List[Dict], dt: float):
        f1 = next(e for e in entities if e['id'] == 'FIGHTER_1')
        f2 = next(e for e in entities if e['id'] == 'FIGHTER_2')
        
        # Circle each other
        center_x = (f1['position']['x'] + f2['position']['x']) / 2
        center_y = (f1['position']['y'] + f2['position']['y']) / 2
        
        for f in [f1, f2]:
            dx = center_x - f['position']['x']
            dy = center_y - f['position']['y']
            # Add orbit logic here... simplified
            f['velocity']['x'] += (np.random.rand()-0.5) * 2.0
            f['velocity']['y'] += (np.random.rand()-0.5) * 2.0
            
            # Keep in ring
            next_x = f['position']['x'] + f['velocity']['x'] * dt
            next_y = f['position']['y'] + f['velocity']['y'] * dt
            
            if next_x < 0 or next_x > self.ring_size:
                f['velocity']['x'] *= -1
            if next_y < 0 or next_y > self.ring_size:
                f['velocity']['y'] *= -1

```

#### simulation\src\sports\soccer.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class SoccerScenario(Scenario):
    """FIFA-style soccer simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'SOCCER'
        
        # Field dimensions (Standard 105m x 68m)
        self.field_length = 105.0
        self.field_width = 68.0
        
        # Zones
        self.zones = [
            Zone(
                name='FIELD',
                bounds=(0, 0, self.field_length, self.field_width),
                area=self.field_length * self.field_width,
                type='FIELD'
            ),
             Zone(
                name='PENALTY_AREA_HOME',
                bounds=(0, self.field_width/2 - 20.15, 16.5, self.field_width/2 + 20.15),
                area=665.0, # Approx
                type='RESTRICTED'
            ),
             Zone(
                name='PENALTY_AREA_AWAY',
                bounds=(self.field_length - 16.5, self.field_width/2 - 20.15, self.field_length, self.field_width/2 + 20.15),
                area=665.0,
                type='RESTRICTED'
            )
        ]
        
    def initialize(self, entities: List[Dict]):
        # Home Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('HOME', i)
            entities.append(self._create_player(f'HOME_{i+1}', 'HOME', pos, (255, 0, 0)))

        # Away Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('AWAY', i)
            entities.append(self._create_player(f'AWAY_{i+1}', 'AWAY', pos, (0, 0, 255)))
            
        # Ball
        entities.append({
            'id': 'BALL', 'type': 'OBJECT', 
            'position': {'x': self.field_length/2, 'y': self.field_width/2, 'z': 0.11},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.11, 'color': (255, 255, 255)
        })

    def update(self, entities: List[Dict], dt: float):
        # Very simple AI: chase ball
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball: return
        
        for e in entities:
            if e.get('role') == 'PLAYER':
                self._update_player(e, ball, dt)

    def _create_player(self, pid, team, pos, color):
        return {
            'id': pid, 'type': 'PERSON', 'role': 'PLAYER', 'team': team,
            'position': {'x': pos[0], 'y': pos[1], 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.8, 'color': color, 'behavior': 'soccer_player'
        }

    def _get_formation_position(self, team, index):
        # 4-4-2 Formation stub
        base_x = 10 if team == 'HOME' else self.field_length - 10
        direction = 1 if team == 'HOME' else -1
        
        if index == 0: # GK
            return (base_x, self.field_width/2)
        elif index < 5: # Defenders
            return (base_x + 15*direction, self.field_width * (index/5))
        elif index < 9: # Midfielders
            return (base_x + 35*direction, self.field_width * ((index-4)/5))
        else: # Forwards
            return (base_x + 55*direction, self.field_width * ((index-8)/3))

    def _update_player(self, player, ball, dt):
        # Determine if this player is closest to ball for their team
        # In a full sim, we'd check all teammates.
        # For efficiency here, we'll just check distance vs fixed threshold
        
        dx_ball = ball['position']['x'] - player['position']['x']
        dy_ball = ball['position']['y'] - player['position']['y']
        dist_ball = np.sqrt(dx_ball**2 + dy_ball**2)
        
        # Calculate formation target
        pid_parts = player['id'].split('_')
        idx = int(pid_parts[1]) - 1 if len(pid_parts) > 1 else 0
        form_pos = self._get_formation_position(player['team'], idx)
        
        # Formation force
        dx_form = form_pos[0] - player['position']['x']
        dy_form = form_pos[1] - player['position']['y']
        dist_form = np.sqrt(dx_form**2 + dy_form**2)
        
        # Logic: If close to ball (within 15m), chase ball. Else, hold formation.
        if dist_ball < 15.0:
            target_dx, target_dy, target_dist = dx_ball, dy_ball, dist_ball
            speed = 5.0 # Sprint
        else:
            target_dx, target_dy, target_dist = dx_form, dy_form, dist_form
            speed = 2.0 # Jog
            
        if target_dist > 0.5:
            player['velocity']['x'] = (target_dx / target_dist) * speed
            player['velocity']['y'] = (target_dy / target_dist) * speed
        else:
            player['velocity']['x'] = 0
            player['velocity']['y'] = 0

```

#### simulation\src\utils\ptp_sync.py
```python
import time
import numpy as np

class PTPClock:
    """
    IEEE 1588 Precision Time Protocol simulation.
    Simulates clock drift and offset correction.
    """
    
    def __init__(self, is_master: bool = True):
        self.is_master = is_master
        self.epoch = time.time_ns()
        self.crystal_frequency = 1e9  # 1 GHz nominal
        # Simulate hardware clock drift (parts per million)
        self.ppm_drift = np.random.uniform(-30, 30) if not is_master else 0.0
        self.offset_ns = 0
        
    def get_time(self) -> int:
        """Get current PTP time in nanoseconds."""
        elapsed = time.time_ns() - self.epoch
        # Apply simulated drift
        drift_factor = 1.0 + (self.ppm_drift / 1e6)
        
        return int(elapsed * drift_factor) + self.offset_ns + self.epoch
    
    def get_time_sec(self) -> float:
        """Get current PTP time in seconds."""
        return self.get_time() / 1e9
    
    def sync_with_master(self, master_time: int):
        """Synchronize slave clock with master time sample."""
        if self.is_master:
            return
            
        current_time = self.get_time()
        offset = master_time - current_time
        
        # Simple PI controller for smooth clock discipline
        # In a real PTP stack this is much more complex
        self.offset_ns += int(offset * 0.5)

```

#### simulation\tests\test_camera_simulator.py
```python
import unittest
import numpy as np
from src.nodes.camera_simulator import CameraSimulator

class TestCameraSimulator(unittest.TestCase):
    def setUp(self):
        self.camera = CameraSimulator(
            resolution={'width': 1920, 'height': 1080},
            fps=30,
            fov=90
        )
    
    def test_render_returns_bytes_when_due(self):
        # Timestamp 0.0 -> should render
        # Timestamp 0.001 -> should NOT render (too soon for 30fps)
        
        entities = [{'id': 'E1', 'position': {'x': 0, 'y': 0, 'z': 5}}]
        
        # First frame
        frame1 = self.camera.render(entities, timestamp=1.0)
        self.assertIsNotNone(frame1)
        self.assertIsInstance(frame1, bytes)
        
        # Too soon
        frame2 = self.camera.render(entities, timestamp=1.01)
        self.assertIsNone(frame2)
        
        # Next frame due (approx 33ms later)
        frame3 = self.camera.render(entities, timestamp=1.04)
        self.assertIsNotNone(frame3)

if __name__ == '__main__':
    unittest.main()

```

#### simulation\tests\test_performance.py
```python
import time
import unittest
from src.core.orchestrator import SimulationOrchestrator

class TestPerformance(unittest.TestCase):
    def test_fps_stability(self):
        # This test ensures the loop runs at ~30 FPS
        # We'll just run a few iter and check time
        
        # Mock orchestrator behavior without threading for test
        orch = SimulationOrchestrator()
        
        start_time = time.time()
        frames = 30
        
        for i in range(frames):
            orch._generate_sensor_data()
            orch._detect_anomalies()
            time.sleep(1/30) # Simulate loop wait
            
        elapsed = time.time() - start_time
        fps = frames / elapsed
        
        print(f"Measured FPS: {fps}")
        self.assertTrue(25 < fps < 35, f"FPS {fps} out of range")

if __name__ == '__main__':
    unittest.main()

```

## 5. Frontend

#### frontend\Dockerfile
```
# Build Stage
FROM node:18-slim AS builder
WORKDIR /app
COPY package.json ./
RUN npm install
COPY . .
# Skip type check based on previous tsconfig relaxation, but run build
RUN npm run build

# Serve Stage
FROM node:18-slim
WORKDIR /app
RUN npm install -g serve
COPY --from=builder /app/dist ./dist
EXPOSE 80
CMD ["serve", "-s", "dist", "-l", "80"]

```

#### frontend\index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motion Intelligence Grid</title>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

#### frontend\package.json
```json
{
    "name": "motiongrid-frontend",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.1",
        "three": "^0.160.0",
        "@react-three/fiber": "^8.15.12",
        "@react-three/drei": "^9.92.4",
        "socket.io-client": "^4.6.2",
        "recharts": "^2.10.3",
        "axios": "^1.6.2",
        "date-fns": "^2.30.0",
        "zustand": "^4.4.7",
        "clsx": "^2.0.0",
        "tailwind-merge": "^2.1.0",
        "lucide-react": "^0.294.0",
        "class-variance-authority": "^0.7.0"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@types/three": "^0.160.0",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.3.6",
        "typescript": "^5.2.2",
        "vite": "^5.0.8"
    }
}
```

#### frontend\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "module": "ESNext",
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        /* Linting */
        "strict": false,
        "noImplicitAny": false,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": [
        "src"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
```

#### frontend\tsconfig.node.json
```json
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "vite.config.ts"
    ]
}
```

#### frontend\vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        host: true,
        allowedHosts: true, // Allow Cloud Run domains
        port: 5173,
        proxy: {
            '/api': {
                target: 'http://localhost:3001',
                changeOrigin: true
            }
        }
    }
})

```

#### frontend\src\App.tsx
```typescript
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AppShell } from './components/layout/AppShell';
import { AuthProvider, useAuth } from './context/AuthContext';
import { Login } from './views/Login';

import Dashboard from './views/Dashboard/Dashboard';
import SystemConfig from './views/SystemConfig/SystemConfig';

import { LiveMonitoring } from './views/LiveMonitoring/index';
import { SessionReplay } from './views/SessionReplay/SessionReplay';
import { AnalyticsDashboard } from './views/Analytics/AnalyticsDashboard';

import { PlaceholderView } from './components/common/PlaceholderView';

import { SessionsList } from './views/Sessions/SessionsList';
import { AnomalyTriage } from './views/Triage/AnomalyTriage';
import { EntityProfile } from './views/Entities/EntityProfile';
import { EntitiesList } from './views/Entities/EntitiesList';

const RequireAuth = ({ children }: { children: JSX.Element }) => {
    const { isAuthenticated } = useAuth();
    const location = useLocation();

    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }
    return children;
};

function App() {
    return (
        <AuthProvider>
            <Router>
                <Routes>
                    <Route path="/login" element={<Login />} />

                    <Route path="/*" element={
                        <RequireAuth>
                            <AppShell>
                                <Routes>
                                    <Route path="/" element={<Dashboard />} />
                                    <Route path="/live" element={<LiveMonitoring />} />
                                    <Route path="/replay/:id" element={<SessionReplay />} />
                                    <Route path="/analytics" element={<AnalyticsDashboard />} />
                                    <Route path="/config" element={<SystemConfig />} />

                                    {/* New Features - No Longer Placeholders */}
                                    <Route path="/sessions" element={<SessionsList />} />
                                    <Route path="/sessions/:id" element={<SessionReplay />} />
                                    <Route path="/triage" element={<AnomalyTriage />} />
                                    <Route path="/entities" element={<EntitiesList />} />
                                    <Route path="/entities/:id" element={<EntityProfile />} />

                                    <Route path="/automation" element={<PlaceholderView title="Automation Rules" />} />

                                    {/* Fallback */}
                                    <Route path="*" element={<PlaceholderView title="404: Page Not Found" description="The page you are looking for does not exist." />} />
                                </Routes>
                            </AppShell>
                        </RequireAuth>
                    } />
                </Routes>
            </Router>
        </AuthProvider>
    )
}

export default App

```

#### frontend\src\index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  background-color: #020617;
  /* navy-950 */
  color: #f8fafc;
  /* light text */
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
```

#### frontend\src\main.tsx
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

```

#### frontend\src\vite-env.d.ts
```typescript
/// <reference types="vite/client" />

```

#### frontend\src\components\common\PlaceholderView.tsx
```typescript
import React from 'react';
import { Construction } from 'lucide-react';
import { Card } from '../ui/Card';

interface PlaceholderViewProps {
    title: string;
    description?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
    title,
    description = "This feature is currently under development. Check back soon for updates."
}) => {
    return (
        <div className="p-6 h-full flex items-center justify-center">
            <Card className="max-w-md w-full p-8 text-center flex flex-col items-center gap-4 bg-navy-800 border-navy-700">
                <div className="w-16 h-16 bg-navy-900 rounded-full flex items-center justify-center border border-navy-700 shadow-inner">
                    <Construction className="w-8 h-8 text-primary-400" />
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white mb-2">{title}</h2>
                    <p className="text-slate-400 leading-relaxed">
                        {description}
                    </p>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\components\layout\AppShell.tsx
```typescript
import { Sidebar } from './Sidebar';
import { TopBar } from './TopBar';

interface AppShellProps {
    children: React.ReactNode;
}

export function AppShell({ children }: AppShellProps) {
    return (
        <div className="min-h-screen bg-navy-950 text-slate-200 font-sans selection:bg-secondary-500/30">
            <TopBar />
            <Sidebar />

            <main className="pl-[260px] pt-[80px] min-h-screen transition-all duration-300">
                <div className="max-w-[1920px] mx-auto p-6 animate-in fade-in duration-500 slide-in-from-bottom-4">
                    {children}
                </div>
            </main>
        </div>
    );
}

```

#### frontend\src\components\layout\Sidebar.tsx
```typescript
import {
    LayoutDashboard,
    Radio,
    Server,
    Settings,
    Bell,
    Search,
    Menu,
    Play,
    LayoutGrid,
    Activity,
    Video,
    BarChart3,
    Zap,
    AlertTriangle,
    Users,
    HelpCircle,
    LogOut
} from 'lucide-react';
import { NavLink } from 'react-router-dom';
import { cn } from '../../utils/cn';

const NAV_ITEMS = [
    { label: 'Overview', path: '/', icon: LayoutGrid },
    { label: 'Live Intelligence', path: '/live', icon: Activity },
    { label: 'Session Replay', path: '/replay/mock-session-1', icon: Play }, // Added for easy access
    { label: 'System Config', path: '/config', icon: Settings },
    { label: 'Sessions', path: '/sessions', icon: Video },
    { label: 'Analytics', path: '/analytics', icon: BarChart3 },
    { label: 'Automation', path: '/automation', icon: Zap },
    { label: 'Triage', path: '/triage', icon: AlertTriangle },
    { label: 'Entities', path: '/entities', icon: Users },
];

export function Sidebar() {
    return (
        <aside className="w-[260px] bg-navy-900 border-r border-navy-800 fixed left-0 top-0 bottom-0 pt-[80px] flex flex-col z-40">
            <div className="flex-1 overflow-y-auto py-6 px-3 space-y-1">
                <div className="text-xs font-bold text-slate-500 uppercase px-4 mb-2 tracking-wider">Menu</div>
                {NAV_ITEMS.map((item) => (
                    <NavLink
                        key={item.path}
                        to={item.path}
                        className={({ isActive }) => cn(
                            "flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200",
                            isActive
                                ? "bg-secondary-600/10 text-secondary-400 border border-secondary-600/20 shadow-[0_0_15px_rgba(99,102,241,0.1)]"
                                : "text-slate-400 hover:bg-navy-800 hover:text-slate-200"
                        )}
                    >
                        <item.icon className="w-5 h-5" />
                        {item.label}
                    </NavLink>
                ))}
            </div>

            <div className="p-4 border-t border-navy-800 space-y-1">
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-navy-800 hover:text-slate-200 transition-colors">
                    <HelpCircle className="w-5 h-5" />
                    Help & Docs
                </button>
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-red-900/20 hover:text-red-400 transition-colors">
                    <LogOut className="w-5 h-5" />
                    Logout
                </button>
            </div>
        </aside>
    );
}

```

#### frontend\src\components\layout\TopBar.tsx
```typescript
import { Bell, Settings, User, Search } from 'lucide-react';
import { Button } from '../ui/Button';

export function TopBar() {
    return (
        <header className="h-[80px] bg-navy-950 border-b border-navy-800 flex items-center justify-between px-6 fixed top-0 left-0 right-0 z-50">
            {/* Left: Logo & Context */}
            <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-lg flex items-center justify-center shadow-lg shadow-primary-500/20">
                        <svg className="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <span className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-400 to-secondary-400">
                        MotionGrid
                    </span>
                </div>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div className="flex items-center gap-2 text-slate-400 bg-navy-900 py-2 px-4 rounded-lg border border-navy-800">
                    <Search className="w-4 h-4" />
                    <span className="text-sm">Global Search...</span>
                </div>
            </div>

            {/* Right: Actions & Profile */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" className="relative" onClick={() => alert("Notifications coming soon!")}>
                    <Bell className="w-5 h-5 text-slate-400" />
                    <span className="absolute top-2 right-2 w-2 h-2 bg-status-critical rounded-full animate-pulse" />
                </Button>
                <Button variant="ghost" size="icon" onClick={() => alert("Settings panel coming soon!")}>
                    <Settings className="w-5 h-5 text-slate-400" />
                </Button>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div
                    className="flex items-center gap-3 pl-2 cursor-pointer hover:bg-navy-900 p-2 rounded-lg transition-colors"
                    onClick={() => alert("User profile management coming soon!")}
                >
                    <div className="text-right hidden md:block">
                        <div className="text-sm font-semibold text-white">Admin User</div>
                        <div className="text-xs text-primary-400">OPERATOR</div>
                    </div>
                    <div className="w-10 h-10 bg-navy-800 rounded-full flex items-center justify-center border border-navy-700">
                        <User className="w-5 h-5 text-slate-300" />
                    </div>
                </div>
            </div>
        </header>
    );
}

```

#### frontend\src\components\ui\Badge.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const badgeVariants = cva(
    "inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide transition-colors",
    {
        variants: {
            variant: {
                default: "bg-navy-700 text-white",
                critical: "bg-status-critical text-white shadow-[0_0_10px_rgba(220,38,38,0.4)]",
                high: "bg-status-high text-white",
                medium: "bg-status-medium text-white",
                low: "bg-status-low text-white",
                success: "bg-status-success text-white",
                outline: "border border-navy-700 text-slate-400 bg-transparent",
            },
            size: {
                sm: "text-[10px] px-2 py-0.5",
                md: "text-xs px-3 py-1",
                lg: "text-sm px-4 py-1.5",
            }
        },
        defaultVariants: {
            variant: "default",
            size: "md",
        }
    }
);

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof badgeVariants> { }

export function Badge({ className, variant, size, ...props }: BadgeProps) {
    return (
        <span className={badgeVariants({ variant, size, className })} {...props} />
    );
}

```

#### frontend\src\components\ui\Button.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';
import React from 'react';

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-lg text-sm font-semibold transition-all focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none active:scale-95",
    {
        variants: {
            variant: {
                primary: "bg-secondary-600 text-white hover:bg-secondary-500 shadow-lg shadow-secondary-900/20",
                secondary: "border border-navy-700 bg-transparent text-slate-300 hover:bg-navy-800",
                danger: "bg-status-critical text-white hover:bg-red-700",
                ghost: "bg-transparent text-slate-400 hover:text-white hover:bg-navy-800",
                icon: "p-2 bg-transparent text-slate-400 hover:bg-navy-800 hover:text-white rounded-md",
            },
            size: {
                sm: "px-3 py-1.5 text-xs",
                md: "px-4 py-2",
                lg: "px-6 py-3 text-base",
                icon: "h-9 w-9 p-0",
            },
            fullWidth: {
                true: "w-full",
            }
        },
        defaultVariants: {
            variant: "primary",
            size: "md",
            fullWidth: false,
        }
    }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, fullWidth, ...props }, ref) => {
        return (
            <button
                ref={ref}
                className={buttonVariants({ variant, size, fullWidth, className })}
                {...props}
            />
        );
    }
);
Button.displayName = "Button";

```

#### frontend\src\components\ui\Card.tsx
```typescript
import { cn } from '../../utils/cn';
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    hover?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
    ({ className, hover = true, children, ...props }, ref) => {
        return (
            <div
                ref={ref}
                className={cn(
                    "bg-navy-800 border border-navy-700 rounded-xl shadow-md p-5",
                    "transition-all duration-200 ease-out",
                    hover && "hover:-translate-y-0.5 hover:shadow-lg hover:shadow-black/20 hover:border-navy-600",
                    className
                )}
                {...props}
            >
                {children}
            </div>
        );
    }
);
Card.displayName = "Card";

export function CardHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("mb-4 flex items-center justify-between", className)} {...props}>
            {children}
        </div>
    );
}

export function CardTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
    return (
        <h3 className={cn("text-lg font-bold text-white", className)} {...props}>
            {children}
        </h3>
    );
}

export function CardContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("text-sm text-slate-300 leading-relaxed", className)} {...props}>
            {children}
        </div>
    );
}

```

#### frontend\src\context\AuthContext.tsx
```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import { api } from '../services/api';

interface User {
    id: string;
    email: string;
    role: string;
    username: string;
}

interface AuthContextType {
    user: User | null;
    token: string | null;
    login: (token: string, user: User) => void;
    logout: () => void;
    isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [token, setToken] = useState<string | null>(null);

    useEffect(() => {
        // Init from local storage
        const storedToken = localStorage.getItem('token');
        const storedUser = localStorage.getItem('user');

        if (storedToken && storedUser) {
            try {
                setToken(storedToken);
                setUser(JSON.parse(storedUser));
                // Set default header
                api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
            } catch (e) {
                console.error("Failed to parse stored user", e);
                localStorage.clear();
            }
        }
    }, []);

    const login = (newToken: string, newUser: User) => {
        setToken(newToken);
        setUser(newUser);
        localStorage.setItem('token', newToken);
        localStorage.setItem('user', JSON.stringify(newUser));
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
    };

    const logout = () => {
        setToken(null);
        setUser(null);
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        delete api.defaults.headers.common['Authorization'];
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout, isAuthenticated: !!token }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

```

#### frontend\src\services\api.ts
```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';

export const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

export const Api = {
    // Nodes
    getNodes: async () => (await api.get('/nodes')).data,
    getNode: async (id: string) => (await api.get(`/nodes/${id}`)).data,
    createNode: async (data: any) => (await api.post('/nodes', data)).data,
    updateNode: async (id: string, data: any) => (await api.patch(`/nodes/${id}`, data)).data,
    deleteNode: async (id: string) => (await api.delete(`/nodes/${id}`)).data,
    calibrateNode: async (id: string) => (await api.post(`/nodes/${id}/calibrate`)).data,

    // Sessions
    getSessions: async () => (await api.get('/sessions')).data,
    getSession: async (id: string) => (await api.get(`/sessions/${id}`)).data,
    createSession: async (data: any) => (await api.post('/sessions', data)).data,
    updateSession: async (id: string, data: any) => (await api.patch(`/sessions/${id}`, data)).data,
    deleteSession: async (id: string) => (await api.delete(`/sessions/${id}`)).data,
    startSession: async (id: string) => (await api.post(`/sessions/${id}/start`)).data,
    stopSession: async (id: string) => (await api.post(`/sessions/${id}/stop`)).data,

    // Simulation
    startSimulation: async (config: any) => (await api.post('/simulation/start', config)).data,
    stopSimulation: async () => (await api.post('/simulation/stop')).data,
    getSimulationStatus: async () => (await api.get('/simulation/status')).data,

    // Entities
    getEntities: async () => (await api.get('/entities')).data,

    // Analytics
    getStats: async () => (await api.get('/analytics/stats')).data
};

```

#### frontend\src\services\websocket.ts
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketService {
    private socket: Socket | null = null;
    private callbacks: Map<string, Function[]> = new Map();

    connect(url: string) {
        const token = localStorage.getItem('auth_token');
        this.socket = io(url, {
            transports: ['websocket'],
            reconnection: true,
            auth: { token }
        });

        this.socket.on('connect', () => {
            console.log('WebSocket connected');
            // Re-subscribe if we had active subscriptions? 
            // For now, simpler to leave it to the components.
        });

        this.socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        // Register for all expected events
        ['sensor:frame', 'anomaly:detected', 'entity:tracking', 'session:stats', 'node:status']
            .forEach(event => {
                this.socket!.on(event, (data: any) => {
                    const cbs = this.callbacks.get(event) || [];
                    cbs.forEach(cb => cb(data));
                });
            });
    }

    subscribeToSession(sessionId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:session', { sessionId });
    }

    subscribeToNode(nodeId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:node', { nodeId });
    }

    on(event: string, callback: Function) {
        if (!this.callbacks.has(event)) {
            this.callbacks.set(event, []);
        }
        this.callbacks.get(event)!.push(callback);
    }

    off(event: string, callback: Function) {
        if (!this.callbacks.has(event)) return;
        const cbs = this.callbacks.get(event) || [];
        this.callbacks.set(event, cbs.filter(cb => cb !== callback));
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
}

export const wsService = new WebSocketService();

```

#### frontend\src\utils\cn.ts
```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

```

#### frontend\src\views\Login.tsx
```typescript
import React, { useState } from 'react';
import { useAuth } from '../context/AuthContext';
import { api } from '../services/api';
import { useNavigate, useLocation } from 'react-router-dom';
import { KeyRound, Mail, User, Loader2 } from 'lucide-react';

export const Login: React.FC = () => {
    const { login } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    // Redirect to where they came from (or dashboard)
    const from = (location.state as any)?.from?.pathname || '/';

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            const response = await api.post('/auth/login', { email, password });
            const { token, user } = response.data;
            login(token, user);
            navigate(from, { replace: true });
        } catch (err: any) {
            console.error(err);
            setError(err.response?.data?.error || 'Login failed. Please check your credentials.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-slate-950 flex items-center justify-center p-4">
            <div className="bg-slate-900 border border-slate-800 rounded-xl max-w-md w-full p-8 shadow-2xl">
                <div className="text-center mb-8">
                    <div className="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-4 shadow-lg shadow-blue-900/50">
                        <KeyRound className="w-8 h-8 text-white" />
                    </div>
                    <h2 className="text-3xl font-bold text-white mb-2">Welcome Back</h2>
                    <p className="text-slate-400">Sign in to Motion Intelligence Grid</p>
                </div>

                {error && (
                    <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4 mb-6 text-red-500 text-sm">
                        {error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Email Address</label>
                        <div className="relative">
                            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="operator@motiongrid.com"
                            />
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Password</label>
                        <div className="relative">
                            <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="••••••••"
                            />
                        </div>
                    </div>

                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg transition shadow-lg shadow-blue-900/20 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                    >
                        {loading ? (
                            <>
                                <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                                Signing in...
                            </>
                        ) : (
                            'Sign In'
                        )}
                    </button>
                </form>

                <div className="mt-6 text-center text-sm text-slate-500">
                    <p>Default Admin: admin@freeforge.com / nimda</p>
                </div>
            </div>
        </div>
    );
};

```

#### frontend\src\views\Analytics\AnalyticsDashboard.tsx
```typescript
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';

export const AnalyticsDashboard = () => {
    return (
        <div className="p-6 space-y-6 text-white h-full overflow-y-auto">
            <h1 className="text-2xl font-bold mb-4">System Analytics</h1>

            {/* KPI Grid */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <KPICard title="Total Sessions" value="1,284" trend="+12%" />
                <KPICard title="Avg. Anomaly Rate" value="0.4/hr" trend="-5%" trendGood />
                <KPICard title="Active Nodes" value="24/24" trend="100%" />
                <KPICard title="Data Throughput" value="1.2 GB/s" trend="+8%" />
            </div>

            {/* Charts Section */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">Anomaly Distribution by Type</h3>
                    <div className="flex items-end justify-around h-60 gap-4 pb-2 border-b border-slate-700">
                        <Bar height="30%" label="Speed" color="bg-blue-500" />
                        <Bar height="60%" label="Crowd" color="bg-purple-500" />
                        <Bar height="15%" label="Zone" color="bg-yellow-500" />
                        <Bar height="45%" label="Formation" color="bg-green-500" />
                    </div>
                </Card>

                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">System Load (24h)</h3>
                    {/* Simple SVG Line Chart */}
                    <div className="h-60 w-full relative">
                        <svg className="w-full h-full overflow-visible">
                            <defs>
                                <linearGradient id="grad" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="#0ea5e9" stopOpacity="0.5" />
                                    <stop offset="100%" stopColor="#0ea5e9" stopOpacity="0" />
                                </linearGradient>
                            </defs>
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20 V150 H0 Z"
                                fill="url(#grad)"
                            />
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20"
                                fill="none"
                                stroke="#0ea5e9"
                                strokeWidth="3"
                            />
                        </svg>
                        <div className="absolute bottom-0 w-full text-xs text-slate-500 flex justify-between">
                            <span>00:00</span>
                            <span>06:00</span>
                            <span>12:00</span>
                            <span>18:00</span>
                            <span>24:00</span>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const KPICard = ({ title, value, trend, trendGood = false }: any) => (
    <Card className="p-4">
        <div className="text-slate-400 text-sm">{title}</div>
        <div className="text-2xl font-bold mt-1">{value}</div>
        <div className={`text-xs mt-2 ${trendGood || trend.startsWith('+') ? 'text-green-400' : 'text-slate-500'}`}>
            {trend} vs last week
        </div>
    </Card>
);

const Bar = ({ height, label, color }: any) => (
    <div className="flex flex-col items-center flex-1 h-full justify-end group">
        <div className={`w-full max-w-[40px] rounded-t-sm ${color} transition-all duration-500`} style={{ height }}></div>
        <div className="text-xs text-slate-400 mt-2">{label}</div>
    </div>
);

```

#### frontend\src\views\Dashboard\Dashboard.tsx
```typescript
import { AnomalyPanel } from './components/AnomalyPanel';
import { DashboardControls } from './components/DashboardControls';
import { StadiumMap } from './components/StadiumMap';
import { DashboardSparkline } from './components/DashboardSparkline';

const Dashboard = () => {
    return (
        <div className="space-y-6">
            <DashboardControls />

            <div className="flex flex-col lg:flex-row gap-6">
                {/* Main View: Stadium Map */}
                <div className="flex-1">
                    <StadiumMap />

                    {/* Bottom Sparkline */}
                    <div className="mt-6 h-[100px] bg-navy-900 border border-navy-800 rounded-xl relative overflow-hidden p-2">
                        <DashboardSparkline />
                    </div>
                </div>

                {/* Right Panel: Anomalies */}
                <AnomalyPanel />
            </div>
        </div>
    );
};

export default Dashboard;

```

#### frontend\src\views\Dashboard\components\AnomalyPanel.tsx
```typescript
import { Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { Badge } from '../../../components/ui/Badge';

const ANOMALIES = [
    { id: 1, time: '11:22', zone: 'Gate B', type: 'Crowd Compression', severity: 'critical', score: 87, delta: '+150%' },
    { id: 2, time: '11:20', zone: 'Concourse N', type: 'Rapid Movement', severity: 'high', score: 65, delta: '+80%' },
    { id: 3, time: '11:15', zone: 'Field', type: 'Unauthorized Access', severity: 'medium', score: 45, delta: 'N/A' },
    { id: 4, time: '11:10', zone: 'Gate A', type: 'Loitering', severity: 'low', score: 20, delta: '+15%' },
];

export function AnomalyPanel() {
    return (
        <div className="w-full lg:w-[360px] bg-navy-900 border border-navy-800 rounded-2xl flex flex-col h-[600px]">
            {/* Header */}
            <div className="p-4 border-b border-navy-800 flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-bold text-white">Active Anomalies</h3>
                    <div className="text-xs text-slate-400">23 Detected • <span className="text-status-critical">4 Critical</span></div>
                </div>
                <div className="flex gap-2">
                    <Button variant="ghost" size="icon"><Filter className="w-4 h-4" /></Button>
                    <Button variant="ghost" size="icon"><MoreHorizontal className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* List */}
            <div className="flex-1 overflow-y-auto p-3 space-y-3">
                {ANOMALIES.map((item) => (
                    <div
                        key={item.id}
                        className="group bg-navy-800 rounded-xl p-3 border border-navy-700 hover:border-indigo-500/50 hover:bg-navy-800/80 transition-all cursor-pointer relative overflow-hidden"
                    >
                        {/* Severity Indicator Bar */}
                        <div className={`absolute left-0 top-0 bottom-0 w-1 ${item.severity === 'critical' ? 'bg-status-critical' :
                            item.severity === 'high' ? 'bg-status-high' :
                                item.severity === 'medium' ? 'bg-status-medium' : 'bg-status-low'
                            }`} />

                        <div className="pl-3">
                            <div className="flex justify-between items-start mb-1">
                                <Badge variant={item.severity as any} size="sm">{item.severity}</Badge>
                                <span className="text-xs font-mono text-slate-500">{item.time}</span>
                            </div>

                            <h4 className="font-bold text-white text-sm mb-1 group-hover:text-indigo-300 transition-colors">{item.type}</h4>
                            <div className="flex justify-between items-center text-xs">
                                <span className="text-slate-400 uppercase tracking-wide font-semibold">{item.zone}</span>
                                <div className="flex gap-3 text-slate-500">
                                    <span>Risk: <span className={item.score > 80 ? 'text-red-400' : 'text-slate-300'}>{item.score}</span></span>
                                    <span>Δ: {item.delta}</span>
                                </div>
                            </div>
                        </div>

                        {/* Hover Actions Overlay (Simulated) */}
                        <div className="absolute right-2 bottom-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button size="sm" variant="secondary" className="h-7 text-xs px-2">View</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-navy-800 bg-navy-950/50 rounded-b-2xl">
                <Button variant="primary" fullWidth size="md">View All Anomalies</Button>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardControls.tsx
```typescript
import { Calendar, ChevronDown } from 'lucide-react';

export function DashboardControls() {
    return (
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6 bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
            {/* Event Selector */}
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-indigo-500/20 rounded-lg flex items-center justify-center text-indigo-400">
                    <Calendar className="w-5 h-5" />
                </div>
                <div>
                    <div className="text-xs text-slate-400 uppercase font-bold tracking-wide">Current Event</div>
                    <div className="flex items-center gap-2 text-white font-semibold cursor-pointer hover:text-indigo-400 transition-colors">
                        Match Day: Team A vs Team B
                        <ChevronDown className="w-4 h-4" />
                    </div>
                </div>
            </div>

            {/* Time Range Chips */}
            <div className="flex bg-navy-900 rounded-lg p-1 border border-navy-700">
                {['Now', 'Last 30m', 'Last 2h', '24h', 'Custom'].map((range, idx) => (
                    <button
                        key={range}
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${idx === 0
                            ? 'bg-secondary-600 text-white shadow-md'
                            : 'text-slate-400 hover:text-white hover:bg-navy-700'
                            }`}
                    >
                        {range}
                    </button>
                ))}
            </div>

            {/* System Status */}
            <div className="flex items-center gap-2 px-4 py-2 bg-status-success/10 border border-status-success/20 rounded-lg text-status-success">
                <span className="relative flex h-2.5 w-2.5">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
                </span>
                <span className="text-sm font-bold tracking-wide">SYSTEM OPTIMAL</span>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardSparkline.tsx
```typescript
import { Area, AreaChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts';

const generateMockData = () => {
    const data = [];
    for (let i = 0; i < 24; i++) {
        data.push({
            time: `${i}:00`,
            events: Math.floor(Math.random() * 50) + 10,
            anomalies: Math.floor(Math.random() * 5),
        });
    }
    return data;
};

const data = generateMockData();

export function DashboardSparkline() {
    return (
        <div className="w-full h-full">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={data}>
                    <defs>
                        <linearGradient id="colorEvents" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#818cf8" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#818cf8" stopOpacity={0} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis hide />
                    <Tooltip
                        contentStyle={{ backgroundColor: '#1e293b', borderColor: '#334155', color: '#f8fafc' }}
                        itemStyle={{ color: '#818cf8' }}
                        labelStyle={{ color: '#94a3b8' }}
                    />
                    <Area
                        type="monotone"
                        dataKey="events"
                        stroke="#818cf8"
                        fillOpacity={1}
                        fill="url(#colorEvents)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\StadiumMap.tsx
```typescript
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ZONES = [
    { id: 'gate-a', name: 'GATE A', type: 'GATE', status: 'critical', x: '10%', y: '20%' },
    { id: 'gate-b', name: 'GATE B', type: 'GATE', status: 'normal', x: '80%', y: '20%' },
    { id: 'field', name: 'FIELD', type: 'FIELD', status: 'normal', x: '45%', y: '45%' },
    { id: 'concourse-n', name: 'CONCOURSE N', type: 'CONCOURSE', status: 'high', x: '45%', y: '10%' },
    { id: 'concourse-s', name: 'CONCOURSE S', type: 'CONCOURSE', status: 'normal', x: '45%', y: '80%' },
];

export function StadiumMap() {
    return (
        <div className="relative w-full h-[600px] bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden shadow-inner">
            {/* Grid Pattern Background */}
            <div className="absolute inset-0 opacity-10"
                style={{ backgroundImage: 'radial-gradient(circle, #334155 1px, transparent 1px)', backgroundSize: '30px 30px' }}
            />

            {/* Stadium Visual Placeholder - Simple SVG representation */}
            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 600">
                {/* Field */}
                <rect x="250" y="150" width="500" height="300" rx="40" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <circle cx="500" cy="300" r="50" fill="none" stroke="#334155" strokeWidth="2" />
                <line x1="500" y1="150" x2="500" y2="450" stroke="#334155" strokeWidth="2" />

                {/* Zones Outline */}
                <path d="M 150 100 Q 500 0 850 100 L 900 250 L 850 500 Q 500 600 150 500 L 100 250 Z"
                    fill="none" stroke="#4f46e5" strokeWidth="2" strokeDasharray="10 5" opacity="0.3" />
            </svg>

            {/* Zone Cards Overlay */}
            {ZONES.map((zone) => (
                <div
                    key={zone.id}
                    className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer transition-transform hover:scale-105 hover:z-10"
                    style={{ left: zone.x, top: zone.y }}
                >
                    <Card className={`w-48 p-3 bg-navy-800/90 backdrop-blur-sm border-l-4 ${zone.status === 'critical' ? 'border-l-status-critical shadow-[0_0_20px_rgba(220,38,38,0.2)]' :
                            zone.status === 'high' ? 'border-l-status-high' :
                                'border-l-status-success'
                        }`}>
                        <div className="flex justify-between items-start mb-2">
                            <span className="text-xs font-bold text-slate-300 tracking-wider">{zone.name}</span>
                            <Badge variant={zone.status as any} size="sm">{zone.status}</Badge>
                        </div>
                        <div className="space-y-1">
                            <div className="text-xs text-slate-400">Last event: 2m ago</div>
                            <div className="text-xs text-slate-400">Anomalies: <span className="text-white font-mono">3</span></div>
                        </div>
                    </Card>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\Entities\EntitiesList.tsx
```typescript

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Search, Filter, Eye } from 'lucide-react';
import { api } from '../../services/api';

interface Entity {
    id: string;
    type: string;
    role?: string;
    team?: string;
    lastSeen: number;
    status: 'ACTIVE' | 'INACTIVE';
}

export const EntitiesList = () => {
    const navigate = useNavigate();
    const [entities, setEntities] = useState<Entity[]>([]);
    const [search, setSearch] = useState('');

    useEffect(() => {
        const fetchEntities = async () => {
            try {
                // Mock endpoint or real if available
                const data = await api.get('/entities');
                if (Array.isArray(data)) setEntities(data);
            } catch (err) {
                // Determine mock data if API fails (for demo robustness)
                setEntities([
                    { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'HOME_PLAYER_2', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'REF_1', type: 'PERSON', role: 'REFEREE', team: 'NEUTRAL', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'BALL', type: 'OBJECT', role: 'game_ball', lastSeen: Date.now(), status: 'ACTIVE' },
                ]);
            }
        }
        fetchEntities();
    }, []);

    const filtered = entities.filter(e => e.id.toLowerCase().includes(search.toLowerCase()));

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Entity Directory</h1>
                <div className="flex gap-2">
                    <div className="relative">
                        <Search className="absolute left-3 top-2.5 w-4 h-4 text-slate-400" />
                        <input
                            type="text"
                            placeholder="Search entities..."
                            className="bg-slate-900 border border-slate-700 rounded-md pl-9 pr-4 py-2 text-sm focus:outline-none focus:border-blue-500 w-64"
                            value={search}
                            onChange={(e) => setSearch(e.target.value)}
                        />
                    </div>
                    <Button variant="outline"><Filter className="w-4 h-4 mr-2" /> Filter</Button>
                </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filtered.map(entity => (
                    <Card key={entity.id} className="hover:border-blue-500/50 transition-colors cursor-pointer" onClick={() => navigate(`/entities/${entity.id}`)}>
                        <div className="flex justify-between items-start mb-4">
                            <Badge variant={entity.team === 'HOME' ? 'critical' : entity.team === 'AWAY' ? 'primary' : 'outline'}>
                                {entity.role || entity.type}
                            </Badge>
                            <div className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]" />
                        </div>
                        <h3 className="text-lg font-bold mb-1">{entity.id}</h3>
                        <div className="text-slate-400 text-sm mb-4">
                            Last seen: {new Date(entity.lastSeen).toLocaleTimeString()}
                        </div>
                        <div className="flex justify-end">
                            <Button variant="ghost" size="sm">
                                <Eye className="w-4 h-4 mr-2" /> View Profile
                            </Button>
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\Entities\EntityProfile.tsx
```typescript
import { useParams, useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { ArrowLeft, Activity, Shield, MapPin } from 'lucide-react';

export const EntityProfile = () => {
    const { id } = useParams();
    const navigate = useNavigate();

    return (
        <div className="p-6 text-white max-w-5xl mx-auto">
            <Button variant="ghost" size="sm" onClick={() => navigate(-1)} className="mb-4">
                <ArrowLeft className="w-4 h-4 mr-2" /> Back
            </Button>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Profile Header */}
                <Card className="md:col-span-3 p-6 flex items-center gap-6">
                    <div className="w-24 h-24 rounded-full bg-slate-800 flex items-center justify-center text-3xl font-bold text-blue-400">
                        {id?.substring(0, 2).toUpperCase() || 'E'}
                    </div>
                    <div>
                        <h1 className="text-3xl font-bold">{id || 'Unknown Entity'}</h1>
                        <div className="text-slate-400 flex gap-4 mt-2">
                            <span className="flex items-center gap-1"><Shield className="w-4 h-4" /> Security Staff</span>
                            <span className="flex items-center gap-1"><MapPin className="w-4 h-4" /> Zone B</span>
                            <span className="flex items-center gap-1 text-green-400"><Activity className="w-4 h-4" /> Active</span>
                        </div>
                    </div>
                </Card>

                {/* Stats */}
                <Card className="p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Movement Stats</h3>
                    <div className="space-y-4">
                        <Stat label="Avg Speed" value="1.4 m/s" />
                        <Stat label="Distance" value="4.2 km" />
                        <Stat label="Zone Violations" value="0" />
                    </div>
                </Card>

                {/* Recent Activity */}
                <Card className="md:col-span-2 p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Recent Activity Timeline</h3>
                    <div className="space-y-4">
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:45</div>
                            <div>Entered Zone B (North Gate)</div>
                        </div>
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:30</div>
                            <div>Shift Started</div>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const Stat = ({ label, value }: any) => (
    <div className="flex justify-between items-center border-b border-slate-800 pb-2">
        <span className="text-slate-400 text-sm">{label}</span>
        <span className="font-mono">{value}</span>
    </div>
);

```

#### frontend\src\views\LiveMonitoring\AlertPanel.tsx
```typescript
import { useEffect, useState } from 'react';
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';
import { wsService } from '../../services/websocket';

interface Anomaly {
    id: string;
    headline: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    time: string;
}

export const AlertPanel = () => {
    const [alerts, setAlerts] = useState<Anomaly[]>([]);

    useEffect(() => {
        // Connect if not already (MeshView also connects, but idempotent)
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            console.log('Anomaly received:', data);

            // Map Python payload to frontend model
            // Python sends: { anomalyId, headline, severity, occurredAt, ... }
            const newAlert: Anomaly = {
                id: data.anomalyId || 'unknown',
                headline: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                // occurredAt is ISO string now
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };

            setAlerts(prev => [newAlert, ...prev].slice(0, 50)); // Keep last 50
        });

        return () => {
            // Unsubscribe logic if wsService supports it, or just let it exist
        };
    }, []);

    return (
        <div className="bg-gray-800 border-l border-gray-700 w-80 flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-red-400" />
                    Active Alerts
                </h3>
            </div>

            <div className="flex-1 overflow-auto p-4 space-y-3">
                {alerts.length === 0 && (
                    <div className="text-gray-500 text-center text-sm py-8">
                        No active alerts.
                    </div>
                )}
                {alerts.map(alert => (
                    <div key={alert.id} className="bg-gray-700/50 rounded-lg p-3 border border-gray-600 hover:border-gray-500 transition-colors">
                        <div className="flex justify-between items-start mb-2">
                            <span className={`text-xs font-bold px-1.5 py-0.5 rounded ${alert.severity === 'CRITICAL' ? 'bg-red-500/20 text-red-300' :
                                alert.severity === 'HIGH' ? 'bg-orange-500/20 text-orange-300' : 'bg-blue-500/20 text-blue-300'
                                }`}>
                                {alert.severity}
                            </span>
                            <span className="text-xs text-gray-400">{alert.time}</span>
                        </div>
                        <h4 className="text-sm font-medium mb-2">{alert.headline}</h4>

                        {/* Triage Actions */}
                        <div className="flex gap-2 mt-2">
                            <button className="flex-1 flex items-center justify-center gap-1 bg-green-900/30 hover:bg-green-900/50 text-green-300 py-1 rounded text-xs transition-colors">
                                <CheckCircle className="h-3 w-3" /> Confirm
                            </button>
                            <button className="flex-1 flex items-center justify-center gap-1 bg-gray-600/30 hover:bg-gray-600/50 text-gray-300 py-1 rounded text-xs transition-colors">
                                <XCircle className="h-3 w-3" /> Dismiss
                            </button>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\CameraGrid.tsx
```typescript

import { useEffect, useState } from 'react';
import { Camera } from 'lucide-react';
import { VideoPlaceholder } from './components/VideoPlaceholder';
import { Api } from '../../../services/api';

interface CameraNode {
    id: string; // real ID (uuid)
    nodeId: string; // human readable (CAM_01)
    status: string;
}

export const CameraGrid = () => {
    const [cameras, setCameras] = useState<CameraNode[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                // Map backend nodes to camera view
                // Backend node has: nodeId (string), id (uuid), config...
                const mapped = data.nodes.map((n: any) => ({
                    id: n._id,
                    nodeId: n.nodeId,
                    status: 'ONLINE' // Assume online if fetched for now
                }));

                if (mapped.length > 0) {
                    setCameras(mapped);
                } else {
                    // Fallback to placeholders if no real nodes found (for demo preservation)
                    setCameras([
                        { id: 'mock1', nodeId: 'CAM_01 (Sim)', status: 'ONLINE' },
                        { id: 'mock2', nodeId: 'CAM_02 (Sim)', status: 'ONLINE' },
                    ]);
                }
            } catch (e) {
                console.error("Failed to fetch camera nodes", e);
                // Fallback
                setCameras([
                    { id: 'mock1', nodeId: 'CAM_01 (Offline)', status: 'OFFLINE' },
                    { id: 'mock2', nodeId: 'CAM_02 (Offline)', status: 'OFFLINE' },
                ]);
            } finally {
                setLoading(false);
            }
        };

        fetchNodes();
    }, []);

    if (loading) {
        return <div className="text-white text-center p-4">Loading streams...</div>;
    }

    return (
        <div className="grid grid-cols-2 gap-2 h-full">
            {cameras.map(cam => (
                <div key={cam.id} className="relative bg-black rounded overflow-hidden group">
                    <div className="absolute inset-0 flex items-center justify-center text-gray-700">
                        {cam.status === 'ONLINE' ? (
                            <div className="flex-1 bg-black relative w-full h-full">
                                {/* Pass nodeId only if it's not a mock ID, or handle mock logic inside VideoPlaceholder? 
                                    Actually, if we want real stream, we need real nodeId (CAM_01 etc from sim).
                                    If mapped from real API, cam.nodeId is what we want.
                                */}
                                <VideoPlaceholder
                                    label={cam.nodeId}
                                    // Use cam.nodeId as endpoint parameter. 
                                    // If it's a mock fallback, this might fail to stream (404) and component will fallback to noise.
                                    nodeId={cam.nodeId}
                                />
                            </div>) : (
                            <div className="flex flex-col items-center">
                                <Camera className="h-8 w-8 mb-2 opacity-50" />
                                <span className="text-xs">OFFLINE</span>
                            </div>
                        )}
                    </div>

                    {/* Overlay */}
                    <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white backdrop-blur-sm">
                        {cam.nodeId}
                    </div>
                    <div className={`absolute top-2 right-2 w-2 h-2 rounded-full ${cam.status === 'ONLINE' ? 'bg-green-500' : 'bg-red-500'}`} />
                </div>
            ))}
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\index.tsx
```typescript
import { useEffect } from 'react';
import { MeshView3D } from './MeshView3D';
import { LayerControls } from './components/LayerControls';
import { LiveAlerts } from './components/LiveAlerts';
import { CameraStrip } from './components/CameraStrip';
import { wsService } from '../../services/websocket';
import { Button } from '../../components/ui/Button';
import { Pause, RefreshCw } from 'lucide-react';

export const LiveMonitoring = () => {
    useEffect(() => {
        const wsUrl = (import.meta as any).env?.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app';
        wsService.connect(wsUrl);
    }, []);

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] gap-4">
            {/* Top Controls */}
            <div className="flex items-center justify-between pb-2 border-b border-navy-800">
                <div className="flex gap-4 items-center">
                    <h2 className="text-lg font-bold text-white">Zone A: Main Concourse</h2>
                    <div className="flex gap-1">
                        <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span className="text-xs text-green-400 font-mono">LIVE FEED</span>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="icon" variant="ghost"><RefreshCw className="w-4 h-4" /></Button>
                    <Button size="icon" variant="secondary"><Pause className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* Main Content Area */}
            <div className="flex flex-1 gap-4 overflow-hidden">
                {/* Left: Layers */}
                <div className="flex-shrink-0">
                    <LayerControls />
                </div>

                {/* Center: 3D View */}
                <div className="flex-1 bg-black rounded-2xl border border-navy-800 relative overflow-hidden group">
                    <MeshView3D />

                    {/* Camera Strip Overlay */}
                    <div className="translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                        <CameraStrip />
                    </div>
                </div>

                {/* Right: Alerts */}
                <div className="flex-shrink-0">
                    <LiveAlerts />
                </div>
            </div>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\MeshView3D.tsx
```typescript
import { useEffect, useState, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text, Html } from '@react-three/drei';
import * as THREE from 'three';
import { wsService } from '../../services/websocket';

interface Entity {
    id: string;
    type: string;
    position: { x: number; y: number; z: number };
    velocity: { x: number; y: number; z: number };
    radius?: number;
    color?: number[];
    severity?: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
}

const EntityMesh = ({ entity }: { entity: Entity }) => {
    // Convert array color or hex to THREE.Color
    const color = useMemo(() => {
        if (Array.isArray(entity.color)) {
            return new THREE.Color(entity.color[0] / 255, entity.color[1] / 255, entity.color[2] / 255);
        }
        return new THREE.Color(entity.color || 'white');
    }, [entity.color]);

    const VelocityArrow = ({ velocity }: { velocity: { x: number; y: number; z: number } }) => {
        const length = Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);
        if (length < 0.1) return null;
        // Normalize direction
        const dir = new THREE.Vector3(velocity.x, velocity.y, velocity.z).normalize();
        return (
            <arrowHelper args={[dir, new THREE.Vector3(0, 0, 0), Math.min(length, 2), 0xffff00]} />
        );
    };

    const RiskHalo = ({ severity }: { severity?: string }) => {
        if (!severity || severity === 'LOW') return null;
        const color = severity === 'CRITICAL' ? 'red' : severity === 'HIGH' ? 'orange' : 'yellow';
        return (
            <mesh position={[0, -0.9, 0]} rotation={[0, 0, 0]}>
                <ringGeometry args={[0.5, 0.7, 32]} />
                <meshBasicMaterial color={color} transparent opacity={0.5} side={THREE.DoubleSide} />
            </mesh>
        );
    };

    return (
        <group position={[entity.position.x, entity.position.y, entity.position.z]}>
            {/* Entity Body */}
            <mesh castShadow receiveShadow>
                <capsuleGeometry args={[entity.radius || 0.3, 1.8, 4, 8]} />
                <meshStandardMaterial color={color} roughness={0.3} metalness={0.1} />
            </mesh>

            <RiskHalo severity={entity.severity} />
            <VelocityArrow velocity={entity.velocity} />

            {/* ID Tag */}
            <Html position={[0, 2.2, 0]} center distanceFactor={15}>
                <div className={`text-[10px] px-1.5 py-0.5 rounded backdrop-blur-md whitespace-nowrap border font-mono
                    ${entity.severity === 'CRITICAL' ? 'bg-red-500/20 border-red-500 text-red-200' :
                        entity.severity === 'HIGH' ? 'bg-orange-500/20 border-orange-500 text-orange-200' :
                            'bg-slate-900/60 border-slate-700 text-slate-300'}`}>
                    {entity.id}
                </div>
            </Html>
        </group>
    );
};

const Floor = () => {
    return (
        <mesh receiveShadow rotation={[0, 0, 0]} position={[0, 0, -0.01]}>
            <planeGeometry args={[100, 100]} />
            <meshStandardMaterial color="#0f172a" roughness={0.8} metalness={0.2} />
            <gridHelper args={[100, 50, 0x334155, 0x1e293b]} rotation={[Math.PI / 2, 0, 0]} />
        </mesh>
    );
};

export const MeshView3D = () => {
    const [entities, setEntities] = useState<Entity[]>([]);
    const [stats, setStats] = useState({ fps: 0, frame: 0, time: 0 });

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');
        const unsubscribe = wsService.on('entity:tracking', (data: { entities: Entity[], stats?: any }) => {
            if (data && data.entities) setEntities(data.entities);
            if (data && data.stats) setStats(data.stats);
        });
        return () => { }; // Connection managed globally or by context in real app
    }, []);

    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden border border-slate-800 relative shadow-inner">
            <div className="absolute top-4 left-4 z-10 space-y-2">
                <div className="bg-slate-900/90 p-3 rounded-lg border border-slate-800 text-xs text-slate-300 backdrop-blur shadow-lg space-y-2">
                    <div className="font-bold text-slate-100 mb-1 border-b border-slate-700 pb-1">Live Telemetry</div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Entities</span>
                        <span className="font-mono text-white text-right">{entities.length}</span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sim FPS</span>
                        <span className={`font-mono text-right ${stats.fps < 25 ? 'text-yellow-400' : 'text-green-400'}`}>
                            {stats.fps.toFixed(1)}
                        </span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sync</span>
                        <div className="flex items-center gap-1.5 justify-end">
                            <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" />
                            <span className="font-mono text-white">ACTIVE</span>
                        </div>
                    </div>
                </div>
            </div>

            <Canvas shadows camera={{ position: [0, -30, 20], fov: 50, up: [0, 0, 1] }}>
                <color attach="background" args={['#020617']} />
                <fog attach="fog" args={['#020617', 20, 90]} />

                <ambientLight intensity={0.4} />
                <directionalLight
                    position={[10, -20, 20]}
                    intensity={1.2}
                    castShadow
                    shadow-mapSize={[1024, 1024]}
                />
                <pointLight position={[-10, 10, 5]} intensity={0.5} color="#3b82f6" />

                <OrbitControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2.1} />

                <Floor />
                <axesHelper args={[2]} position={[0, 0, 0.1]} />

                {entities.map(e => (
                    <EntityMesh key={e.id} entity={e} />
                ))}
            </Canvas>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\components\CameraStrip.tsx
```typescript
export function CameraStrip() {
    return (
        <div className="absolute bottom-4 left-4 right-4 flex gap-4 overflow-x-auto pb-2 scrollbar-hide">
            {[1, 2, 3, 4, 5].map(cam => (
                <div key={cam} className="w-40 h-24 bg-black rounded-lg border border-navy-700 relative flex-shrink-0 group cursor-pointer hover:border-indigo-500 transition-colors">
                    <div className="absolute top-1 left-1 bg-black/50 px-1 rounded text-[10px] text-slate-300">CAM-0{cam}</div>
                    <div className="w-full h-full flex items-center justify-center text-slate-700 text-xs">NO SIGNAL</div>
                    <div className="absolute top-1 right-1 h-2 w-2 bg-green-500 rounded-full shadow-[0_0_5px_rgba(34,197,94,0.5)]"></div>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LayerControls.tsx
```typescript
import { Layers, Eye, Activity, Map, Users, Zap } from 'lucide-react';
import { Card } from '../../../components/ui/Card';

const LAYERS = [
    { id: 'entities', label: 'Entities', icon: Users, default: true },
    { id: 'risk', label: 'Risk Halos', icon: Zap, default: true },
    { id: 'velocity', label: 'Velocity Vectors', icon: Activity, default: false },
    { id: 'trails', label: 'Path Trails', icon: Map, default: false },
    { id: 'social', label: 'Social Radar', icon: Users, default: false },
    { id: 'terrain', label: 'Behavior Terrain', icon: Layers, default: true },
];

export function LayerControls() {
    return (
        <Card className="w-64 bg-navy-900 border-navy-800 flex flex-col gap-4 h-full">
            <div className="flex items-center gap-2 mb-2 pb-2 border-b border-navy-800">
                <Layers className="w-4 h-4 text-indigo-400" />
                <h3 className="font-bold text-white text-sm">View Layers</h3>
            </div>

            <div className="space-y-3">
                {LAYERS.map(layer => (
                    <label key={layer.id} className="flex items-center justify-between group cursor-pointer">
                        <div className="flex items-center gap-3 text-slate-300 group-hover:text-white transition-colors">
                            <layer.icon className="w-4 h-4 text-slate-500 group-hover:text-indigo-400" />
                            <span className="text-sm font-medium">{layer.label}</span>
                        </div>
                        <div className="relative inline-block w-8 h-4 rounded-full cursor-pointer">
                            <input type="checkbox" className="sr-only peer" defaultChecked={layer.default} />
                            <div className="w-8 h-4 bg-navy-800 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-indigo-600"></div>
                        </div>
                    </label>
                ))}
            </div>

            <div className="mt-auto pt-4 border-t border-navy-800">
                <div className="text-xs text-slate-500 mb-2 uppercase font-bold">Camera Overlay</div>
                <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <Eye className="w-4 h-4" /> Show FOV Cones
                    <input type="checkbox" className="ml-auto accent-indigo-500" defaultChecked />
                </label>
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LiveAlerts.tsx
```typescript
import { AlertTriangle, Clock } from 'lucide-react';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ALERTS = [
    { id: 1, type: 'Crowd Crush', risk: 92, time: '10s ago', zone: 'Gate B' },
    { id: 2, type: 'Fight Precursor', risk: 78, time: '32s ago', zone: 'Concourse' },
    { id: 3, type: 'Fallen Object', risk: 45, time: '1m ago', zone: 'Aisle 12' },
];

export function LiveAlerts() {
    return (
        <Card className="w-80 bg-navy-900 border-navy-800 flex flex-col h-full">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-navy-800">
                <div className="flex items-center gap-2">
                    <AlertTriangle className="w-4 h-4 text-status-critical" />
                    <h3 className="font-bold text-white text-sm">Live Alerts</h3>
                </div>
                <Badge variant="critical">3 Active</Badge>
            </div>

            <div className="flex-1 overflow-y-auto space-y-3">
                {ALERTS.map(alert => (
                    <div key={alert.id} className="bg-navy-800 p-3 rounded-lg border border-navy-700 hover:border-red-500/50 transition-colors cursor-pointer group">
                        <div className="flex justify-between items-start mb-1">
                            <span className="text-xs font-bold text-red-300">{alert.type}</span>
                            <span className="text-[10px] text-slate-500 flex items-center gap-1">
                                <Clock className="w-3 h-3" /> {alert.time}
                            </span>
                        </div>
                        <div className="flex justify-between items-end">
                            <div className="text-xs text-slate-400">{alert.zone}</div>
                            <div className="text-sm font-mono font-bold text-white">
                                {alert.risk}% <span className="text-xs font-sans font-normal text-slate-500">Risk</span>
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\VideoPlaceholder.tsx
```typescript
import { useEffect, useRef, useState } from 'react';
import { api } from '../../../services/api';

export function VideoPlaceholder({ label, nodeId }: { label: string, nodeId?: string }) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [useStream, setUseStream] = useState(!!nodeId);
    const [imgError, setImgError] = useState(false);

    // Construct stream URL
    // We need to access the baseURL from axios instance or env
    const baseURL = api.defaults.baseURL || import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';
    const token = localStorage.getItem('auth_token');
    const streamUrl = nodeId ? `${baseURL}/nodes/${nodeId}/stream?token=${token}` : '';

    useEffect(() => {
        if (useStream && !imgError && nodeId) return; // If using stream, don't run canvas animation

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId: number;
        let time = 0;

        const draw = () => {
            time += 0.05;
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a'; // bg-slate-900
            ctx.fillRect(0, 0, width, height);

            // Digital Noise / Scanlines
            for (let i = 0; i < height; i += 4) {
                ctx.fillStyle = `rgba(30, 41, 59, ${Math.random() * 0.5})`;
                ctx.fillRect(0, i, width, 1);
            }

            // Moving "Entities" (Simple Blobs)
            const x = (Math.sin(time) * 0.4 + 0.5) * width;
            const y = (Math.cos(time * 0.7) * 0.4 + 0.5) * height;

            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(79, 70, 229, 0.4)'; // Indigo
            ctx.fill();

            // Overlay Text
            ctx.font = '12px monospace';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('REC', width - 40, 20);
            ctx.fillText(new Date().toLocaleTimeString(), 10, height - 10);
            ctx.fillText(label, 10, 20);

            if (imgError) {
                ctx.fillStyle = '#ef4444';
                ctx.fillText('SIGNAL LOST', width / 2 - 30, height / 2);
            }

            // Recording Dot
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(width - 50, 15, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }

            animationFrameId = window.requestAnimationFrame(draw);
        };

        const resize = () => {
            if (canvas?.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        };

        window.addEventListener('resize', resize);
        resize(); // Initial resize
        draw();

        return () => {
            window.removeEventListener('resize', resize);
            window.cancelAnimationFrame(animationFrameId);
        };
    }, [label, useStream, imgError, nodeId]);

    if (useStream && !imgError && nodeId) {
        return (
            <div className="relative w-full h-full bg-black">
                <img
                    src={streamUrl}
                    alt={label}
                    className="w-full h-full object-cover"
                    onError={() => setImgError(true)}
                />
                {/* Overlay Text for Stream too */}
                <div className="absolute top-0 left-0 p-2 text-xs font-mono text-green-500 w-full flex justify-between">
                    <span>{label}</span>
                    <span>LIVE</span>
                </div>
            </div>
        );
    }

    return (
        <canvas ref={canvasRef} className="w-full h-full block" />
    );
}

```

#### frontend\src\views\SessionReplay\SessionReplay.tsx
```typescript
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button } from '../../components/ui/Button';
import { Card } from '../../components/ui/Card';
import { Play, Pause, SkipBack, SkipForward, ArrowLeft } from 'lucide-react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';

interface SessionData {
    id: string;
    name: string;
    sport: string;
    startTime: string;
    duration: number;
    status: string;
}

export const SessionReplay = () => {
    const { id } = useParams();
    const navigate = useNavigate();
    const [session, setSession] = useState<SessionData | null>(null);
    const [currentTime, setCurrentTime] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const playbackRef = useRef<number>();

    // Mock fetch session details
    useEffect(() => {
        // In real app: fetch(`/api/sessions/${id}`)
        setSession({
            id: id || '1',
            name: 'Championship Final Game 3',
            sport: 'BASKETBALL',
            startTime: new Date().toISOString(),
            duration: 1200, // 20 mins
            status: 'COMPLETED'
        });
    }, [id]);

    // Playback loop
    useEffect(() => {
        if (isPlaying) {
            playbackRef.current = window.setInterval(() => {
                setCurrentTime(prev => {
                    if (prev >= (session?.duration || 0)) {
                        setIsPlaying(false);
                        return prev;
                    }
                    return prev + 1;
                });
            }, 1000); // 1x Speed
        } else {
            clearInterval(playbackRef.current);
        }
        return () => clearInterval(playbackRef.current);
    }, [isPlaying, session]);

    const formatTime = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    return (
        <div className="flex flex-col h-full gap-4 p-4 text-white">
            {/* Header */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="sm" onClick={() => navigate('/sessions')}>
                    <ArrowLeft className="w-4 h-4 mr-2" /> Back
                </Button>
                <div>
                    <h1 className="text-xl font-bold">{session?.name || 'Loading...'}</h1>
                    <div className="text-sm text-slate-400">
                        {session?.sport} • {new Date(session?.startTime || '').toLocaleDateString()}
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 flex gap-4 min-h-0">
                {/* 3D Replay Viewport */}
                <div className="flex-1 bg-slate-950 rounded-xl overflow-hidden relative border border-slate-800">
                    <div className="absolute top-4 left-4 z-10 bg-black/50 px-2 py-1 rounded text-xs">
                        REPLAY MODE
                    </div>
                    <Canvas camera={{ position: [0, -40, 30] }}>
                        <ambientLight intensity={0.5} />
                        <gridHelper args={[100, 100, 0x334155, 0x0f172a]} rotation={[Math.PI / 2, 0, 0]} />
                        <OrbitControls />
                        {/* Placeholder for entities at currentTime */}
                        <mesh position={[Math.sin(currentTime * 0.1) * 5, Math.cos(currentTime * 0.1) * 5, 1]}>
                            <sphereGeometry args={[0.5]} />
                            <meshStandardMaterial color="orange" />
                        </mesh>
                    </Canvas>
                </div>

                {/* Sidebar Stats */}
                <div className="w-80 flex flex-col gap-4">
                    <Card className="flex-1">
                        <div className="p-4">
                            <h3 className="font-semibold mb-4">Events Log</h3>
                            <div className="space-y-2 text-sm text-slate-400">
                                <div className="flex justify-between">
                                    <span>Sync Start</span>
                                    <span>0:00</span>
                                </div>
                                <div className="flex justify-between text-yellow-400">
                                    <span>Anomaly Detected</span>
                                    <span>0:45</span>
                                </div>
                                <div className="flex justify-between text-red-400">
                                    <span>Speed Violation</span>
                                    <span>1:20</span>
                                </div>
                            </div>
                        </div>
                    </Card>
                </div>
            </div>

            {/* Controls Bar */}
            <Card className="p-4 bg-slate-900 border-t border-slate-800">
                <div className="flex flex-col gap-2">
                    {/* Scrubber */}
                    <div className="flex items-center gap-4 text-xs text-slate-400">
                        <span className="w-12 text-right">{formatTime(currentTime)}</span>
                        <input
                            type="range"
                            min="0"
                            max={session?.duration || 100}
                            value={currentTime}
                            onChange={(e) => setCurrentTime(Number(e.target.value))}
                            className="flex-1 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="w-12">{formatTime(session?.duration || 0)}</span>
                    </div>

                    {/* Buttons */}
                    <div className="flex items-center justify-center gap-4">
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.max(0, currentTime - 10))}>
                            <SkipBack className="w-5 h-5" />
                        </Button>
                        <Button
                            variant="primary"
                            size="icon"
                            className="w-12 h-12 rounded-full"
                            onClick={() => setIsPlaying(!isPlaying)}
                        >
                            {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6 ml-1" />}
                        </Button>
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.min(session?.duration || 0, currentTime + 10))}>
                            <SkipForward className="w-5 h-5" />
                        </Button>
                    </div>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\views\Sessions\SessionsList.tsx
```typescript
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Play, Loader2 } from 'lucide-react';
import { api } from '../../services/api';

interface Session {
    id: string;
    sessionId: string;
    startTime: number;
    endTime?: number;
    sport: string;
    anomalies: any[]; // Expecting count or array
}

export const SessionsList = () => {
    const navigate = useNavigate();
    const [sessions, setSessions] = useState<Session[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchSessions = async () => {
            try {
                const data = await api.get('/sessions');
                if (Array.isArray(data)) {
                    // Map or sort data if necessary (latest first)
                    const sorted = data.sort((a: any, b: any) => b.startTime - a.startTime);
                    setSessions(sorted);
                }
            } catch (error) {
                console.error('Failed to fetch sessions:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchSessions();
    }, []);

    const formatDuration = (start: number, end?: number) => {
        if (!end) return 'Live';
        const diff = end - start;
        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        return `${minutes}m ${seconds}s`;
    };

    const formatDate = (ts: number) => new Date(ts).toLocaleDateString() + ' ' + new Date(ts).toLocaleTimeString();

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Recorded Sessions</h1>
                <Button variant="primary" onClick={() => window.location.reload()}>Refresh</Button>
            </div>

            <Card className="overflow-hidden">
                {loading ? (
                    <div className="p-12 flex justify-center text-slate-500">
                        <Loader2 className="animate-spin w-8 h-8" />
                    </div>
                ) : (
                    <table className="w-full text-left text-sm">
                        <thead className="bg-slate-900 uppercase text-slate-400 font-semibold">
                            <tr>
                                <th className="p-4">Session ID</th>
                                <th className="p-4">Sport</th>
                                <th className="p-4">Date</th>
                                <th className="p-4">Duration</th>
                                <th className="p-4">Anomalies</th>
                                <th className="p-4">Status</th>
                                <th className="p-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-800">
                            {sessions.length === 0 && (
                                <tr>
                                    <td colSpan={7} className="p-8 text-center text-slate-500">No sessions found.</td>
                                </tr>
                            )}
                            {sessions.map((session) => (
                                <tr key={session.id || session.sessionId} className="hover:bg-slate-800/50 transition-colors">
                                    <td className="p-4 font-mono text-slate-300">{session.sessionId}</td>
                                    <td className="p-4 font-medium">{session.sport}</td>
                                    <td className="p-4 text-slate-400">{formatDate(session.startTime)}</td>
                                    <td className="p-4 text-slate-400">{formatDuration(session.startTime, session.endTime)}</td>
                                    <td className="p-4">
                                        <Badge variant={session.anomalies?.length > 0 ? 'critical' : 'success'}>
                                            {session.anomalies?.length || 0} Detected
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Badge variant={session.endTime ? 'outline' : 'warning'}>
                                            {session.endTime ? 'COMPLETED' : 'LIVE'}
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            onClick={() => navigate(`/sessions/${session.sessionId}`)}
                                        >
                                            <Play className="w-4 h-4 mr-2" /> Replay
                                        </Button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </Card>
        </div>
    );
};

```

#### frontend\src\views\SystemConfig\SystemConfig.tsx
```typescript
import { useState } from 'react';
import { Network, Activity, Crosshair } from 'lucide-react';
import { Button } from '../../components/ui/Button';
import { NodeTopology } from './components/NodeTopology';
import { SensorHealth } from './components/SensorHealth';
import { CalibrationWizard } from './components/CalibrationWizard';

type Tab = 'topology' | 'health' | 'calibration';

const SystemConfig = () => {
    const [activeTab, setActiveTab] = useState<Tab>('topology');

    return (
        <div className="space-y-6">
            {/* Top Bar Actions */}
            <div className="flex justify-between items-center bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
                <div className="flex gap-2">
                    <Button
                        variant={activeTab === 'topology' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('topology')}
                        className="gap-2"
                    >
                        <Network className="w-4 h-4" /> Node Topology
                    </Button>
                    <Button
                        variant={activeTab === 'health' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('health')}
                        className="gap-2"
                    >
                        <Activity className="w-4 h-4" /> Sensor Health
                    </Button>
                    <Button
                        variant={activeTab === 'calibration' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('calibration')}
                        className="gap-2"
                    >
                        <Crosshair className="w-4 h-4" /> Calibration
                    </Button>
                </div>
                <div className="flex gap-2">
                    <Button variant="secondary" size="sm">Export Config</Button>
                    <Button variant="primary" size="sm">Save Changes</Button>
                </div>
            </div>

            {/* Tab Content */}
            <div className="min-h-[600px]">
                {activeTab === 'topology' && <NodeTopology />}
                {activeTab === 'health' && <SensorHealth />}
                {activeTab === 'calibration' && <CalibrationWizard />}
            </div>
        </div>
    );
};

export default SystemConfig;

```

#### frontend\src\views\SystemConfig\components\CalibrationWizard.tsx
```typescript
import { useState, useEffect } from 'react';
import { Button } from '../../../components/ui/Button';
import { Camera, CheckCircle, RefreshCw, AlertTriangle } from 'lucide-react';
import { Api } from '../../../services/api';

type Step = 'SELECT' | 'CAPTURE' | 'VERIFY' | 'COMPLETE';

export function CalibrationWizard() {
    const [step, setStep] = useState<Step>('SELECT');
    const [progress, setProgress] = useState(0);
    const [selectedNode, setSelectedNode] = useState<string | null>(null);
    const [nodes, setNodes] = useState<any[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    // Fetch nodes
    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                setNodes(data.nodes);
            } catch (err) {
                console.error('Failed to fetch nodes for calibration', err);
            }
        };
        fetchNodes();
    }, []);

    const handleStart = async () => {
        if (!selectedNode) return;
        setStep('CAPTURE');
        setProgress(10);
        setError(null);

        try {
            // Start calibration on backend
            const result = await Api.calibrateNode(selectedNode);

            // Progress animation simulation while waiting or based on real status 
            // but for now we just show it finish
            setProgress(50);
            setTimeout(() => {
                setProgress(100);
                setStep('VERIFY');
            }, 1500);

        } catch (err: any) {
            setError(err.message || 'Calibration failed');
            setStep('SELECT');
        }
    };

    const reset = () => {
        setStep('SELECT');
        setProgress(0);
        setSelectedNode(null);
        setError(null);
    };

    return (
        <div className="h-[500px] bg-navy-900 border border-navy-800 rounded-xl p-6 flex flex-col">
            <div className="mb-6">
                <h3 className="text-xl font-bold text-white mb-2">Sensor Calibration</h3>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <span className={step === 'SELECT' ? 'text-indigo-400 font-bold' : ''}>1. Select Node</span>
                    <span>→</span>
                    <span className={step === 'CAPTURE' ? 'text-indigo-400 font-bold' : ''}>2. Capture</span>
                    <span>→</span>
                    <span className={step === 'VERIFY' ? 'text-indigo-400 font-bold' : ''}>3. Verify</span>
                </div>
            </div>

            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-navy-700 rounded-xl bg-navy-800/30 p-8">
                {step === 'SELECT' && (
                    <div className="text-center space-y-4 w-full">
                        <div className="bg-navy-700 p-4 rounded-full inline-block">
                            <Camera className="w-8 h-8 text-indigo-400" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Select a Node to Calibrate</h4>
                        {error && <div className="text-red-500 text-xs">{error}</div>}
                        <div className="grid grid-cols-2 gap-3 w-full max-w-md mx-auto">
                            {nodes.length > 0 ? nodes.map(node => (
                                <button
                                    key={node.nodeId}
                                    onClick={() => setSelectedNode(node.nodeId)}
                                    className={`p-3 rounded border text-sm truncate ${selectedNode === node.nodeId ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node.nodeId}
                                </button>
                            )) : (
                                <div className="col-span-2 text-slate-500 text-xs">No nodes found. Using demo nodes...</div>
                            )}

                            {/* DEMO FALLBACK if no real nodes */}
                            {nodes.length === 0 && ['CAM-01', 'CAM-02'].map(node => (
                                <button
                                    key={node}
                                    onClick={() => setSelectedNode(node)}
                                    className={`p-3 rounded border text-sm ${selectedNode === node ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node}
                                </button>
                            ))}
                        </div>
                        <Button
                            variant="primary"
                            disabled={!selectedNode}
                            onClick={handleStart}
                        >
                            Start Calibration
                        </Button>
                    </div>
                )}

                {step === 'CAPTURE' && (
                    <div className="text-center space-y-6 w-full max-w-md">
                        <RefreshCw className="w-12 h-12 text-indigo-400 animate-spin mx-auto" />
                        <div>
                            <h4 className="text-lg font-medium text-white mb-1">Calibrating {selectedNode}...</h4>
                            <p className="text-sm text-slate-400">Capturing extrinsic parameters and aligning with point cloud.</p>
                        </div>
                        <div className="w-full bg-navy-950 rounded-full h-2.5 overflow-hidden">
                            <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-100" style={{ width: `${progress}%` }}></div>
                        </div>
                        <p className="text-xs text-slate-500 font-mono">{progress}% Complete</p>
                    </div>
                )}

                {step === 'VERIFY' && (
                    <div className="text-center space-y-4">
                        <AlertTriangle className="w-12 h-12 text-amber-400 mx-auto" />
                        <h4 className="text-lg font-medium text-white">Verification Required</h4>
                        <p className="text-sm text-slate-400 max-w-xs mx-auto">
                            The calculated transform has a reprojection error of <span className="text-white font-mono">0.024m</span>. This is within acceptable limits.
                        </p>
                        <div className="flex gap-3 justify-center">
                            <Button variant="secondary" onClick={reset}>Discard</Button>
                            <Button variant="primary" onClick={() => setStep('COMPLETE')}>Apply Transform</Button>
                        </div>
                    </div>
                )}

                {step === 'COMPLETE' && (
                    <div className="text-center space-y-4">
                        <div className="bg-emerald-500/10 p-4 rounded-full inline-block">
                            <CheckCircle className="w-12 h-12 text-emerald-500" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Calibration Successful</h4>
                        <p className="text-sm text-slate-400">Node {selectedNode} is now active and aligned.</p>
                        <Button variant="ghost" onClick={reset}>Calibrate Another Node</Button>
                    </div>
                )}
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\NodeTopology.tsx
```typescript
import { Plus } from 'lucide-react';
import { TopologyCanvas } from './TopologyCanvas';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const NODES = [
    { id: 'NODE_001', name: 'Gate B Cam 1', status: 'online', type: 'Camera' },
    { id: 'NODE_002', name: 'Gate B LIDAR', status: 'offline', type: 'LIDAR' },
    { id: 'NODE_003', name: 'Field Cam Main', status: 'online', type: 'Camera' },
];

export function NodeTopology() {
    return (
        <div className="flex flex-col lg:flex-row gap-6 h-[700px]">
            {/* Left Panel: Node List */}
            <div className="w-full lg:w-[300px] flex flex-col gap-4">
                <Card className="flex-1 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-white">Nodes</h3>
                        <Button size="icon" variant="ghost"><Plus className="w-4 h-4" /></Button>
                    </div>

                    <div className="space-y-3 flex-1 overflow-y-auto">
                        {NODES.map(node => (
                            <div key={node.id} className="p-3 bg-navy-900 rounded-lg border border-navy-700 hover:border-indigo-500 cursor-pointer transition-colors">
                                <div className="flex justify-between items-start mb-1">
                                    <div className="font-mono text-xs text-slate-500">{node.id}</div>
                                    <Badge variant={node.status === 'online' ? 'success' : 'critical'} size="sm" className="h-2 w-2 p-0 rounded-full"> </Badge>
                                </div>
                                <div className="font-bold text-sm text-slate-200">{node.name}</div>
                                <div className="text-xs text-indigo-400 mt-1">{node.type}</div>
                            </div>
                        ))}
                    </div>

                    <Button variant="secondary" fullWidth className="mt-4">Add New Node</Button>
                </Card>
            </div>

            {/* Right Panel: 3D View */}
            <div className="flex-1 bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden relative">
                <TopologyCanvas />
                <div className="absolute top-4 right-4 bg-navy-800/80 p-2 rounded text-xs text-slate-400">
                    <p>Left Click: Rotate</p>
                    <p>Right Click: Pan</p>
                    <p>Scroll: Zoom</p>
                </div>

                {/* Overlay Controls */}
                <div className="absolute top-4 right-4 bg-navy-800/80 backdrop-blur p-3 rounded-lg border border-navy-700 space-y-2">
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show Frustums
                    </label>
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show LIDAR
                    </label>
                </div>
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\SensorHealth.tsx
```typescript
import { Badge } from '../../../components/ui/Badge';

export function SensorHealth() {
    return (
        <div className="bg-navy-800 rounded-xl border border-navy-700 overflow-hidden">
            <table className="w-full text-left text-sm">
                <thead className="bg-navy-900 text-slate-400 font-medium">
                    <tr>
                        <th className="p-4">Node ID</th>
                        <th className="p-4">Sensor</th>
                        <th className="p-4">Status</th>
                        <th className="p-4">FPS (Target)</th>
                        <th className="p-4">Latency</th>
                        <th className="p-4">Last Update</th>
                        <th className="p-4 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-navy-700">
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_001</td>
                        <td className="p-4">Camera</td>
                        <td className="p-4"><Badge variant="success">ONLINE</Badge></td>
                        <td className="p-4">30/30</td>
                        <td className="p-4 text-green-400">12ms</td>
                        <td className="p-4 text-slate-400">Just now</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_002</td>
                        <td className="p-4">LIDAR</td>
                        <td className="p-4"><Badge variant="critical">OFFLINE</Badge></td>
                        <td className="p-4 text-red-400">0/10</td>
                        <td className="p-4 text-slate-500">--</td>
                        <td className="p-4 text-red-400">5m ago</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\TopologyCanvas.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Grid, Center, Text } from '@react-three/drei';

const Node = ({ position, color, label }: { position: [number, number, number], color: string, label: string }) => {
    return (
        <group position={position}>
            {/* Node visual */}
            <mesh>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* Frustum Visual (Cone) */}
            <mesh position={[0, 0, 2]} rotation={[Math.PI / 2, 0, 0]}>
                <coneGeometry args={[1, 4, 32, 1, true]} />
                <meshStandardMaterial color={color} wireframe opacity={0.3} transparent />
            </mesh>

            {/* Label */}
            <Text position={[0, 1.2, 0]} fontSize={0.5} color="white" anchorX="center" anchorY="middle">
                {label}
            </Text>
        </group>
    );
};

export function TopologyCanvas() {
    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden">
            <Canvas>
                <PerspectiveCamera makeDefault position={[10, 10, 10]} fov={50} />
                <OrbitControls makeDefault />

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} />

                <Grid infiniteGrid fadeDistance={50} sectionColor="#4f46e5" cellColor="#4f46e5" sectionSize={5} cellSize={1} />

                <Center>
                    <Node position={[0, 2, 0]} color="#10b981" label="Cam-01" />
                    <Node position={[-5, 2, 5]} color="#3b82f6" label="Lidar-01" />
                    <Node position={[5, 2, 5]} color="#3b82f6" label="Lidar-02" />
                </Center>
            </Canvas>
        </div>
    );
}

```

#### frontend\src\views\Triage\AnomalyTriage.tsx
```typescript
import { useEffect, useState } from 'react';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { wsService } from '../../services/websocket';

interface TriageTask {
    id: string;
    title: string;
    time: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

export const AnomalyTriage = () => {
    const [newIncidents, setNewIncidents] = useState<TriageTask[]>([]);

    // Mock existing state for other columns
    const [investigating] = useState<TriageTask[]>([
        { id: 'A-099', title: 'Crowd Density Warning', time: '09:30 AM', severity: 'MEDIUM' },
    ]);
    const [resolved] = useState<TriageTask[]>([
        { id: 'A-055', title: 'Sensor Dropout', time: 'Yesterday', severity: 'LOW' },
    ]);

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            const newTask: TriageTask = {
                id: data.anomalyId || 'unknown',
                title: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };
            setNewIncidents(prev => [newTask, ...prev]);
        });
        return () => { };
    }, []);

    return (
        <div className="p-6 h-full text-white overflow-hidden flex flex-col">
            <h1 className="text-2xl font-bold mb-6">Anomaly Triage (Live)</h1>

            <div className="flex-1 flex gap-6 min-h-0 overflow-x-auto">
                <Column title="New Incidents" color="border-red-500" items={newIncidents} />
                <Column title="Investigating" color="border-yellow-500" items={investigating} />
                <Column title="Resolved" color="border-green-500" items={resolved} />
            </div>
        </div>
    );
};

const Column = ({ title, color, items }: any) => (
    <div className="flex-1 flex flex-col gap-4 min-w-[300px]">
        <div className={`font-semibold pb-2 border-b-2 ${color} flex justify-between`}>
            {title}
            <span className="text-slate-500 text-sm">{items.length}</span>
        </div>
        <div className="flex-1 bg-slate-900/50 rounded-lg p-2 space-y-3 overflow-y-auto">
            {items.map((item: any) => (
                <Card key={item.id} className="p-3 cursor-move hover:bg-slate-800 transition-colors">
                    <div className="flex justify-between items-start mb-2">
                        <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                        <Badge variant={item.severity.toLowerCase()}>{item.severity}</Badge>
                    </div>
                    <div className="font-medium text-sm mb-2">{item.title}</div>
                    <div className="text-xs text-slate-400">{item.time}</div>
                </Card>
            ))}
        </div>
    </div>
);

```

## 1. Root

#### deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting deployment for Motion Intelligence Grid..."

# 1. Build and Push Containers
Write-Host "Building and Pushing Containers..."
gcloud builds submit --config cloudbuild.yaml . --project $ProjectId

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# 2. Apply Terraform
Write-Host "Applying Terraform..."
cd infrastructure
terraform init
terraform apply `
    -var="project_id=$ProjectId" `
    -var="region=$Region" `
    -var="mongodb_uri=$env:MONGODB_URI" `
    -var="jwt_secret=$env:JWT_SECRET" `
    -var="admin_password=$env:ADMIN_PASSWORD" `
    -auto-approve

if ($LASTEXITCODE -ne 0) {
    Write-Error "Terraform failed!"
    exit 1
}

Write-Host "Deployment Complete!"

```

#### manual_deploy.ps1
```powershell
$ProjectId = "freeforge-481415"
$Region = "us-central1"

Write-Host "Starting Robust Deployment for Motion Intelligence Grid..." -ForegroundColor Cyan

# Function to Build and Push
function Build-And-Push {
    param(
        [string]$ServiceName,
        [string]$Path
    )
    $ImageName = "gcr.io/$ProjectId/motiongrid-$ServiceName`:latest"
    Write-Host "Processing $ServiceName..." -ForegroundColor Yellow
    
    # Build
    Write-Host "  Building $ImageName..."
    docker build -t $ImageName $Path
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Build Failed"; exit 1 }
    
    # Push
    Write-Host "  Pushing $ImageName..."
    docker push $ImageName
    if ($LASTEXITCODE -ne 0) { Write-Error "$ServiceName Push Failed"; exit 1 }
    
    Write-Host "  $ServiceName Done." -ForegroundColor Green
}

# 1. Server
Build-And-Push "api" "./server"

# 2. Simulation
Build-And-Push "simulation" "./simulation"

# 3. Frontend
Build-And-Push "frontend" "./frontend"

# 4. Terraform
Write-Host "Applying Infrastructure Updates..." -ForegroundColor Yellow
Set-Location "./infrastructure"
terraform init
terraform apply -var="project_id=$ProjectId" -var="region=$Region" -auto-approve -lock=false

if ($LASTEXITCODE -ne 0) { 
    Write-Error "Terraform Failed"
    exit 1 
}

Write-Host "Deployment Complete! 🚀" -ForegroundColor Green
Set-Location ..

```

#### cloudbuild.yaml
```yaml
steps:
  # Build API
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-api:latest', './server']
    
  # Build Simulation
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest', './simulation']
    
  # Build Frontend
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest', './frontend']

  # Push Images
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-api:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-simulation:latest']
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/motiongrid-frontend:latest']


options:
  machineType: 'N1_HIGHCPU_8'

```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # MongoDB database
  mongodb:
    image: mongo:6
    container_name: motiongrid-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: devpassword123
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - motiongrid-network
    command: --wiredTigerCacheSizeGB 1.5

  # Redis (optional, for caching)
  redis:
    image: redis:7-alpine
    container_name: motiongrid-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - motiongrid-network
    command: redis-server --appendonly yes

  # API Gateway (Node.js + Express + Socket.io)
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-api
    restart: unless-stopped
    environment:
      NODE_ENV: development
      PORT: 3001
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
      REDIS_URL: redis://redis:6379
      JWT_SECRET: dev-secret-key
      SIMULATION_API_URL: http://simulation:8000
    ports:
      - "3001:3001"
    volumes:
      - ./server/src:/app/src
    depends_on:
      - mongodb
      - redis
    networks:
      - motiongrid-network
    command: npm run dev

  # Simulation Engine (Python + FastAPI)
  simulation:
    build:
      context: ./simulation
      dockerfile: Dockerfile
    container_name: motiongrid-simulation
    restart: unless-stopped
    environment:
      PYTHONUNBUFFERED: 1
      API_PORT: 8000
      MONGODB_URI: mongodb://admin:devpassword123@mongodb:27017/motiongrid?authSource=admin
    ports:
      - "8000:8000"
    volumes:
      - ./simulation/src:/app/src
    depends_on:
      - mongodb
    networks:
      - motiongrid-network
    command: uvicorn src.api.server:app --host 0.0.0.0 --port 8000 --reload

  # Frontend (React SPA)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    container_name: motiongrid-frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_WS_URL: ws://localhost:3001
    ports:
      - "5173:5173"
    volumes:
      - ./frontend/src:/app/src
    networks:
      - motiongrid-network
    command: npm run dev

volumes:
  mongodb_data:
  redis_data:


networks:
  motiongrid-network:
    driver: bridge

```

#### .gcloudignore
```
node_modules/
.git/
.github/
infrastructure/.terraform/
.DS_Store
*.log
coverage/
dist/
tmp/
gcloud_temp/

```

## 2. Infrastructure

#### infrastructure\main.tf
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

resource "google_cloud_run_service" "api" {
  name     = "motiongrid-api"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-api:latest"
        ports {
            container_port = 8080
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
            name = "SIMULATION_API_URL"
            value = "https://motiongrid-simulation-rrsyyeqnbq-uc.a.run.app"
        }
        env {
          name  = "JWT_SECRET"
          value = var.jwt_secret
        }
        env {
          name  = "ADMIN_EMAIL"
          value = var.admin_email
        }
          env {
            name  = "ADMIN_PASSWORD"
            value = var.admin_password
          }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

resource "google_cloud_run_service" "simulation" {
  name     = "motiongrid-simulation"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-simulation:latest"
        ports {
            container_port = 8000
        }
        resources {
          limits = {
            cpu    = "2000m"
            memory = "2Gi"
          }
        }
        env {
          name  = "MONGODB_URI"
          value = var.mongodb_uri
        }
        env {
          name  = "API_URL"
          value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service" "frontend" {
  name     = "motiongrid-frontend"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/motiongrid-frontend:latest"
        ports {
            container_port = 80
        }
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        env {
            name = "VITE_API_URL"
            value = google_cloud_run_service.api.status[0].url
        }
      }
    }
  }
}

resource "google_cloud_run_service_iam_member" "public_access_frontend" {
  service  = google_cloud_run_service.frontend.name
  location = google_cloud_run_service.frontend.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

# Storage Bucket for Session Recordings
resource "google_storage_bucket" "sessions" {
  name     = "${var.project_id}-sessions"
  location = var.region
  
  uniform_bucket_level_access = true
  
  lifecycle_rule {
    action { type = "Delete" }
    condition { age = 180 }  # Keep recordings 6 months
  }
}

resource "google_cloud_run_service_iam_member" "public_access_api" {
  service  = google_cloud_run_service.api.name
  location = google_cloud_run_service.api.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_service_iam_member" "public_access_simulation" {
  service  = google_cloud_run_service.simulation.name
  location = google_cloud_run_service.simulation.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "frontend_url" {
  value = google_cloud_run_service.frontend.status[0].url
}

```

#### infrastructure\variables.tf
```hcl
variable "project_id" {
  description = "GCP Project ID"
  type        = string
  default     = "freeforge-481415"
}

variable "region" {
  description = "GCP Region"
  type        = string
  default     = "us-central1"
}

variable "mongodb_uri" {
    description = "MongoDB Connection String"
    type = string
    sensitive = true
}

variable "jwt_secret" {
    description = "JWT Secret for authentication"
    type = string
    sensitive = true
}

variable "admin_email" {
    description = "Default admin email"
    type = string
    default = "admin@freeforge.com"
}

variable "admin_password" {
    description = "Default admin password"
    type = string
    sensitive = true
}


```

## 3. Server

#### server\Dockerfile
```
# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine AS production
WORKDIR /app
ENV NODE_ENV=production
COPY package*.json ./
RUN npm install --only=production
COPY --from=builder /app/dist ./dist
EXPOSE 8080
CMD ["node", "dist/index.js"]

```

#### server\package.json
```json
{
  "name": "motiongrid-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.2",
    "mongoose": "^8.0.3",
    "redis": "^4.6.11",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "joi": "^17.11.0",
    "axios": "^1.6.2",
    "typescript": "^5.3.3",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/express": "^4.17.21",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11"
  }
}
```

#### server\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es2016",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": false,
        "noImplicitAny": false,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "noEmitOnError": false,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts"
    ]
}
```

#### server\src\database.ts
```typescript
import mongoose from 'mongoose';

export const connectDB = async () => {
    const uri = process.env.MONGODB_URI;

    if (!uri) {
        console.error('❌ MONGODB_URI environment variable is required');
        // In production, we might want to throw error, but for now we log error
        // throwing error would crash loop which is handled by index.ts
        throw new Error('MONGODB_URI environment variable is required');
    }

    if (uri === 'memory') {
        console.warn('⚠️ Running in IN-MEMORY mode (dev only). Persistence disabled.');
        return;
    }

    try {
        console.log(`[DATABASE] Connecting to MongoDB (URI ending in: ...${uri.slice(-4)})`);
        await mongoose.connect(uri, {
            serverSelectionTimeoutMS: 10000, // 10 seconds
        });
        console.log('✅ MongoDB connected successfully');
    } catch (error: any) {
        console.error('❌ MongoDB connection failed:', error.message);
        throw error;
    }
};

```

#### server\src\index.ts
```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { connectDB } from './database';
import { socketService } from './services/SocketService';
import { authenticate as authMiddleware } from './middleware/auth';

// Import routes at the top as per best practices
import authRouter from './routes/auth';
import nodesRouter from './routes/nodes';
import sessionsRouter from './routes/sessions';
import anomaliesRouter from './routes/anomalies';
import entitiesRouter from './routes/entities';
import simulationRouter from './routes/simulation';
import analyticsRouter from './routes/analytics';

// Load environment variables
dotenv.config();

console.log('🚀 [STARTUP] Motion Intelligence Grid API initiating...');
console.log(`[STARTUP] Environment: ${process.env.NODE_ENV || 'development'}`);

const app = express();
const httpServer = createServer(app);

// BIND PORT IMMEDIATELY FOR CLOUD RUN HEALTH CHECKS
const PORT = process.env.PORT || 8080;
httpServer.listen(PORT, () => {
    console.log(`✅ [STARTUP] API listening on port ${PORT}`);
});

const io = new Server(httpServer, {
    cors: {
        origin: process.env.CLIENT_URL || '*',
        methods: ['GET', 'POST'],
    },
});

// Initialize SocketService
socketService.init(io);

// Middleware
app.use(cors());
app.use(helmet());
app.use(express.json());

// Basic health check (Always available)
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date(),
        db: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        uptime: process.uptime()
    });
});

// Routes
app.use('/api/auth', authRouter);
app.use('/api/nodes', authMiddleware, nodesRouter);
app.use('/api/sessions', authMiddleware, sessionsRouter);
app.use('/api/anomalies', authMiddleware, anomaliesRouter);
app.use('/api/entities', authMiddleware, entitiesRouter);
app.use('/api/simulation', authMiddleware, simulationRouter);
app.use('/api/analytics', authMiddleware, analyticsRouter);

// Internal Endpoints for Simulation Bridge
app.post('/internal/entity-update', async (req, res) => {
    const { sessionId, entities, stats, sentAt } = req.body;
    const latencyMs = sentAt ? Math.round((Date.now() / 1000 - sentAt) * 1000) : 0;
    socketService.emit('entity:tracking', { entities, stats, latencyMs }, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

app.post('/internal/anomaly', async (req, res) => {
    const { sessionId, anomaly } = req.body;
    socketService.emit('anomaly:detected', anomaly, sessionId ? `session:${sessionId}` : undefined);
    res.json({ status: 'ok' });
});

const startServer = async () => {
    try {
        console.log('[STARTUP] Connecting to database...');
        await connectDB();
        console.log('✅ [STARTUP] Database connected successfully.');

        if (mongoose.connection.readyState === 1) {
            const { User } = await import('./models/User');
            const adminEmail = process.env.ADMIN_EMAIL || 'admin@freeforge.com';
            const adminPassword = process.env.ADMIN_PASSWORD || 'nimda';

            console.log(`[STARTUP] Checking for admin: ${adminEmail}`);
            const adminUser = await User.findOne({ email: adminEmail });

            if (!adminUser) {
                console.log(`[STARTUP] Seeding default admin user: ${adminEmail} with password: ${adminPassword}...`);
                const newAdmin = new User({
                    email: adminEmail,
                    passwordHash: adminPassword,
                    username: 'admin',
                    role: 'ADMIN'
                });
                await newAdmin.save();
                console.log('✅ [STARTUP] Default admin created.');
            } else {
                console.log(`[STARTUP] Admin user ${adminEmail} exists. Updating password to environment current value...`);
                adminUser.passwordHash = adminPassword;
                await adminUser.save();
                console.log('✅ [STARTUP] Admin password updated successfully.');
            }
        }
    } catch (error) {
        console.error('❌ [STARTUP] initialization failed:', error);
    }
};

startServer();

```

#### server\src\middleware\auth.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface UserPayload {
    userId: string;
    role: string;
    email: string;
}

declare global {
    namespace Express {
        interface Request {
            user?: UserPayload;
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    // Skip auth for login/public routes if applying globally, 
    // but usually we apply this middleware to specific routes.

    const authHeader = req.headers.authorization;
    let token = '';

    if (authHeader) {
        token = authHeader.split(' ')[1]; // Bearer <token>
    } else if (req.query.token) {
        token = req.query.token as string;
    }

    if (!token) {
        return res.status(401).json({ error: 'Token missing or Authorization header missing' });
    }

    try {
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const decoded = jwt.verify(token, secret) as UserPayload;
        req.user = decoded;
        next();
    } catch (err) {
        return res.status(401).json({ error: 'Invalid or expired token' });
    }
};

export const requireRole = (roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        if (!req.user || !roles.includes(req.user.role)) {
            return res.status(403).json({ error: 'Insufficient permissions' });
        }
        next();
    };
};

```

#### server\src\middleware\validate.ts
```typescript
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

export const validateBody = (schema: Joi.Schema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({ error: error.details[0].message });
        }
        next();
    };
};

```

#### server\src\models\Anomaly.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IAnomaly extends Document {
    anomalyId: string;
    sessionId: mongoose.Types.ObjectId;
    entityIds: mongoose.Types.ObjectId[];
    nodeIds: string[];
    occurredAt: Date;
    duration: number;
    type: 'GEOGRAPHICS' | 'KINETICS' | 'PROXEMICS' | 'ATMOSPHERICS';
    subtype: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    scenario?: string;
    headline: string;
    description: string;
    baselineText: string;
    anomalyText: string;
    metrics: {
        baselineDelta: number;
        confidence: number;
        riskScore: number;
    };
    ruleOfThreeHit: boolean;
    relatedAnomalies: mongoose.Types.ObjectId[];
    zone: string;
    location: { x: number; y: number; z: number };
    triage: {
        status: 'UNREVIEWED' | 'CONFIRMED' | 'DOWNGRADED' | 'FALSE_POSITIVE';
        notes?: string;
    };
    tags: string[];
    createdAt: Date;
    updatedAt: Date;
}

const AnomalySchema: Schema = new Schema({
    anomalyId: { type: String, required: true, unique: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    entityIds: [{ type: Schema.Types.ObjectId, ref: 'Entity' }],
    nodeIds: [String],
    occurredAt: { type: Date, default: Date.now },
    duration: { type: Number, default: 0 },
    type: { type: String, enum: ['GEOGRAPHICS', 'KINETICS', 'PROXEMICS', 'ATMOSPHERICS'], required: true },
    subtype: String,
    severity: { type: String, enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'], default: 'LOW' },
    scenario: String,
    headline: String,
    description: String,
    baselineText: String,
    anomalyText: String,
    metrics: {
        baselineDelta: Number,
        confidence: Number,
        riskScore: Number
    },
    ruleOfThreeHit: { type: Boolean, default: false },
    relatedAnomalies: [{ type: Schema.Types.ObjectId, ref: 'Anomaly' }],
    zone: String,
    location: {
        x: Number,
        y: Number,
        z: Number
    },
    triage: {
        status: { type: String, enum: ['UNREVIEWED', 'CONFIRMED', 'DOWNGRADED', 'FALSE_POSITIVE'], default: 'UNREVIEWED' },
        notes: String,
        triageAt: Date,
        triagedBy: String
    },
    tags: [String]
}, { timestamps: true });

export const Anomaly = mongoose.model<IAnomaly>('Anomaly', AnomalySchema);

```

#### server\src\models\Entity.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IEntity extends Document {
    entityId: string;
    type: 'PERSON' | 'OBJECT';
    role: 'PLAYER' | 'OFFICIAL' | 'SPECTATOR' | 'BALL';
    team?: 'HOME' | 'AWAY';
    name?: string;
    lastPosition: { x: number; y: number; z: number };
    lastVelocity: { x: number; y: number; z: number };
    lastSeenAt: Date;
    sessionId?: string;
}

const EntitySchema: Schema = new Schema({
    entityId: { type: String, required: true, unique: true },
    type: { type: String, enum: ['PERSON', 'OBJECT'], required: true },
    role: { type: String, enum: ['PLAYER', 'OFFICIAL', 'SPECTATOR', 'BALL'], default: 'SPECTATOR' },
    team: { type: String, enum: ['HOME', 'AWAY'] },
    name: String,
    lastPosition: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastVelocity: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    lastSeenAt: { type: Date, default: Date.now },
    sessionId: String
}, { timestamps: true });

export const Entity = mongoose.model<IEntity>('Entity', EntitySchema);

```

#### server\src\models\Node.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INode extends Document {
    nodeId: string;
    name: string;
    type: 'EDGE_NODE';
    status: 'ONLINE' | 'OFFLINE' | 'DEGRADED';
    position: { x: number; y: number; z: number };
    orientation: { pitch: number; yaw: number; roll: number };
    sensors: {
        camera: {
            enabled: boolean;
            resolution: { width: number; height: number };
            fps: number;
            fov: number;
            exposure: number;
            gain: number;
        };
        lidar: {
            enabled: boolean;
            model: string;
            channels: number;
            pointsPerSecond: number;
            range: number;
            accuracy: number;
        };
        imu: {
            enabled: boolean;
            sampleRate: number;
            accelRange: number;
            gyroRange: number;
        };
    };
    calibration: {
        intrinsic: {
            cameraMatrix: number[][];
            distortion: number[];
        };
        extrinsic: {
            rotationMatrix: number[][];
            translationVector: number[];
        };
        lidarToCameraTransform: number[][];
        calibrationQuality: number;
        calibratedAt: Date;
    };
    network: {
        ipAddress: string;
        port: number;
        ptpDomain: number;
        clockOffset: number;
        lastSyncAt: Date;
    };
    sessionId?: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const NodeSchema: Schema = new Schema({
    nodeId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    type: { type: String, default: 'EDGE_NODE' },
    status: { type: String, enum: ['ONLINE', 'OFFLINE', 'DEGRADED'], default: 'OFFLINE' },
    position: {
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
        z: { type: Number, default: 0 }
    },
    orientation: {
        pitch: { type: Number, default: 0 },
        yaw: { type: Number, default: 0 },
        roll: { type: Number, default: 0 }
    },
    sensors: {
        camera: {
            enabled: { type: Boolean, default: true },
            resolution: {
                width: { type: Number, default: 1920 },
                height: { type: Number, default: 1080 }
            },
            fps: { type: Number, default: 30 },
            fov: { type: Number, default: 90 },
            exposure: { type: Number, default: 50 },
            gain: { type: Number, default: 0 }
        },
        lidar: {
            enabled: { type: Boolean, default: true },
            model: { type: String, default: 'VLP-16' },
            channels: { type: Number, default: 16 },
            pointsPerSecond: { type: Number, default: 300000 },
            range: { type: Number, default: 100 },
            accuracy: { type: Number, default: 0.03 }
        },
        imu: {
            enabled: { type: Boolean, default: true },
            sampleRate: { type: Number, default: 100 },
            accelRange: { type: Number, default: 16 },
            gyroRange: { type: Number, default: 2000 }
        }
    },
    calibration: {
        intrinsic: {
            cameraMatrix: [[Number]],
            distortion: [Number]
        },
        extrinsic: {
            rotationMatrix: [[Number]],
            translationVector: [Number]
        },
        lidarToCameraTransform: [[Number]],
        calibrationQuality: { type: Number, default: 0 },
        calibratedAt: Date
    },
    network: {
        ipAddress: String,
        port: Number,
        ptpDomain: { type: Number, default: 0 },
        clockOffset: { type: Number, default: 0 },
        lastSyncAt: Date
    },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session' }
}, { timestamps: true });

export const Node = mongoose.model<INode>('Node', NodeSchema);

```

#### server\src\models\SensorFrame.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISensorFrame extends Document {
    frameId: string;
    sessionId: mongoose.Types.ObjectId;
    nodeId: string;
    timestamp: Date;
    frameNumber: number;
    camera?: {
        imagePath: string;
        resolution: { width: number; height: number };
    };
    lidar?: {
        pointCloudPath: string;
        pointCount: number;
    };
    fusion?: {
        detectedEntities: any[];
        processingTime: number;
    };
    createdAt: Date;
}

const SensorFrameSchema: Schema = new Schema({
    frameId: { type: String, required: true },
    sessionId: { type: Schema.Types.ObjectId, ref: 'Session', required: true },
    nodeId: { type: String, required: true },
    timestamp: { type: Date, required: true },
    frameNumber: Number,
    camera: {
        imagePath: String,
        resolution: { width: Number, height: Number }
    },
    lidar: {
        pointCloudPath: String,
        pointCount: Number
    },
    fusion: {
        detectedEntities: [],
        processingTime: Number
    }
}, {
    timeseries: {
        timeField: 'timestamp',
        metaField: 'nodeId',
        granularity: 'seconds'
    },
    expireAfterSeconds: 86400 * 7 // 7 days retention
});

export const SensorFrame = mongoose.model<ISensorFrame>('SensorFrame', SensorFrameSchema);

```

#### server\src\models\Session.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface ISession extends Document {
    sessionId: string;
    name: string;
    sport: 'BASKETBALL' | 'SOCCER' | 'COMBAT' | 'CUSTOM';
    venue: string;
    startedAt: Date;
    endedAt?: Date;
    duration: number;
    status: 'RECORDING' | 'STOPPED' | 'PROCESSING' | 'READY';
    nodeIds: string[];
    stats: {
        totalFrames: number;
        totalEntities: number;
        totalAnomalies: number;
        anomalyBreakdown: {
            critical: number;
            high: number;
            medium: number;
            low: number;
        };
        avgOccupancy: number;
        peakOccupancy: number;
        avgActivityIndex: number;
    };
    scenario: {
        entityCount: number;
        crowdDensity: number;
        anomalyRate: number;
        environmentConfig: {
            lighting: 'BRIGHT' | 'DIM' | 'VARIABLE';
            weather?: 'CLEAR' | 'RAIN' | 'SNOW';
        };
    };
    dataPath: string;
    thumbnailPath?: string;
    createdAt: Date;
    updatedAt: Date;
}

const SessionSchema: Schema = new Schema({
    sessionId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    sport: { type: String, enum: ['BASKETBALL', 'SOCCER', 'COMBAT', 'CUSTOM'], required: true },
    venue: String,
    startedAt: { type: Date, default: Date.now },
    endedAt: Date,
    duration: { type: Number, default: 0 },
    status: { type: String, enum: ['RECORDING', 'STOPPED', 'PROCESSING', 'READY'], default: 'RECORDING' },
    nodeIds: [String],
    stats: {
        totalFrames: { type: Number, default: 0 },
        totalEntities: { type: Number, default: 0 },
        totalAnomalies: { type: Number, default: 0 },
        anomalyBreakdown: {
            critical: { type: Number, default: 0 },
            high: { type: Number, default: 0 },
            medium: { type: Number, default: 0 },
            low: { type: Number, default: 0 }
        },
        avgOccupancy: { type: Number, default: 0 },
        peakOccupancy: { type: Number, default: 0 },
        avgActivityIndex: { type: Number, default: 0 }
    },
    scenario: {
        entityCount: { type: Number, default: 0 },
        crowdDensity: { type: Number, default: 0 },
        anomalyRate: { type: Number, default: 0 },
        environmentConfig: {
            lighting: { type: String, default: 'BRIGHT' },
            weather: String
        }
    },
    dataPath: String,
    thumbnailPath: String
}, { timestamps: true });

export const Session = mongoose.model<ISession>('Session', SessionSchema);

```

#### server\src\models\User.ts
```typescript
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
    username: string;
    email: string;
    passwordHash: string;
    role: 'OPERATOR' | 'ANALYST' | 'ADMIN';
    permissions: string[];
    preferences: {
        theme: 'DARK' | 'LIGHT';
    };
    createdAt: Date;
    updatedAt: Date;
    validatePassword(password: string): Promise<boolean>;
}

const UserSchema: Schema = new Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },
    role: { type: String, enum: ['OPERATOR', 'ANALYST', 'ADMIN'], default: 'OPERATOR' },
    permissions: [String],
    preferences: {
        theme: { type: String, default: 'DARK' }
    }
}, { timestamps: true });

UserSchema.pre<IUser>('save', async function (next) {
    if (!this.isModified('passwordHash')) return next();
    try {
        const salt = await bcrypt.genSalt(10);
        this.passwordHash = await bcrypt.hash(this.passwordHash, salt);
        next();
    } catch (err: any) {
        next(err);
    }
});

UserSchema.methods.validatePassword = async function (password: string): Promise<boolean> {
    return await bcrypt.compare(password, this.passwordHash);
};

export const User = mongoose.model<IUser>('User', UserSchema);

```

#### server\src\routes\analytics.ts
```typescript
import express from 'express';

const router = express.Router();

router.get('/stats', (req, res) => {
    // Return aggregated stats
    res.json({
        totalAnomalies: 42,
        activeEntities: 15,
        systemHealth: 98.6,
        uptimeSeconds: 3600
    });
});

router.get('/performance', (req, res) => {
    // Return system performance metrics (FPS, Latency)
    res.json({
        simulationFps: 29.8,
        networkLatencyMs: 12,
        processingTimeMs: 4
    });
});

export default router;

```

#### server\src\routes\anomalies.ts
```typescript
import express from 'express';
import { Anomaly } from '../models/Anomaly';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, severity, status } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (severity) query.severity = severity;
        if (status || req.query.triageStatus) query['triage.status'] = status || req.query.triageStatus;

        const anomalies = await Anomaly.find(query).sort({ occurredAt: -1 }).limit(100);
        res.json({ anomalies, count: anomalies.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id/triage', async (req, res) => {
    try {
        const { status, notes } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            {
                'triage.status': status,
                'triage.notes': notes,
                'triage.triageAt': new Date()
            },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/tag', async (req, res) => {
    try {
        const { tags } = req.body;
        const anomaly = await Anomaly.findOneAndUpdate(
            { anomalyId: req.params.id },
            { $addToSet: { tags: { $each: tags } } },
            { new: true }
        );

        if (!anomaly) return res.status(404).json({ error: 'Anomaly not found' });
        res.json(anomaly);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\auth.ts
```typescript
import express from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/User';

const router = express.Router();

router.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        // Find user
        const user = await User.findOne({ email });
        if (!user) {
            console.log(`Login attempt failed: User not found (${email})`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Validate password
        const isValid = await user.validatePassword(password);
        if (!isValid) {
            console.log(`Login attempt failed: Invalid password for ${email}`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        console.log(`Login successful for ${email}`);

        // Generate Token
        const secret = process.env.JWT_SECRET || 'dev_secret_do_not_use_in_prod';
        const token = jwt.sign(
            {
                userId: user._id,
                role: user.role,
                email: user.email
            },
            secret,
            { expiresIn: '24h' }
        );

        res.json({
            token,
            user: {
                id: user._id,
                email: user.email,
                role: user.role,
                username: user.username
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.post('/register', async (req, res) => {
    // For MVP/Demo: Allow registration of first user as ADMIN, others as VIEWERS
    // Or just open registration for "OPERATOR"
    try {
        const { email, password, username } = req.body;

        const existing = await User.findOne({ $or: [{ email }, { username }] });
        if (existing) {
            return res.status(400).json({ error: 'User already exists' });
        }

        const count = await User.countDocuments();
        const role = count === 0 ? 'ADMIN' : 'OPERATOR';

        const user = new User({
            email,
            passwordHash: password, // Will be hashed by pre-save hook
            username,
            role
        });

        await user.save();

        res.status(201).json({ message: 'User created', userId: user._id });
    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({ error: 'Registration failed' });
    }
});

export default router;

```

#### server\src\routes\entities.ts
```typescript
import express from 'express';
import { Entity } from '../models/Entity';
import { SensorFrame } from '../models/SensorFrame';

const router = express.Router();

router.get('/', async (req, res) => {
    try {
        const { sessionId, type, role } = req.query;
        const query: any = {};

        if (sessionId) query.sessionId = sessionId;
        if (type) query.type = type;
        if (role) query.role = role;

        const entities = await Entity.find(query);
        res.json(entities);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const entity = await Entity.findOne({ entityId: req.params.id });
        if (!entity) return res.status(404).json({ error: 'Entity not found' });
        res.json(entity);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/track', async (req, res) => {
    try {
        const { id } = req.params;
        const { startTime, endTime } = req.query;

        // Find frames where this entity appears in fusion data
        // Note: This query depends on how SensorFrame stores fusion data
        const query: any = {
            'fusion.detectedEntities.id': id
        };

        if (startTime || endTime) {
            query.timestamp = {};
            if (startTime) query.timestamp.$gte = new Date(String(startTime));
            if (endTime) query.timestamp.$lte = new Date(String(endTime));
        }

        const frames = await SensorFrame.find(query)
            .select('timestamp fusion.detectedEntities')
            .sort({ timestamp: 1 })
            .limit(1000);

        // Extract just the relevant position data
        const path = frames.map(f => {
            const ent = f.toJSON().fusion?.detectedEntities?.find((e: any) => e.id === id);
            return {
                timestamp: f.timestamp,
                position: ent?.position
            };
        }).filter(p => p.position);

        res.json({
            entityId: id,
            path
        });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\nodes.ts
```typescript
import express from 'express';
import axios from 'axios';
import { NodeService } from '../services/NodeService';

const router = express.Router();
const nodeService = new NodeService();

router.post('/', async (req, res) => {
    try {
        const node = await nodeService.createNode(req.body);
        res.status(201).json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const nodes = await nodeService.getNodes(req.query);
        res.json({ nodes, count: nodes.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id', async (req, res) => {
    try {
        const node = await nodeService.getNode(req.params.id);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:id/stream', async (req, res) => {
    try {
        const nodeId = req.params.id;
        // Ideally use env var for simulation URL
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios({
            method: 'get',
            url: `${simulationUrl}/nodes/${nodeId}/stream`,
            responseType: 'stream'
        });

        // Forward content type (multipart/x-mixed-replace)
        res.setHeader('Content-Type', response.headers['content-type']);
        response.data.pipe(res);
    } catch (err: any) {
        // console.error('Stream proxy error:', err.message);
        res.status(503).send('Stream unavailable');
    }
});

router.post('/:id/calibrate', async (req, res) => {
    try {
        const nodeId = req.params.id;
        const simulationUrl = process.env.SIMULATION_API_URL || 'http://localhost:8000';

        const response = await axios.post(`${simulationUrl}/nodes/${nodeId}/calibrate`);
        const result = response.data;

        // Update node in database
        await nodeService.updateNode(nodeId, {
            calibration: result.calibration
        });

        res.json(result);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const node = await nodeService.updateNode(req.params.id, req.body);
        if (!node) return res.status(404).json({ error: 'Node not found' });
        res.json(node);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await nodeService.deleteNode(req.params.id);
        if (!success) return res.status(404).json({ error: 'Node not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\sessions.ts
```typescript
import express from 'express';
import { SessionService } from '../services/SessionService';

const router = express.Router();
const sessionService = new SessionService();

router.post('/', async (req, res) => {
    try {
        const session = await sessionService.createSession(req.body);
        res.status(201).json(session);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/', async (req, res) => {
    try {
        const sessions = await sessionService.getSessions(req.query);
        res.json({ sessions, count: sessions.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/start', async (req, res) => {
    try {
        const session = await sessionService.startSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.post('/:id/stop', async (req, res) => {
    try {
        const session = await sessionService.stopSession(req.params.id);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json({ success: true, session });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.patch('/:id', async (req, res) => {
    try {
        const session = await sessionService.updateSession(req.params.id, req.body);
        if (!session) return res.status(404).json({ error: 'Session not found' });
        res.json(session);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
});

router.delete('/:id', async (req, res) => {
    try {
        const success = await sessionService.deleteSession(req.params.id);
        if (!success) return res.status(404).json({ error: 'Session not found' });
        res.status(204).send();
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});


router.get('/:sessionId/frames', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const { startTime, endTime, limit = 100 } = req.query;

        // This relies on SensorFrame model being available. 
        // We might need to import it or use a service method.
        // Ideally checking SessionService first.
        const frames = await sessionService.getSessionFrames(sessionId, {
            startTime: startTime ? new Date(String(startTime)) : undefined,
            endTime: endTime ? new Date(String(endTime)) : undefined,
            limit: Number(limit)
        });

        res.json({ frames, count: frames.length });
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

router.get('/:sessionId/export', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const { format = 'json' } = req.query;

        // Use any to bypass strict type check for now or import models
        const session = await sessionService.getSession(sessionId);
        if (!session) return res.status(404).json({ error: 'Session not found' });

        const frames = await sessionService.getSessionFrames(sessionId, { limit: 10000 });

        // We'd need an AnomalyService or direct DB call here. 
        // For simplicity reusing Frame logic but we will stub Anomaly export if Service doesn't support it yet
        // or import Anomaly model directly.
        // Let's import Anomaly model dynamically to avoid circular deps or service bloat for now
        const { Anomaly } = await import('../models/Anomaly');
        const anomalies = await Anomaly.find({ sessionId: session._id }).sort({ occurredAt: 1 });

        if (format === 'csv') {
            res.setHeader('Content-Type', 'text/csv');
            res.setHeader('Content-Disposition', `attachment; filename="session-${sessionId}.csv"`);

            let csv = 'Timestamp,Type,ID,Detail\n';
            frames.forEach((f: any) => {
                csv += `${f.timestamp.toISOString()},FRAME,${f.frameNumber},\n`;
            });
            anomalies.forEach((a: any) => {
                csv += `${a.occurredAt.toISOString()},ANOMALY,${a.anomalyId},${a.type}\n`;
            });

            res.send(csv);
        } else {
            res.json({
                session,
                frames,
                anomalies,
                stats: {
                    duration: session.duration,
                    totalFrames: frames.length,
                    totalAnomalies: anomalies.length
                }
            });
        }
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
});

export default router;

```

#### server\src\routes\simulation.ts
```typescript
import express from 'express';
import { SimulationClient } from '../services/simulation_client';

const router = express.Router();

router.post('/start', async (req, res) => {
    const config = req.body;
    const success = await SimulationClient.startSimulation(config);
    if (success) {
        res.json({ message: 'Simulation started' });
    } else {
        res.status(500).json({ error: 'Failed to start simulation' });
    }
});

router.post('/stop', async (req, res) => {
    const success = await SimulationClient.stopSimulation();
    if (success) {
        res.json({ message: 'Simulation stopped' });
    } else {
        res.status(500).json({ error: 'Failed to stop simulation' });
    }
});

router.get('/status', async (req, res) => {
    const isHealthy = await SimulationClient.healthCheck();
    res.json({
        status: isHealthy ? 'running' : 'stopped',
        service: 'python-engine'
    });
});

export default router;

```

#### server\src\services\AnalyticsService.ts
```typescript
import { Session } from '../models/Session';
import { Anomaly } from '../models/Anomaly';

export class AnalyticsService {
    async getSessionStats(sessionId: string) {
        const session = await Session.findOne({ sessionId });
        if (!session) throw new Error('Session not found');

        const anomalyCount = await Anomaly.countDocuments({ sessionId: session._id });
        const criticalAnomalies = await Anomaly.countDocuments({ sessionId: session._id, severity: 'CRITICAL' });

        return {
            ...session.toJSON().stats,
            anomalyCount,
            criticalAnomalies
        };
    }

    async getGlobalStats() {
        const totalSessions = await Session.countDocuments();
        const totalAnomalies = await Anomaly.countDocuments();

        return {
            totalSessions,
            totalAnomalies,
            systemHealth: 'HEALTHY' // Placeholder
        };
    }
}

```

#### server\src\services\NodeService.ts
```typescript
import { Node, INode } from '../models/Node';

export class NodeService {
    async createNode(data: Partial<INode>): Promise<INode> {
        // Validation: Check if nodeId exists
        const existing = await Node.findOne({ nodeId: data.nodeId });
        if (existing) {
            throw new Error('Node ID already exists');
        }

        const node = new Node(data);
        return await node.save();
    }

    async getNodes(filter: any = {}): Promise<INode[]> {
        return await Node.find(filter);
    }

    async getNode(nodeId: string): Promise<INode | null> {
        return await Node.findOne({ nodeId });
    }

    async updateNode(nodeId: string, data: Partial<INode>): Promise<INode | null> {
        return await Node.findOneAndUpdate({ nodeId }, data, { new: true });
    }

    async deleteNode(nodeId: string): Promise<boolean> {
        const result = await Node.deleteOne({ nodeId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\SessionService.ts
```typescript
import { Session, ISession } from '../models/Session';
import mongoose from 'mongoose';
import { SensorFrame } from '../models/SensorFrame';

export class SessionService {
    async createSession(data: Partial<ISession>): Promise<ISession> {
        const session = new Session({
            ...data,
            sessionId: `SES_${Date.now()}`
        });
        return await session.save();
    }

    async getSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOne({ sessionId });
    }

    async getSessions(filter: any = {}): Promise<ISession[]> {
        return await Session.find(filter).sort({ createdAt: -1 });
    }

    async getSessionFrames(sessionId: string, options: { startTime?: Date, endTime?: Date, limit?: number }): Promise<any[]> {
        const session = await Session.findOne({ sessionId });
        if (!session) return [];

        const query: any = { sessionId: session._id };
        if (options.startTime || options.endTime) {
            query.timestamp = {};
            if (options.startTime) query.timestamp.$gte = options.startTime;
            if (options.endTime) query.timestamp.$lte = options.endTime;
        }

        return await SensorFrame.find(query).sort({ timestamp: 1 }).limit(options.limit || 100);
    }

    async startSession(sessionId: string): Promise<ISession | null> {
        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'RECORDING',
                startedAt: new Date()
            },
            { new: true }
        );
    }

    async stopSession(sessionId: string): Promise<ISession | null> {
        const session = await Session.findOne({ sessionId });
        if (!session) return null;

        const endedAt = new Date();
        const duration = (endedAt.getTime() - session.startedAt.getTime()) / 1000;

        return await Session.findOneAndUpdate(
            { sessionId },
            {
                status: 'STOPPED',
                endedAt,
                duration
            },
            { new: true }
        );
    }


    async updateSession(sessionId: string, data: Partial<ISession>): Promise<ISession | null> {
        return await Session.findOneAndUpdate({ sessionId }, data, { new: true });
    }

    async deleteSession(sessionId: string): Promise<boolean> {
        const result = await Session.deleteOne({ sessionId });
        return result.deletedCount === 1;
    }
}

```

#### server\src\services\simulation_client.ts
```typescript
import axios from 'axios';

const SIMULATION_API_URL = process.env.SIMULATION_API_URL || 'http://localhost:8000';

export class SimulationClient {

    static async healthCheck(): Promise<boolean> {
        try {
            const response = await axios.get(`${SIMULATION_API_URL}/health`);
            return response.data.status === 'ok';
        } catch (error) {
            console.error('Simulation API unhealthy:', error.message);
            return false;
        }
    }

    static async startSimulation(config: any): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/start`, config);
            return response.data.status === 'started';
        } catch (error) {
            console.error('Failed to start simulation:', error.message);
            return false;
        }
    }

    static async stopSimulation(): Promise<boolean> {
        try {
            const response = await axios.post(`${SIMULATION_API_URL}/simulation/stop`);
            return response.data.status === 'stopped';
        } catch (error) {
            console.error('Failed to stop simulation:', error.message);
            return false;
        }
    }
}

```

#### server\src\services\SocketService.ts
```typescript
import { Server, Socket } from 'socket.io';
import jwt from 'jsonwebtoken';

class SocketService {
    private io: Server | null = null;

    init(io: Server) {
        this.io = io;
        this.setupListeners();
    }

    private setupListeners() {
        if (!this.io) return;

        // Authentication Middleware
        this.io.use((socket, next) => {
            const token = socket.handshake.auth.token || socket.handshake.query.token;

            if (!token) {
                return next(new Error('Authentication required'));
            }

            try {
                const secret = process.env.JWT_SECRET;
                if (!secret) {
                    console.error('❌ CRITICAL: JWT_SECRET environment variable is missing! Falling back to dev secret (INSECURE)');
                }
                const decoded = jwt.verify(token as string, secret || 'dev_secret_do_not_use_in_prod');
                (socket as any).user = decoded;
                next();
            } catch (err) {
                next(new Error('Invalid token'));
            }
        });

        this.setupHandlers();
    }

    private setupHandlers() {
        if (!this.io) return;

        this.io.on('connection', (socket: Socket) => {
            const user = (socket as any).user;
            console.log(`Client connected: ${socket.id} (User: ${user?.email || 'Unknown'})`);

            socket.on('disconnect', () => {
                console.log('Client disconnected:', socket.id);
            });

            // Handle subscriptions
            socket.on('subscribe:session', (data) => {
                console.log(`Client ${socket.id} subscribed to session ${data.sessionId}`);
                socket.join(`session:${data.sessionId}`);
            });

            socket.on('subscribe:node', (data) => {
                console.log(`Client ${socket.id} subscribed to node ${data.nodeId}`);
                socket.join(`node:${data.nodeId}`);
            });
        });
    }

    emit(event: string, data: any, room?: string) {
        if (!this.io) {
            console.warn('SocketService not initialized');
            return;
        }

        if (room) {
            this.io.to(room).emit(event, data);
        } else {
            this.io.emit(event, data);
        }
    }
}

export const socketService = new SocketService();

```

#### server\src\tests\integration\session-flow.test.ts
```typescript
import request from 'supertest';
import app from '../../index'; // Assuming index.ts exports app
import { connectDB } from '../../database';
import mongoose from 'mongoose';

describe('Integration: Session Lifecycle', () => {
    let authToken: string;
    let sessionId: string;

    beforeAll(async () => {
        // Ensure DB is connected (likely Memory or Real)
        await connectDB();
    });

    afterAll(async () => {
        await mongoose.connection.close();
    });

    it('should login and receive a token', async () => {
        // Seed or assuming default admin exists from index.ts seed logic
        const response = await request(app)
            .post('/api/auth/login')
            .send({
                email: 'admin@freeforge.com',
                password: 'nimda'
            });

        expect(response.status).toBe(200);
        expect(response.body).toHaveProperty('token');
        authToken = response.body.token;
    });

    it('should create a new session', async () => {
        const response = await request(app)
            .post('/api/sessions')
            .set('Authorization', `Bearer ${authToken}`)
            .send({
                name: 'Integration Test Session',
                sport: 'BASKETBALL',
                duration: 60
            });

        expect(response.status).toBe(201);
        expect(response.body).toHaveProperty('sessionId');
        expect(response.body.status).toBe('SCHEDULED');
        sessionId = response.body.sessionId;
    });

    it('should start the session', async () => {
        const response = await request(app)
            .post(`/api/sessions/${sessionId}/start`)
            .set('Authorization', `Bearer ${authToken}`);

        expect(response.status).toBe(200);
        expect(response.body.session.status).toBe('RECORDING');
    });

    it('should retrieve empty frames list initially', async () => {
        const response = await request(app)
            .get(`/api/sessions/${sessionId}/frames`)
            .set('Authorization', `Bearer ${authToken}`);

        expect(response.status).toBe(200);
        expect(Array.isArray(response.body.frames)).toBe(true);
        // Might be empty if no sim running
        expect(response.body.count).toBeGreaterThanOrEqual(0);
    });

    it('should stop the session', async () => {
        const response = await request(app)
            .post(`/api/sessions/${sessionId}/stop`)
            .set('Authorization', `Bearer ${authToken}`);

        expect(response.status).toBe(200);
        expect(response.body.session.status).toBe('COMPLETED');
    });

    it('should export the session data as JSON', async () => {
        const response = await request(app)
            .get(`/api/sessions/${sessionId}/export?format=json`)
            .set('Authorization', `Bearer ${authToken}`);

        expect(response.status).toBe(200);
        expect(response.body).toHaveProperty('session');
    });
});

```

#### server\src\__tests__\integration\session-flow.test.ts
```typescript
import request from 'supertest';
// Mocking app import since we might not export it correctly for testing in index.ts
// In a real setup, we'd export `app` from app.ts and import it in index.ts
// For now, pseudo-integration test or need to refactor index.ts
// Refactoring index.ts to export app is best practice.

describe('Session Flow Integration', () => {
    it('placeholder for integration test', async () => {
        expect(true).toBe(true);
    });
});

```

#### server\src\__tests__\services\NodeService.test.ts
```typescript
import { NodeService } from '../../services/NodeService';
import { Node } from '../../models/Node';

// Mock the Mongoose Model
jest.mock('../../models/Node');

describe('NodeService', () => {
    let nodeService: NodeService;

    beforeEach(() => {
        nodeService = new NodeService();
        jest.clearAllMocks();
    });

    it('should create a node successfully', async () => {
        const mockNodeData = {
            nodeId: 'TEST_001',
            name: 'Test Node',
            position: { x: 0, y: 0, z: 0 },
            status: 'active'
        };

        // Mock findOne to return null (not found)
        (Node.findOne as jest.Mock).mockResolvedValue(null);

        // Mock create
        (Node.create as jest.Mock).mockResolvedValue(mockNodeData);

        const result = await nodeService.createNode(mockNodeData);

        expect(Node.findOne).toHaveBeenCalledWith({ nodeId: 'TEST_001' });
        expect(Node.create).toHaveBeenCalledWith(mockNodeData);
        expect(result).toEqual(mockNodeData);
    });

    it('should throw error if node already exists', async () => {
        const mockNodeData = { nodeId: 'DUPLICATE_001', name: 'Dup' };

        // Mock findOne to return existing doc
        (Node.findOne as jest.Mock).mockResolvedValue({ nodeId: 'DUPLICATE_001' });

        await expect(nodeService.createNode(mockNodeData))
            .rejects
            .toThrow('Node with this ID already exists');
    });

    it('should get all nodes', async () => {
        const mockNodes = [{ nodeId: 'N1' }, { nodeId: 'N2' }];
        (Node.find as jest.Mock).mockResolvedValue(mockNodes);

        const result = await nodeService.getAllNodes();

        expect(Node.find).toHaveBeenCalled();
        expect(result).toHaveLength(2);
    });
});

```

## 4. Simulation

#### simulation\Dockerfile
```
FROM python:3.10 AS base

WORKDIR /app

RUN apt-get update && apt-get install -y \
    libgl1 \
    libglib2.0-0 \
    libopenblas-dev \
    liblapack-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM base AS development
COPY . .
CMD ["uvicorn", "src.api.server:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

FROM base AS production
COPY src ./src
ENV PYTHONUNBUFFERED=1
EXPOSE 8000
CMD ["sh", "-c", "uvicorn src.api.server:app --host 0.0.0.0 --port ${PORT:-8080}"]

```

#### simulation\requirements.txt
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
python-dotenv==1.0.0
numpy==1.24.3
opencv-python-headless==4.8.1.78

pymongo==4.6.0
motor==3.3.2
python-dateutil==2.8.2
pytz==2023.3

```

#### simulation\src\__init__.py
```python

```

#### simulation\src\anomalies\detector.py
```python
from typing import List

class AnomalyDetector:
    def detect(self, entities: List[dict]) -> List[dict]:
        anomalies = []
        
        # 1. Check Crowd Compression
        # Radius check -> if many entities in small area
        
        # 2. Check Speed
        for e in entities:
             if abs(e.get('velocity', {}).get('x', 0)) > 10: # >10m/s
                 anomalies.append({
                     'id': f"SPEED_{e['id']}",
                     'type': 'KINETICS',
                     'headline': f"High Speed Detected: {e['id']}",
                     'severity': 'MEDIUM'
                 })
                 
        return anomalies

```

#### simulation\src\anomalies\generator.py
```python
import numpy as np
from typing import List, Dict, Optional
import uuid
from datetime import datetime

class AnomalyGenerator:
    """
    Generates realistic anomalies based on entity behavior and scenario context.
    """
    
    def __init__(self):
        self.baselines = {}  # Zone -> baseline metrics
        self.anomaly_rate = 2.0  # anomalies per minute (configurable)
        self.last_anomaly_time = 0
        self.min_anomaly_interval = 5.0  # seconds between anomalies
        
    def detect(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """
        Check for anomalies based on entity behavior.
        Returns list of anomaly dicts.
        """
        anomalies = []
        
        # Update baselines
        self._update_baselines(entities, scenario)
        
        # 1. Crowd Compression (Geographics + Proxemics)
        for zone in scenario.zones:
            compression = self._check_crowd_compression(entities, zone, timestamp)
            if compression:
                anomalies.append(compression)
        
        # 2. Speed Violations (Kinetics)
        speed_anomalies = self._check_speed_anomalies(entities, timestamp)
        anomalies.extend(speed_anomalies)
        
        # 3. Loitering (Atmospherics)
        loitering = self._check_loitering(entities, timestamp)
        anomalies.extend(loitering)
        
        # 4. Restricted Zone Entry (Geographics)
        trespass = self._check_restricted_zones(entities, scenario, timestamp)
        anomalies.extend(trespass)
        
        # Apply Rule of Three
        anomalies = self._apply_rule_of_three(anomalies, timestamp)
        
        return anomalies
    
    def _check_crowd_compression(self, entities: List[Dict], zone, timestamp: float) -> Optional[Dict]:
        """Detect crowd compression/crush risk."""
        # Filter entities in this zone
        entities_in_zone = [
            e for e in entities 
            if self._entity_in_zone(e, zone)
        ]
        
        if not entities_in_zone:
            return None
        
        # Calculate density
        area = zone.area
        density = len(entities_in_zone) / area
        
        # Get baseline
        baseline_key = f"{zone.name}_density"
        baseline_density = self.baselines.get(baseline_key, 0.5)
        
        # Threshold: 2.5× baseline or >4 people/m² (crowd crush risk)
        threshold = max(baseline_density * 2.5, 4.0)
        
        if density > threshold:
            severity = 'CRITICAL' if density > 6.0 else 'HIGH'
            
            return {
                'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                'type': 'GEOGRAPHICS',
                'subtype': 'CROWD_COMPRESSION',
                'severity': severity,
                'scenario': 'CRUSH',
                'headline': f'{zone.name} Crowd Compression Risk',
                'description': f'Density {density:.1f} people/m², {density/baseline_density:.1f}× baseline',
                'baselineText': f'Normal density: {baseline_density:.1f} people/m²',
                'anomalyText': f'Current density: {density:.1f} people/m² ({len(entities_in_zone)} in {area:.0f}m²)',
                'zone': zone.name,
                'location': zone.center if hasattr(zone, 'center') else {'x': 0, 'y': 0, 'z': 0},
                'entityIds': [e['id'] for e in entities_in_zone],
                'metrics': {
                    'baselineDelta': ((density / baseline_density) - 1) * 100,
                    'confidence': 0.95,
                    'riskScore': min(density * 15, 100)
                },
                'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                'ruleOfThreeHit': False
            }
        
        return None
    
    def _check_speed_anomalies(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect excessive speed violations."""
        anomalies = []
        
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            vel = entity.get('velocity', {'x': 0, 'y': 0, 'z': 0})
            speed = np.sqrt(vel['x']**2 + vel['y']**2)  # Horizontal speed
            
            # Thresholds based on role
            role = entity.get('role', 'SPECTATOR')
            if role == 'PLAYER':
                max_speed = 10.0  # m/s (fast sprinting)
            elif role == 'OFFICIAL':
                max_speed = 5.0   # m/s
            else:
                max_speed = 2.0   # m/s (walking speed for spectators)
            
            if speed > max_speed * 1.5:  # 1.5× threshold
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'KINETICS',
                    'subtype': 'SPEED_VIOLATION',
                    'severity': 'MEDIUM',
                    'headline': f'Excessive Speed: {entity["id"]}',
                    'description': f'Entity moving at {speed:.1f} m/s, {(speed/max_speed):.1f}× expected',
                    'baselineText': f'Expected max speed: {max_speed:.1f} m/s for {role}',
                    'anomalyText': f'Current speed: {speed:.1f} m/s',
                    'zone': 'UNKNOWN',  # TODO: Determine zone from position
                    'location': entity['position'],
                    'entityIds': [entity['id']],
                    'metrics': {
                        'baselineDelta': ((speed / max_speed) - 1) * 100,
                        'confidence': 0.88,
                        'riskScore': min(speed * 8, 100)
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
        
        return anomalies
    
    def _check_loitering(self, entities: List[Dict], timestamp: float) -> List[Dict]:
        """Detect loitering patterns (entities staying in same small area for too long)."""
        anomalies = []
        
        # Initialize history if not present
        if not hasattr(self, 'position_history'):
            self.position_history = {} # entity_id -> list of (timestamp, pos)
            
        for entity in entities:
            if entity.get('type') != 'PERSON':
                continue
                
            eid = entity['id']
            pos = entity['position']
            
            # Update history
            if eid not in self.position_history:
                self.position_history[eid] = []
                
            self.position_history[eid].append((timestamp, pos))
            
            # Prune old history (> 60 seconds)
            cutoff = timestamp - 60.0
            self.position_history[eid] = [p for p in self.position_history[eid] if p[0] > cutoff]
            
            # Check for loitering if we have enough data (e.g. > 10 seconds)
            history = self.position_history[eid]
            if len(history) < 30: # Assuming ~3fps check rate, need 10s
                continue
                
            # Calculate bounding box of movement over last window
            xs = [p[1]['x'] for p in history]
            ys = [p[1]['y'] for p in history]
            
            if not xs or not ys:
                continue
                
            x_range = max(xs) - min(xs)
            y_range = max(ys) - min(ys)
            
            # If stayed within 3m box for > 15s (approx len check)
            if x_range < 3.0 and y_range < 3.0 and (history[-1][0] - history[0][0]) > 15.0:
                # Check if already flagged recently to avoid spam is hard without state, 
                # but Rule of Three handles clustering.
                
                anomalies.append({
                    'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                    'type': 'ATMOSPHERICS',
                    'subtype': 'LOITERING',
                    'severity': 'LOW',
                    'headline': f'Loitering Detected: {eid}',
                    'description': f'Entity remained in 3m radius for > 15s',
                    'baselineText': 'Normal transit time: < 10s',
                    'anomalyText': f'Stationary duration: {history[-1][0] - history[0][0]:.1f}s',
                    'zone': 'UNKNOWN', 
                    'location': pos,
                    'entityIds': [eid],
                    'metrics': {
                        'baselineDelta': 50,
                        'confidence': 0.85,
                        'riskScore': 40
                    },
                    'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                    'ruleOfThreeHit': False
                })
                
        return anomalies
    
    def _check_restricted_zones(self, entities: List[Dict], scenario, timestamp: float) -> List[Dict]:
        """Detect entities entering restricted zones."""
        anomalies = []
        
        restricted_zones = [z for z in scenario.zones if z.type == 'RESTRICTED']
        
        for zone in restricted_zones:
            for entity in entities:
                if entity.get('role') == 'PLAYER':
                    continue  # Players allowed in restricted zones
                    
                if self._entity_in_zone(entity, zone):
                    anomalies.append({
                        'anomalyId': f'ANOM_{uuid.uuid4().hex[:8]}',
                        'type': 'GEOGRAPHICS',
                        'subtype': 'RESTRICTED_ZONE_ENTRY',
                        'severity': 'HIGH',
                        'headline': f'Unauthorized Entry: {zone.name}',
                        'description': f'{entity["id"]} entered restricted zone',
                        'baselineText': f'Zone {zone.name} is restricted',
                        'anomalyText': f'{entity["role"]} entity detected in zone',
                        'zone': zone.name,
                        'location': entity['position'],
                        'entityIds': [entity['id']],
                        'metrics': {
                            'baselineDelta': 100,
                            'confidence': 0.92,
                            'riskScore': 75
                        },
                        'occurredAt': datetime.fromtimestamp(timestamp).isoformat(),
                        'ruleOfThreeHit': False
                    })
        
        return anomalies
    
    def _apply_rule_of_three(self, anomalies: List[Dict], timestamp: float) -> List[Dict]:
        """
        Apply Rule of Three: flag when 3+ independent anomaly types
        converge in same space-time.
        """
        # Group anomalies by proximity
        spatial_threshold = 10.0  # meters
        temporal_threshold = 30.0  # seconds
        
        groups = []
        for anomaly in anomalies:
            placed = False
            for group in groups:
                # Check if anomaly belongs to this group
                representative = group[0]
                
                # Spatial proximity
                loc1 = anomaly['location']
                loc2 = representative['location']
                dist = np.sqrt(
                    (loc1['x'] - loc2['x'])**2 + 
                    (loc1['y'] - loc2['y'])**2
                )
                
                # Temporal proximity
                time_diff = abs(
                    anomaly['occurredAt'].timestamp() - 
                    representative['occurredAt'].timestamp()
                )
                
                if dist < spatial_threshold and time_diff < temporal_threshold:
                    group.append(anomaly)
                    placed = True
                    break
            
            if not placed:
                groups.append([anomaly])
        
        # Check each group for Rule of Three
        for group in groups:
            distinct_types = set(a['type'] for a in group)
            
            if len(distinct_types) >= 3:
                # Mark all anomalies in group
                for anomaly in group:
                    anomaly['ruleOfThreeHit'] = True
                    anomaly['severity'] = 'CRITICAL'  # Escalate
                    anomaly['relatedAnomalies'] = [
                        a['anomalyId'] for a in group if a != anomaly
                    ]
        
        return anomalies
    
    def _update_baselines(self, entities: List[Dict], scenario):
        """Update baseline metrics using exponential moving average."""
        # TODO: Implement proper baseline learning
        # For now, use static baselines
        for zone in scenario.zones:
            baseline_key = f"{zone.name}_density"
            if baseline_key not in self.baselines:
                self.baselines[baseline_key] = 1.0  # 1 person/m² default
    
    def _entity_in_zone(self, entity: Dict, zone) -> bool:
        """Check if entity is inside zone bounds."""
        pos = entity['position']
        bounds = zone.bounds  # (x_min, y_min, x_max, y_max)
        
        return (
            bounds[0] <= pos['x'] <= bounds[2] and
            bounds[1] <= pos['y'] <= bounds[3]
        )

```

#### simulation\src\api\server.py
```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import uvicorn
import os

from src.core.orchestrator import SimulationOrchestrator

orchestrator = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global orchestrator
    # Initialize with default config
    orchestrator = SimulationOrchestrator({})
    print("Simulation Engine Starting...")
    yield
    # Shutdown
    if orchestrator:
        orchestrator.stop()
    print("Simulation Engine Stopping...")

app = FastAPI(lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "simulation-engine"}

@app.post("/simulation/start")
async def start_simulation(config: dict):
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.load_scenario(config.get('sport', 'BASKETBALL'), config)
    orchestrator.start()
    return {"status": "started"}

@app.post("/simulation/stop")
async def stop_simulation():
    if not orchestrator:
        return {"error": "Orchestrator not initialized"}
    orchestrator.stop()
    return {"status": "stopped"}

@app.get("/nodes/{node_id}/stream")
async def get_stream(node_id: str):
    if not orchestrator:
        raise HTTPException(status_code=503, detail="Orchestrator not initialized")
    
    return StreamingResponse(
        orchestrator.get_video_stream(node_id), 
        media_type="multipart/x-mixed-replace; boundary=frame"
    )

@app.get("/simulation/status")
async def get_status():
    if not orchestrator:
        return {"running": False, "error": "Orchestrator not initialized"}
    
    return {
        "running": orchestrator.running,
        "paused": orchestrator.paused,
        "active_scenario": orchestrator.scenario.sport if orchestrator.scenario else None,
        "fps": getattr(orchestrator, 'actual_fps', 0),
        "target_fps": getattr(orchestrator, 'target_fps', 30),
        "entity_count": len(orchestrator.entities)
    }

@app.patch("/simulation/config")
async def update_config(config: dict):
    if not orchestrator:
         return {"error": "Orchestrator not initialized"}
    
    if 'targetFps' in config:
        orchestrator.target_fps = config['targetFps']
    
    if 'anomalyRate' in config and hasattr(orchestrator, 'anomaly_generator'):
        orchestrator.anomaly_generator.anomaly_rate = config['anomalyRate']

    return {"status": "updated", "config": config}

@app.post("/nodes/{node_id}/calibrate")
async def calibrate_node(node_id: str):
    """Simulate calibration for a node."""
    if not orchestrator:
         raise HTTPException(status_code=503, detail="Orchestrator not initialized")
    
    import random
    import time
    return {
        "nodeId": node_id,
        "calibration": {
            "reprojectionError": random.uniform(0.01, 0.05),
            "status": "SUCCESS",
            "timestamp": time.time()
        }
    }

@app.get("/")
async def root():
    return {"message": "Motion Intelligence Simulation Engine v1.0"}

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("src.api.server:app", host="0.0.0.0", port=port, reload=True)

```

#### simulation\src\calibration\utils.py
```python
import numpy as np

def generate_default_calibration():
    # Intrinsic (Camera)
    # 1920x1080, FOV ~90 deg
    fx = 1000
    fy = 1000
    cx = 960
    cy = 540
    camera_matrix = [
        [fx, 0, cx],
        [0, fy, cy],
        [0, 0, 1]
    ]
    
    # Extrinsic (Identity for now)
    rotation = np.eye(3).tolist()
    translation = [0, 0, 0]
    
    # Lidar to Camera (Example: Camera is 10cm above LIDAR)
    lidar_to_camera = np.eye(4)
    lidar_to_camera[1, 3] = -0.1 # y-axis translation
    
    return {
        'intrinsic': {
            'cameraMatrix': camera_matrix,
            'distortion': [0, 0, 0, 0, 0]
        },
        'extrinsic': {
            'rotationMatrix': rotation,
            'translationVector': translation
        },
        'lidarToCameraTransform': lidar_to_camera.tolist(),
        'calibrationQuality': 100,
        'calibratedAt': '2025-12-16T12:00:00Z'
    }

def generate_realistic_calibration():
    # Add realistic error and degradation (85-95%)
    quality = 85 + random.uniform(-5, 10)
    
    return {
        'calibrationQuality': quality,
        'calibratedAt': datetime.now().isoformat(),
        'driftRate': random.uniform(0.1, 0.5),  # % per hour
    }

```

#### simulation\src\core\orchestrator.py
```python
import os
import time
import threading
from typing import List, Optional, Dict
import numpy as np

from .physics_engine import PhysicsEngine
from .scenario_manager import ScenarioManager
from ..nodes.edge_node import EdgeNode
from ..anomalies.generator import AnomalyGenerator
from ..utils.ptp_sync import PTPClock

class SimulationOrchestrator:
    def __init__(self, config: dict):
        self.config = config
        self.running = False
        self.paused = False
        self.thread = None
        
        # Core components
        self.physics_engine = PhysicsEngine()
        self.scenario = None
        self.anomaly_generator = AnomalyGenerator()
        self.clock = PTPClock(is_master=True)
        
        # State
        self.nodes: List[EdgeNode] = []
        self.entities: List[Dict] = []
        self.current_time = 0.0
        self.frame_count = 0
        self.target_fps = 30
        self.actual_fps = 0.0
        
    def load_scenario(self, sport: str, config: dict):
        """Load sport-specific scenario."""
        self.scenario = ScenarioManager.create_scenario(sport, config)
        self.scenario.initialize(self.entities)
        print(f"Loaded scenario: {sport} with {len(self.entities)} entities")
        
    def add_node(self, node_config: dict) -> EdgeNode:
        """Add a sensor node to the simulation."""
        node = EdgeNode(
            node_id=node_config['nodeId'],
            position=np.array([
                node_config['position']['x'],
                node_config['position']['y'],
                node_config['position']['z']
            ]),
            orientation=np.array([
                node_config['orientation']['pitch'],
                node_config['orientation']['yaw'],
                node_config['orientation']['roll']
            ]),
            sensors=node_config['sensors'],
            calibration=node_config.get('calibration', {})
        )
        self.nodes.append(node)
        print(f"Added node: {node_config['nodeId']}")
        return node
        
    def start(self):
        """Start the simulation loop."""
        if self.running:
            return
            
        if not self.scenario:
            # Fallback for empty start
            try:
                self.load_scenario('BASKETBALL', {})
            except:
                print("Failed to load default scenario")
            
        self.running = True
        self.paused = False
        self.thread = threading.Thread(target=self._loop, daemon=True)
        self.thread.start()
        print("Simulation started")
        
    def stop(self):
        """Stop the simulation."""
        self.running = False
        if self.thread:
            self.thread.join()
        print("Simulation stopped")
        
    def pause(self):
        """Pause the simulation."""
        self.paused = True
        
    def resume(self):
        """Resume the simulation."""
        self.paused = False
        
    def _loop(self):
        """Main simulation loop - runs at 30 FPS."""
        target_dt = 1.0 / self.target_fps
        last_fps_check = time.time()
        fps_frame_count = 0
        
        while self.running:
            if self.paused:
                time.sleep(0.1)
                continue
                
            loop_start = time.time()
            
            # 1. Update simulation time (PTP clock)
            self.current_time = self.clock.get_time() / 1e9  # Convert ns to seconds
            
            # 2. Update entity behaviors (scenario-specific)
            if self.scenario:
                self.scenario.update(self.entities, target_dt)
            
            # 3. Update physics (entity movement)
            self.physics_engine.step(self.entities, target_dt)
            
            # 4. Generate sensor data from all nodes
            # For this MVP, we just generate generating logs or frames
            # Logic to publish via WebSocket would go here
            # 4. Generate sensor data from all nodes
            for node in self.nodes:
                # This updates internal buffers like last_camera_frame
                node.generate_frame(
                    entities=self.entities,
                    timestamp=self.current_time
                )
            
            # 5. Detect anomalies
            if self.scenario:
                anomalies = self.anomaly_generator.detect(
                    entities=self.entities,
                    scenario=self.scenario,
                    timestamp=self.current_time
                )
                for anomaly in anomalies:
                    self._publish_anomaly(anomaly)
            
            # 6. Update frame counter
            self.frame_count += 1
            fps_frame_count += 1
            
            # 7. Calculate actual FPS every second
            now = time.time()
            if now - last_fps_check >= 1.0:
                self.actual_fps = fps_frame_count / (now - last_fps_check)
                fps_frame_count = 0
                last_fps_check = now
                # print(f"Simulation FPS: {self.actual_fps:.1f} | Entities: {len(self.entities)}")
            
            # 8. Sleep to maintain frame rate
            elapsed = time.time() - loop_start
            if elapsed < target_dt:
                time.sleep(target_dt - elapsed)
                
            # Broadcast updates (Every 3 frames approx 10Hz)
            if self.frame_count % 3 == 0:
                self._publish_entities()

    def _publish_entities(self):
        """Send entity positions to API."""
        try:
            # Basic validation
            if not self.entities:
                return

            payload = {
                'sessionId': None, # TODO: Pass session ID if managed
                'stats': {
                    'fps': self.actual_fps,
                    'frame': self.frame_count,
                    'time': self.current_time
                },
                'sentAt': time.time(),
                'entities': [
                    {
                        'id': e.get('id'),
                        'type': e.get('type'),
                        'role': e.get('role'),
                        'team': e.get('team'),
                        'position': e.get('position'),
                        'velocity': e.get('velocity'),
                        'color': e.get('color'),
                        'radius': e.get('radius'),
                        'severity': e.get('severity')
                    }
                    for e in self.entities
                ]
            }
            
            # Fire and forget POST
            # Using threads or async here would be better for performance, 
            # but for this simulation loop strictness, a short timeout is acceptable logic 
            # if we assume local network.
            try:
                import requests
                api_url = os.getenv('API_URL', 'http://api:3001')
                response = requests.post(
                    f"{api_url}/internal/entity-update",
                    json=payload,
                    timeout=0.2 
                )
                if response.status_code != 200:
                    print(f"Warning: API returned status {response.status_code} for entity-update")
            except ImportError:
                print("requests module not found")
            except Exception as e:
                # print(f"Failed to publish entities: {e}")
                pass # Still suppress to avoid loop crash, but could log periodically
                
        except Exception as e:
            print(f"Error publishing entities: {e}")

    def _publish_anomaly(self, anomaly):
        """Publish detected anomaly."""
        try:
            import requests
            requests.post(
                f"{os.getenv('API_URL', 'http://api:3001')}/internal/anomaly",
                json={
                    'sessionId': None,
                    'anomaly': anomaly
                },
                timeout=0.1
            )
        except Exception as e:
            print(f"Failed to publish anomaly: {e}")

    def get_video_stream(self, node_id: str):
        """Generator for MJPEG stream from a specific node."""
        node = next((n for n in self.nodes if n.node_id == node_id), None)
        if not node:
            return

        while self.running:
            frame = node.last_camera_frame
            if frame:
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
            
            # rate limit to approx 30 fps to avoid busy loop
            time.sleep(0.033)



```

#### simulation\src\core\physics_engine.py
```python
import numpy as np
from typing import List

class PhysicsEngine:
    def __init__(self):
        self.gravity = -9.81
        self.friction_coeff = 0.5

    def step(self, entities: List[dict], dt: float):
        """
        Update entity positions based on velocity and forces.
        """
        for entity in entities:
            # Simple Euler integration
            vel = np.array(entity.get('velocity', [0, 0, 0]), dtype=float)
            pos = np.array(entity.get('position', [0, 0, 0]), dtype=float)
            
            # Apply friction (damping)
            vel = vel * (1.0 - self.friction_coeff * dt)
            
            # Update position
            pos += vel * dt
            
            # Floor constraint (z >= 0)
            if pos[2] < 0:
                pos[2] = 0
                vel[2] = 0
            
            # Update entity state
            entity['position'] = {
                'x': float(pos[0]),
                'y': float(pos[1]),
                'z': float(pos[2])
            }
            entity['velocity'] = {
                'x': float(vel[0]),
                'y': float(vel[1]),
                'z': float(vel[2])
            }

```

#### simulation\src\core\scenario_manager.py
```python
from typing import List, Dict, Optional
import numpy as np

class Zone:
    def __init__(self, name: str, bounds: tuple, area: float, type: str):
        self.name = name
        self.bounds = bounds # (x_min, y_min, x_max, y_max)
        self.area = area
        self.type = type
        self.center = {
            'x': (bounds[0] + bounds[2]) / 2,
            'y': (bounds[1] + bounds[3]) / 2,
            'z': 0
        }

class Scenario:
    def __init__(self):
        self.zones: List[Zone] = []
        self.entities: List[dict] = []
        self.sport = 'UNKNOWN'

    def initialize(self, entities: List[dict]):
        """Populate initial entities"""
        pass

    def update(self, entities: List[dict], dt: float):
        """Update entity behaviors"""
        pass

class ScenarioManager:
    @staticmethod
    def create_scenario(sport: str, config: dict) -> Scenario:
        if sport == 'BASKETBALL':
            from ..sports.basketball import BasketballScenario
            return BasketballScenario(config)
        else:
            raise ValueError(f"Unknown sport: {sport}")

```

#### simulation\src\nodes\camera_simulator.py
```python
import numpy as np
import cv2
import time
from typing import List, Tuple, Optional

class CameraSimulator:
    def __init__(self, resolution: dict, fps: int, fov: float):
        self.width = resolution['width']
        self.height = resolution['height']
        self.fps = fps
        self.fov = fov
        self.last_frame_time = 0
        self.frame_interval = 1.0 / fps

    def render(self, entities: List[dict], timestamp: float) -> Optional[bytes]:
        """
        Render a frame if enough time has passed.
        Returns JPEG bytes or None.
        """
        # Simple frame rate control
        if timestamp - self.last_frame_time < self.frame_interval:
            return None
            
        self.last_frame_time = timestamp
        
        # Create blank image (dark gray background)
        image = np.full((self.height, self.width, 3), 30, dtype=np.uint8)
        
        # Draw entities (simplified 2D projection for now)
        for entity in entities:
             # Basic projection logic (placeholder)
             # In a real 3D sim, we'd use a projection matrix
             pos = entity.get('position', {'x':0, 'y':0, 'z':0})
             
             # Map x/y to screen coordinates (very rough approx)
             cx = int(self.width / 2 + pos['x'] * 50) 
             cy = int(self.height / 2 + pos['y'] * 50)
             
             if 0 <= cx < self.width and 0 <= cy < self.height:
                 cv2.circle(image, (cx, cy), 10, (0, 255, 0), -1)
                 cv2.putText(image, entity.get('id', '?'), (cx+15, cy), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        # Add noise
        noise = np.random.normal(0, 5, image.shape).astype(np.uint8)
        image = cv2.add(image, noise)
        
        # Encode to JPEG
        _, encoded = cv2.imencode('.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 80])
        return encoded.tobytes()

```

#### simulation\src\nodes\edge_node.py
```python
from typing import List, Dict, Any
import numpy as np
from .camera_simulator import CameraSimulator
from .lidar_simulator import LidarSimulator
from .imu_simulator import IMUSimulator

class EdgeNode:
    def __init__(self, node_id: str, position: np.ndarray, orientation: np.ndarray, sensors: dict, calibration: dict):
        self.node_id = node_id
        self.position = position
        self.orientation = orientation
        self.calibration = calibration
        self.last_camera_frame = None
        
        # Initialize Sensors
        self.camera = None
        if sensors.get('camera', {}).get('enabled'):
            cam_config = sensors['camera']
            self.camera = CameraSimulator(
                resolution=cam_config.get('resolution', {'width': 1920, 'height': 1080}),
                fps=cam_config.get('fps', 30),
                fov=cam_config.get('fov', 90)
            )
            
        self.lidar = None
        if sensors.get('lidar', {}).get('enabled'):
            lid_config = sensors['lidar']
            self.lidar = LidarSimulator(
                model=lid_config.get('model', 'VLP-16'),
                channels=lid_config.get('channels', 16),
                range_m=lid_config.get('range', 100)
            )
            
        self.imu = None
        if sensors.get('imu', {}).get('enabled'):
            self.imu = IMUSimulator(sample_rate=100)

    def generate_frame(self, entities: List[dict], timestamp: float) -> Dict[str, Any]:
        """Generate a synchronized frame from all enabled sensors."""
        frame = {
            'nodeId': self.node_id,
            'timestamp': timestamp,
            'sensors': {}
        }
        
        # Transform entities to node-local coordinates if needed
        # For now, simulators handle global entities
        
        if self.camera:
            image_data = self.camera.render(entities, timestamp)
            if image_data:
                frame['sensors']['camera'] = image_data # In real app, this would be a path or heavy blob
                self.last_camera_frame = image_data
        
        if self.lidar:
            point_cloud = self.lidar.scan(entities, timestamp)
            frame['sensors']['lidar'] = point_cloud # Numpy array
            
        if self.imu:
            imu_data = self.imu.read(timestamp, self.position) # Simplified IMU read
            frame['sensors']['imu'] = imu_data
            
        return frame

```

#### simulation\src\nodes\fusion_engine.py
```python
import numpy as np
from typing import List, Dict

class FusionEngine:
    """
    Fuses camera + LIDAR data at edge node.
    Core learning objective: demonstrates sensor fusion concepts.
    """
    
    def __init__(self, camera_matrix=None, lidar_to_camera_transform=None):
        # Defaults if not provided
        self.camera_matrix = camera_matrix if camera_matrix is not None else np.eye(3)
        self.transform = lidar_to_camera_transform if lidar_to_camera_transform is not None else np.eye(4)
        
    def _project_lidar_to_image(self, points):
        """Project 3D LIDAR points to 2D camera coordinates."""
        if len(points) == 0:
            return np.array([])
            
        # 1. Transform Lidar -> Camera frame
        # We assume standard Camera frame: X right, Y down, Z forward
        # Simple simulation hack: rotate points to align with camera Z
        # R_lidar_cam = np.array([[0, -1, 0], [0, 0, -1], [1, 0, 0]])
        # points_cam = points @ R_lidar_cam.T + np.array([0, 0, 0])
        
        # For simplicity in this demo, treat world X,Y as 'flat' image plane scaling
        focal_length = 1000
        
        u = focal_length * (points[:, 0] / (points[:, 1] + 1e-6)) + 960  # Center X
        v = focal_length * (points[:, 2] / (points[:, 1] + 1e-6)) + 540  # Center Y (Z is up in input, Y down in image)
        
        # Filter points behind camera (Y < 0)
        valid_mask = points[:, 1] > 0
        
        projected = np.zeros((len(points), 3))
        projected[:, 0] = u
        projected[:, 1] = v
        projected[:, 2] = valid_mask
        
        return projected

    def _iou(self, point, bbox):
        """Check if point is inside bbox."""
        x, y = point[0], point[1]
        x1, y1, x2, y2 = bbox
        return x1 <= x <= x2 and y1 <= y <= y2

    def fuse(self, camera_image, lidar_points, entities):
        """
        Perform fusion of camera and LIDAR data.
        Returns: List of detected entities with 3D positions derived from LIDAR clusters.
        """
        detections = []
        
        # 1. Project LIDAR points to camera image
        projected_points_2d = self._project_lidar_to_image(lidar_points[:, :3])
        
        # 2. Run 2D object detection (Simulated)
        bboxes = self._detect_objects_2d(camera_image, entities)
        
        # 3. Associate and Fuse
        for bbox_data in bboxes:
            bbox = bbox_data['bbox']
            
            # Find points inside this bbox
            points_inside_indices = []
            for i, pt in enumerate(projected_points_2d):
                if pt[2] > 0 and self._iou(pt, bbox): # Check validity and bounds
                    points_inside_indices.append(i)
            
            # Fuse: Compute centroid of associated LIDAR points
            if points_inside_indices:
                cluster = lidar_points[points_inside_indices]
                fused_pos = np.mean(cluster[:, :3], axis=0)
                confidence = 0.9 + (len(points_inside_indices) / 100.0) # More points = higher confidence
            else:
                # Fallback if no LIDAR hits (e.g. occlusion): use purely visual estimate or prior
                # For simulaton, fallback to entity truth + large noise
                target_entity = next((e for e in entities if e['id'] == bbox_data['entity_id']), None)
                if target_entity:
                    pos = target_entity['position']
                    fused_pos = np.array([pos['x'], pos['y'], pos['z']]) + np.random.normal(0, 0.5, 3)
                    confidence = 0.5
                else:
                    continue

            detections.append({
                'entityId': bbox_data['entity_id'],
                'position3d': fused_pos.tolist(),
                'velocity': [0, 0, 0], # Kalman filter would determine this over time
                'confidence': min(confidence, 1.0),
                'bbox2d': bbox
            })
        
        return detections

    def _detect_objects_2d(self, image, entities):
        """Simulate YOLO detection."""
        bboxes = []
        for entity in entities:
            # Simple manual projection for bounding box simulation
            pos = entity['position']
            # Scale world coords to 'pixel' coords roughly
            cx = 960 + (pos['x'] * 50) 
            cy = 540 - (pos['z'] * 50) 
            w, h = 60 / (pos['y']*0.1 + 1), 120 / (pos['y']*0.1 + 1)
            
            bboxes.append({
                'entity_id': entity['id'],
                'bbox': [cx - w/2, cy - h/2, cx + w/2, cy + h/2],
                'confidence': 0.95
            })
        return bboxes

```

#### simulation\src\nodes\imu_simulator.py
```python
import numpy as np

class IMUSimulator:
    def __init__(self, sample_rate: int):
        self.sample_rate = sample_rate
        self.accel_bias = np.random.normal(0, 0.01, 3)
        self.gyro_bias = np.random.normal(0, 0.001, 3)

    def sample(self, timestamp: float, motion: dict) -> dict:
        """
        Generate IMU reading based on actual motion.
        """
        true_accel = motion.get('acceleration', np.zeros(3))
        true_gyro = motion.get('angular_velocity', np.zeros(3))
        
        # Add noise and bias
        accel_noise = np.random.normal(0, 0.01, 3)
        gyro_noise = np.random.normal(0, 0.001, 3)
        
        accel = true_accel + self.accel_bias + accel_noise
        gyro = true_gyro + self.gyro_bias + gyro_noise
        
        # Add gravity (assuming z is up)
        accel[2] += 9.81
        
        return {
            'acceleration': accel.tolist(),
            'gyroscope': gyro.tolist(),
            'temperature': 45.0 + np.random.normal(0, 0.1)
        }

```

#### simulation\src\nodes\lidar_simulator.py
```python
import numpy as np
from typing import List, Tuple

class LidarSimulator:
    def __init__(self, model: str, channels: int, range_m: float):
        self.model = model
        self.channels = channels
        self.range = range_m
        self.points_per_second = 300000

    def scan(self, entities: List[dict], timestamp: float) -> np.ndarray:
        """
        Generate a point cloud.
        Returns numpy array of (x, y, z, intensity).
        """
        # Generate background points (ground plane)
        # Simplified: Grid of points
        x = np.linspace(-20, 20, 100)
        y = np.linspace(-20, 20, 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X) # Ground is at z=0
        
        # Flatten
        ground_points = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1)
        
        entity_points = []
        for entity in entities:
            pos = entity.get('position', {'x':0, 'y':0, 'z':0})
            # Generate a cluster of points for the entity
            num_points = 50
            # Gaussian distribution around entity position
            ep = np.random.normal([pos['x'], pos['y'], pos['z']], 0.2, (num_points, 3))
            entity_points.append(ep)
            
        if entity_points:
            all_entity_points = np.vstack(entity_points)
            points = np.vstack([ground_points, all_entity_points])
        else:
            points = ground_points

        # Add intensity (random for now)
        intensities = np.random.rand(len(points), 1)
        
        return np.hstack([points, intensities]).astype(np.float32)

```

#### simulation\src\sports\basketball.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class BasketballScenario(Scenario):
    """NBA-style basketball simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'BASKETBALL'
        
        # Court dimensions (NBA standard in meters)
        self.court_length = 28.65
        self.court_width = 15.24
        
        # Zones
        self.zones = [
            Zone(
                name='COURT',
                bounds=self._court_bounds(),
                area=self.court_length * self.court_width,
                type='FIELD'
            ),
            Zone(
                name='HOME_BENCH',
                bounds=(0, 0, 5, 2),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='AWAY_BENCH',
                bounds=(0, self.court_width - 2, 5, self.court_width),
                area=10,
                type='BENCH'
            ),
            Zone(
                name='PAINT_HOME',
                bounds=(0, self.court_width/2 - 2.44, 5.8, self.court_width/2 + 2.44),
                area=28.3,
                type='RESTRICTED'
            )
        ]
        
        self.crowd_count = config.get('crowdCount', 5000) if config else 5000
        
    def initialize(self, entities: List[Dict]):
        """Set up players, refs, ball, crowd."""
        
        # Home team (5 players)
        for i in range(5):
            pos = self._get_formation_position('HOME', i)
            entity = {
                'id': f'HOME_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'HOME',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (255, 0, 0),  # Red
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Away team (5 players)
        for i in range(5):
            pos = self._get_formation_position('AWAY', i)
            entity = {
                'id': f'AWAY_PLAYER_{i+1}',
                'type': 'PERSON',
                'role': 'PLAYER',
                'team': 'AWAY',
                'position': {'x': pos[0], 'y': pos[1], 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 2.0,
                'color': (0, 0, 255),  # Blue
                'reflectance': 0.4,
                'behavior': 'basketball_player'
            }
            entities.append(entity)
        
        # Referees (3)
        for i in range(3):
            entity = {
                'id': f'REF_{i+1}',
                'type': 'PERSON',
                'role': 'OFFICIAL',
                'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 0.0},
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 0.3,
                'height': 1.8,
                'color': (128, 128, 128),  # Gray
                'reflectance': 0.4,
                'behavior': 'referee'
            }
            entities.append(entity)
        
        # Basketball
        entity = {
            'id': 'BALL',
            'type': 'OBJECT',
            'position': {'x': self.court_length/2, 'y': self.court_width/2, 'z': 1.5},
            'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
            'radius': 0.12,
            'color': (255, 165, 0),  # Orange
            'reflectance': 0.6
        }
        entities.append(entity)
        
        # Crowd (simplified - grouped entities)
        self._generate_crowd(entities, self.crowd_count)
        
        print(f"Basketball scenario initialized: {len(entities)} entities")
        
    def update(self, entities: List[Dict], dt: float):
        """Update entity behaviors each frame."""
        for entity in entities:
            behavior = entity.get('behavior')
            
            if behavior == 'basketball_player':
                self._update_player_behavior(entity, entities, dt)
            elif behavior == 'referee':
                self._update_referee_behavior(entity, entities, dt)
        
        # Update ball physics (bouncing, possession)
        self._update_ball(entities, dt)
        
    def _get_formation_position(self, team: str, index: int) -> tuple:
        """Get initial position for player in formation."""
        # Simple positioning - half court
        if team == 'HOME':
            x_base = self.court_length * 0.25
        else:
            x_base = self.court_length * 0.75
            
        # Spread players across court width
        y = (self.court_width / 6) * (index + 1)
        
        return (x_base, y)
        
    def _update_player_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Basic basketball player AI."""
        # Find ball
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Move towards ball (simplified)
        dx = ball['position']['x'] - entity['position']['x']
        dy = ball['position']['y'] - entity['position']['y']
        dist = np.sqrt(dx**2 + dy**2)
        
        if dist > 0.5:  # Not at ball
            # Move towards ball
            speed = 3.0  # m/s
            entity['velocity']['x'] = (dx / dist) * speed
            entity['velocity']['y'] = (dy / dist) * speed
        else:
            # At ball - slow down
            entity['velocity']['x'] *= 0.5
            entity['velocity']['y'] *= 0.5
            
    def _update_referee_behavior(self, entity: Dict, all_entities: List[Dict], dt: float):
        """Referee follows play."""
        # Similar to player but slower
        ball = next((e for e in all_entities if e['id'] == 'BALL'), None)
        if ball:
            dx = ball['position']['x'] - entity['position']['x']
            dy = ball['position']['y'] - entity['position']['y']
            dist = np.sqrt(dx**2 + dy**2)
            
            if dist > 3.0:
                speed = 2.0
                entity['velocity']['x'] = (dx / dist) * speed
                entity['velocity']['y'] = (dy / dist) * speed
                
    def _update_ball(self, entities: List[Dict], dt: float):
        """Update ball physics."""
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball:
            return
            
        # Gravity
        ball['velocity']['z'] -= 9.81 * dt
        
        # Bounce on floor
        if ball['position']['z'] <= 0.12:  # Ball radius
            ball['position']['z'] = 0.12
            ball['velocity']['z'] = -ball['velocity']['z'] * 0.7  # Bounce with loss
            
    def _court_bounds(self) -> tuple:
        """Return (x_min, y_min, x_max, y_max)."""
        return (0, 0, self.court_length, self.court_width)
        
    def _generate_crowd(self, entities: List[Dict], count: int):
        """Generate crowd entities (simplified grouping)."""
        # Stands are outside court boundaries
        # Create grouped "crowd sections" rather than individual spectators
        num_sections = 8
        people_per_section = count // num_sections
        
        for i in range(num_sections):
            entity = {
                'id': f'CROWD_SECTION_{i+1}',
                'type': 'GROUP',
                'role': 'SPECTATOR',
                'count': people_per_section,
                'position': {
                    'x': np.random.uniform(-5, self.court_length + 5),
                    'y': np.random.uniform(-5, self.court_width + 5),
                    'z': 0.0
                },
                'velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'radius': 2.0,  # Group radius
                'color': (100, 100, 200),
                'reflectance': 0.3
            }
            entities.append(entity)

```

#### simulation\src\sports\combat.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class CombatScenario(Scenario):
    """MMA/Boxing style simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'COMBAT'
        self.ring_size = 9.0 # meters
        
        self.zones = [
            Zone(name='RING', bounds=(0,0,self.ring_size,self.ring_size), area=81, type='RING'),
            Zone(name='RINGSIDE', bounds=(-2,-2,self.ring_size+2,self.ring_size+2), area=150, type='RESTRICTED')
        ]

    def initialize(self, entities: List[Dict]):
        # Fighter 1
        entities.append({
            'id': 'FIGHTER_1', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (255, 0, 0)
        })
        
        # Fighter 2
        entities.append({
            'id': 'FIGHTER_2', 'type': 'PERSON', 'role': 'FIGHTER',
            'position': {'x': self.ring_size*2/3, 'y': self.ring_size/2, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.4, 'height': 1.8, 'color': (0, 0, 255)
        })
        
        # Referee
        entities.append({
            'id': 'REF', 'type': 'PERSON', 'role': 'OFFICIAL',
            'position': {'x': self.ring_size/2, 'y': self.ring_size/4, 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.75, 'color': (200, 200, 200)
        })

    def update(self, entities: List[Dict], dt: float):
        f1 = next(e for e in entities if e['id'] == 'FIGHTER_1')
        f2 = next(e for e in entities if e['id'] == 'FIGHTER_2')
        
        # Circle each other
        center_x = (f1['position']['x'] + f2['position']['x']) / 2
        center_y = (f1['position']['y'] + f2['position']['y']) / 2
        
        for f in [f1, f2]:
            dx = center_x - f['position']['x']
            dy = center_y - f['position']['y']
            # Add orbit logic here... simplified
            f['velocity']['x'] += (np.random.rand()-0.5) * 2.0
            f['velocity']['y'] += (np.random.rand()-0.5) * 2.0
            
            # Keep in ring
            next_x = f['position']['x'] + f['velocity']['x'] * dt
            next_y = f['position']['y'] + f['velocity']['y'] * dt
            
            if next_x < 0 or next_x > self.ring_size:
                f['velocity']['x'] *= -1
            if next_y < 0 or next_y > self.ring_size:
                f['velocity']['y'] *= -1

```

#### simulation\src\sports\soccer.py
```python
import numpy as np
from typing import List, Dict
from ..core.scenario_manager import Scenario, Zone

class SoccerScenario(Scenario):
    """FIFA-style soccer simulation."""
    
    def __init__(self, config: dict = None):
        super().__init__()
        self.sport = 'SOCCER'
        
        # Field dimensions (Standard 105m x 68m)
        self.field_length = 105.0
        self.field_width = 68.0
        
        # Zones
        self.zones = [
            Zone(
                name='FIELD',
                bounds=(0, 0, self.field_length, self.field_width),
                area=self.field_length * self.field_width,
                type='FIELD'
            ),
             Zone(
                name='PENALTY_AREA_HOME',
                bounds=(0, self.field_width/2 - 20.15, 16.5, self.field_width/2 + 20.15),
                area=665.0, # Approx
                type='RESTRICTED'
            ),
             Zone(
                name='PENALTY_AREA_AWAY',
                bounds=(self.field_length - 16.5, self.field_width/2 - 20.15, self.field_length, self.field_width/2 + 20.15),
                area=665.0,
                type='RESTRICTED'
            )
        ]
        
    def initialize(self, entities: List[Dict]):
        # Home Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('HOME', i)
            entities.append(self._create_player(f'HOME_{i+1}', 'HOME', pos, (255, 0, 0)))

        # Away Team (11 players)
        for i in range(11):
            pos = self._get_formation_position('AWAY', i)
            entities.append(self._create_player(f'AWAY_{i+1}', 'AWAY', pos, (0, 0, 255)))
            
        # Ball
        entities.append({
            'id': 'BALL', 'type': 'OBJECT', 
            'position': {'x': self.field_length/2, 'y': self.field_width/2, 'z': 0.11},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.11, 'color': (255, 255, 255)
        })

    def update(self, entities: List[Dict], dt: float):
        # Very simple AI: chase ball
        ball = next((e for e in entities if e['id'] == 'BALL'), None)
        if not ball: return
        
        for e in entities:
            if e.get('role') == 'PLAYER':
                self._update_player(e, ball, dt)

    def _create_player(self, pid, team, pos, color):
        return {
            'id': pid, 'type': 'PERSON', 'role': 'PLAYER', 'team': team,
            'position': {'x': pos[0], 'y': pos[1], 'z': 0},
            'velocity': {'x': 0, 'y': 0, 'z': 0},
            'radius': 0.3, 'height': 1.8, 'color': color, 'behavior': 'soccer_player'
        }

    def _get_formation_position(self, team, index):
        # 4-4-2 Formation stub
        base_x = 10 if team == 'HOME' else self.field_length - 10
        direction = 1 if team == 'HOME' else -1
        
        if index == 0: # GK
            return (base_x, self.field_width/2)
        elif index < 5: # Defenders
            return (base_x + 15*direction, self.field_width * (index/5))
        elif index < 9: # Midfielders
            return (base_x + 35*direction, self.field_width * ((index-4)/5))
        else: # Forwards
            return (base_x + 55*direction, self.field_width * ((index-8)/3))

    def _update_player(self, player, ball, dt):
        # Determine if this player is closest to ball for their team
        # In a full sim, we'd check all teammates.
        # For efficiency here, we'll just check distance vs fixed threshold
        
        dx_ball = ball['position']['x'] - player['position']['x']
        dy_ball = ball['position']['y'] - player['position']['y']
        dist_ball = np.sqrt(dx_ball**2 + dy_ball**2)
        
        # Calculate formation target
        pid_parts = player['id'].split('_')
        idx = int(pid_parts[1]) - 1 if len(pid_parts) > 1 else 0
        form_pos = self._get_formation_position(player['team'], idx)
        
        # Formation force
        dx_form = form_pos[0] - player['position']['x']
        dy_form = form_pos[1] - player['position']['y']
        dist_form = np.sqrt(dx_form**2 + dy_form**2)
        
        # Logic: If close to ball (within 15m), chase ball. Else, hold formation.
        if dist_ball < 15.0:
            target_dx, target_dy, target_dist = dx_ball, dy_ball, dist_ball
            speed = 5.0 # Sprint
        else:
            target_dx, target_dy, target_dist = dx_form, dy_form, dist_form
            speed = 2.0 # Jog
            
        if target_dist > 0.5:
            player['velocity']['x'] = (target_dx / target_dist) * speed
            player['velocity']['y'] = (target_dy / target_dist) * speed
        else:
            player['velocity']['x'] = 0
            player['velocity']['y'] = 0

```

#### simulation\src\utils\ptp_sync.py
```python
import time
import numpy as np

class PTPClock:
    """
    IEEE 1588 Precision Time Protocol simulation.
    Simulates clock drift and offset correction.
    """
    
    def __init__(self, is_master: bool = True):
        self.is_master = is_master
        self.epoch = time.time_ns()
        self.crystal_frequency = 1e9  # 1 GHz nominal
        # Simulate hardware clock drift (parts per million)
        self.ppm_drift = np.random.uniform(-30, 30) if not is_master else 0.0
        self.offset_ns = 0
        
    def get_time(self) -> int:
        """Get current PTP time in nanoseconds."""
        elapsed = time.time_ns() - self.epoch
        # Apply simulated drift
        drift_factor = 1.0 + (self.ppm_drift / 1e6)
        
        return int(elapsed * drift_factor) + self.offset_ns + self.epoch
    
    def get_time_sec(self) -> float:
        """Get current PTP time in seconds."""
        return self.get_time() / 1e9
    
    def sync_with_master(self, master_time: int):
        """Synchronize slave clock with master time sample."""
        if self.is_master:
            return
            
        current_time = self.get_time()
        offset = master_time - current_time
        
        # Simple PI controller for smooth clock discipline
        # In a real PTP stack this is much more complex
        self.offset_ns += int(offset * 0.5)

```

#### simulation\tests\test_camera_simulator.py
```python
import unittest
import numpy as np
from src.nodes.camera_simulator import CameraSimulator

class TestCameraSimulator(unittest.TestCase):
    def setUp(self):
        self.camera = CameraSimulator(
            resolution={'width': 1920, 'height': 1080},
            fps=30,
            fov=90
        )
    
    def test_render_returns_bytes_when_due(self):
        # Timestamp 0.0 -> should render
        # Timestamp 0.001 -> should NOT render (too soon for 30fps)
        
        entities = [{'id': 'E1', 'position': {'x': 0, 'y': 0, 'z': 5}}]
        
        # First frame
        frame1 = self.camera.render(entities, timestamp=1.0)
        self.assertIsNotNone(frame1)
        self.assertIsInstance(frame1, bytes)
        
        # Too soon
        frame2 = self.camera.render(entities, timestamp=1.01)
        self.assertIsNone(frame2)
        
        # Next frame due (approx 33ms later)
        frame3 = self.camera.render(entities, timestamp=1.04)
        self.assertIsNotNone(frame3)

if __name__ == '__main__':
    unittest.main()

```

#### simulation\tests\test_performance.py
```python
import time
import unittest
from src.core.orchestrator import SimulationOrchestrator

class TestPerformance(unittest.TestCase):
    def test_fps_stability(self):
        # This test ensures the loop runs at ~30 FPS
        # We'll just run a few iter and check time
        
        # Mock orchestrator behavior without threading for test
        orch = SimulationOrchestrator()
        
        start_time = time.time()
        frames = 30
        
        for i in range(frames):
            orch._generate_sensor_data()
            orch._detect_anomalies()
            time.sleep(1/30) # Simulate loop wait
            
        elapsed = time.time() - start_time
        fps = frames / elapsed
        
        print(f"Measured FPS: {fps}")
        self.assertTrue(25 < fps < 35, f"FPS {fps} out of range")

if __name__ == '__main__':
    unittest.main()

```

## 5. Frontend

#### frontend\Dockerfile
```
# Build Stage
FROM node:18-slim AS builder
WORKDIR /app
COPY package.json ./
RUN npm install
COPY . .
# Skip type check based on previous tsconfig relaxation, but run build
RUN npm run build

# Serve Stage
FROM node:18-slim
WORKDIR /app
RUN npm install -g serve
COPY --from=builder /app/dist ./dist
EXPOSE 80
CMD ["serve", "-s", "dist", "-l", "80"]

```

#### frontend\index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motion Intelligence Grid</title>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

#### frontend\package.json
```json
{
    "name": "motiongrid-frontend",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.1",
        "three": "^0.160.0",
        "@react-three/fiber": "^8.15.12",
        "@react-three/drei": "^9.92.4",
        "socket.io-client": "^4.6.2",
        "recharts": "^2.10.3",
        "axios": "^1.6.2",
        "date-fns": "^2.30.0",
        "zustand": "^4.4.7",
        "clsx": "^2.0.0",
        "tailwind-merge": "^2.1.0",
        "lucide-react": "^0.294.0",
        "class-variance-authority": "^0.7.0"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@types/three": "^0.160.0",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.3.6",
        "typescript": "^5.2.2",
        "vite": "^5.0.8"
    }
}
```

#### frontend\tsconfig.json
```json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": [
            "ES2020",
            "DOM",
            "DOM.Iterable"
        ],
        "module": "ESNext",
        "skipLibCheck": true,
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        /* Linting */
        "strict": false,
        "noImplicitAny": false,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true
    },
    "include": [
        "src"
    ],
    "references": [
        {
            "path": "./tsconfig.node.json"
        }
    ]
}
```

#### frontend\tsconfig.node.json
```json
{
    "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "vite.config.ts"
    ]
}
```

#### frontend\vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        host: true,
        allowedHosts: true, // Allow Cloud Run domains
        port: 5173,
        proxy: {
            '/api': {
                target: 'http://localhost:3001',
                changeOrigin: true
            }
        }
    }
})

```

#### frontend\src\App.tsx
```typescript
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AppShell } from './components/layout/AppShell';
import { AuthProvider, useAuth } from './context/AuthContext';
import { Login } from './views/Login';

import Dashboard from './views/Dashboard/Dashboard';
import SystemConfig from './views/SystemConfig/SystemConfig';

import { LiveMonitoring } from './views/LiveMonitoring/index';
import { SessionReplay } from './views/SessionReplay/SessionReplay';
import { AnalyticsDashboard } from './views/Analytics/AnalyticsDashboard';

import { PlaceholderView } from './components/common/PlaceholderView';

import { SessionsList } from './views/Sessions/SessionsList';
import { AnomalyTriage } from './views/Triage/AnomalyTriage';
import { EntityProfile } from './views/Entities/EntityProfile';
import { EntitiesList } from './views/Entities/EntitiesList';

const RequireAuth = ({ children }: { children: JSX.Element }) => {
    const { isAuthenticated } = useAuth();
    const location = useLocation();

    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }
    return children;
};

function App() {
    return (
        <AuthProvider>
            <Router>
                <Routes>
                    <Route path="/login" element={<Login />} />

                    <Route path="/*" element={
                        <RequireAuth>
                            <AppShell>
                                <Routes>
                                    <Route path="/" element={<Dashboard />} />
                                    <Route path="/live" element={<LiveMonitoring />} />
                                    <Route path="/replay/:id" element={<SessionReplay />} />
                                    <Route path="/analytics" element={<AnalyticsDashboard />} />
                                    <Route path="/config" element={<SystemConfig />} />

                                    {/* New Features - No Longer Placeholders */}
                                    <Route path="/sessions" element={<SessionsList />} />
                                    <Route path="/sessions/:id" element={<SessionReplay />} />
                                    <Route path="/triage" element={<AnomalyTriage />} />
                                    <Route path="/entities" element={<EntitiesList />} />
                                    <Route path="/entities/:id" element={<EntityProfile />} />

                                    <Route path="/automation" element={<PlaceholderView title="Automation Rules" />} />

                                    {/* Fallback */}
                                    <Route path="*" element={<PlaceholderView title="404: Page Not Found" description="The page you are looking for does not exist." />} />
                                </Routes>
                            </AppShell>
                        </RequireAuth>
                    } />
                </Routes>
            </Router>
        </AuthProvider>
    )
}

export default App

```

#### frontend\src\index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  background-color: #020617;
  /* navy-950 */
  color: #f8fafc;
  /* light text */
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
```

#### frontend\src\main.tsx
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)

```

#### frontend\src\vite-env.d.ts
```typescript
/// <reference types="vite/client" />

```

#### frontend\src\components\common\PlaceholderView.tsx
```typescript
import React from 'react';
import { Construction } from 'lucide-react';
import { Card } from '../ui/Card';

interface PlaceholderViewProps {
    title: string;
    description?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
    title,
    description = "This feature is currently under development. Check back soon for updates."
}) => {
    return (
        <div className="p-6 h-full flex items-center justify-center">
            <Card className="max-w-md w-full p-8 text-center flex flex-col items-center gap-4 bg-navy-800 border-navy-700">
                <div className="w-16 h-16 bg-navy-900 rounded-full flex items-center justify-center border border-navy-700 shadow-inner">
                    <Construction className="w-8 h-8 text-primary-400" />
                </div>
                <div>
                    <h2 className="text-xl font-bold text-white mb-2">{title}</h2>
                    <p className="text-slate-400 leading-relaxed">
                        {description}
                    </p>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\components\layout\AppShell.tsx
```typescript
import { Sidebar } from './Sidebar';
import { TopBar } from './TopBar';

interface AppShellProps {
    children: React.ReactNode;
}

export function AppShell({ children }: AppShellProps) {
    return (
        <div className="min-h-screen bg-navy-950 text-slate-200 font-sans selection:bg-secondary-500/30">
            <TopBar />
            <Sidebar />

            <main className="pl-[260px] pt-[80px] min-h-screen transition-all duration-300">
                <div className="max-w-[1920px] mx-auto p-6 animate-in fade-in duration-500 slide-in-from-bottom-4">
                    {children}
                </div>
            </main>
        </div>
    );
}

```

#### frontend\src\components\layout\Sidebar.tsx
```typescript
import {
    LayoutDashboard,
    Radio,
    Server,
    Settings,
    Bell,
    Search,
    Menu,
    Play,
    LayoutGrid,
    Activity,
    Video,
    BarChart3,
    Zap,
    AlertTriangle,
    Users,
    HelpCircle,
    LogOut
} from 'lucide-react';
import { NavLink } from 'react-router-dom';
import { cn } from '../../utils/cn';

const NAV_ITEMS = [
    { label: 'Overview', path: '/', icon: LayoutGrid },
    { label: 'Live Intelligence', path: '/live', icon: Activity },
    { label: 'Session Replay', path: '/replay/mock-session-1', icon: Play }, // Added for easy access
    { label: 'System Config', path: '/config', icon: Settings },
    { label: 'Sessions', path: '/sessions', icon: Video },
    { label: 'Analytics', path: '/analytics', icon: BarChart3 },
    { label: 'Automation', path: '/automation', icon: Zap },
    { label: 'Triage', path: '/triage', icon: AlertTriangle },
    { label: 'Entities', path: '/entities', icon: Users },
];

export function Sidebar() {
    return (
        <aside className="w-[260px] bg-navy-900 border-r border-navy-800 fixed left-0 top-0 bottom-0 pt-[80px] flex flex-col z-40">
            <div className="flex-1 overflow-y-auto py-6 px-3 space-y-1">
                <div className="text-xs font-bold text-slate-500 uppercase px-4 mb-2 tracking-wider">Menu</div>
                {NAV_ITEMS.map((item) => (
                    <NavLink
                        key={item.path}
                        to={item.path}
                        className={({ isActive }) => cn(
                            "flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200",
                            isActive
                                ? "bg-secondary-600/10 text-secondary-400 border border-secondary-600/20 shadow-[0_0_15px_rgba(99,102,241,0.1)]"
                                : "text-slate-400 hover:bg-navy-800 hover:text-slate-200"
                        )}
                    >
                        <item.icon className="w-5 h-5" />
                        {item.label}
                    </NavLink>
                ))}
            </div>

            <div className="p-4 border-t border-navy-800 space-y-1">
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-navy-800 hover:text-slate-200 transition-colors">
                    <HelpCircle className="w-5 h-5" />
                    Help & Docs
                </button>
                <button className="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium text-slate-400 hover:bg-red-900/20 hover:text-red-400 transition-colors">
                    <LogOut className="w-5 h-5" />
                    Logout
                </button>
            </div>
        </aside>
    );
}

```

#### frontend\src\components\layout\TopBar.tsx
```typescript
import { Bell, Settings, User, Search } from 'lucide-react';
import { Button } from '../ui/Button';

export function TopBar() {
    return (
        <header className="h-[80px] bg-navy-950 border-b border-navy-800 flex items-center justify-between px-6 fixed top-0 left-0 right-0 z-50">
            {/* Left: Logo & Context */}
            <div className="flex items-center gap-6">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-secondary-600 rounded-lg flex items-center justify-center shadow-lg shadow-primary-500/20">
                        <svg className="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                    </div>
                    <span className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-400 to-secondary-400">
                        MotionGrid
                    </span>
                </div>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div className="flex items-center gap-2 text-slate-400 bg-navy-900 py-2 px-4 rounded-lg border border-navy-800">
                    <Search className="w-4 h-4" />
                    <span className="text-sm">Global Search...</span>
                </div>
            </div>

            {/* Right: Actions & Profile */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" className="relative" onClick={() => alert("Notifications coming soon!")}>
                    <Bell className="w-5 h-5 text-slate-400" />
                    <span className="absolute top-2 right-2 w-2 h-2 bg-status-critical rounded-full animate-pulse" />
                </Button>
                <Button variant="ghost" size="icon" onClick={() => alert("Settings panel coming soon!")}>
                    <Settings className="w-5 h-5 text-slate-400" />
                </Button>

                <div className="h-8 w-px bg-navy-800 mx-2" />

                <div
                    className="flex items-center gap-3 pl-2 cursor-pointer hover:bg-navy-900 p-2 rounded-lg transition-colors"
                    onClick={() => alert("User profile management coming soon!")}
                >
                    <div className="text-right hidden md:block">
                        <div className="text-sm font-semibold text-white">Admin User</div>
                        <div className="text-xs text-primary-400">OPERATOR</div>
                    </div>
                    <div className="w-10 h-10 bg-navy-800 rounded-full flex items-center justify-center border border-navy-700">
                        <User className="w-5 h-5 text-slate-300" />
                    </div>
                </div>
            </div>
        </header>
    );
}

```

#### frontend\src\components\ui\Badge.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const badgeVariants = cva(
    "inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide transition-colors",
    {
        variants: {
            variant: {
                default: "bg-navy-700 text-white",
                critical: "bg-status-critical text-white shadow-[0_0_10px_rgba(220,38,38,0.4)]",
                high: "bg-status-high text-white",
                medium: "bg-status-medium text-white",
                low: "bg-status-low text-white",
                success: "bg-status-success text-white",
                outline: "border border-navy-700 text-slate-400 bg-transparent",
            },
            size: {
                sm: "text-[10px] px-2 py-0.5",
                md: "text-xs px-3 py-1",
                lg: "text-sm px-4 py-1.5",
            }
        },
        defaultVariants: {
            variant: "default",
            size: "md",
        }
    }
);

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof badgeVariants> { }

export function Badge({ className, variant, size, ...props }: BadgeProps) {
    return (
        <span className={badgeVariants({ variant, size, className })} {...props} />
    );
}

```

#### frontend\src\components\ui\Button.tsx
```typescript
import { cva, type VariantProps } from 'class-variance-authority';
import React from 'react';

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-lg text-sm font-semibold transition-all focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none active:scale-95",
    {
        variants: {
            variant: {
                primary: "bg-secondary-600 text-white hover:bg-secondary-500 shadow-lg shadow-secondary-900/20",
                secondary: "border border-navy-700 bg-transparent text-slate-300 hover:bg-navy-800",
                danger: "bg-status-critical text-white hover:bg-red-700",
                ghost: "bg-transparent text-slate-400 hover:text-white hover:bg-navy-800",
                icon: "p-2 bg-transparent text-slate-400 hover:bg-navy-800 hover:text-white rounded-md",
            },
            size: {
                sm: "px-3 py-1.5 text-xs",
                md: "px-4 py-2",
                lg: "px-6 py-3 text-base",
                icon: "h-9 w-9 p-0",
            },
            fullWidth: {
                true: "w-full",
            }
        },
        defaultVariants: {
            variant: "primary",
            size: "md",
            fullWidth: false,
        }
    }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, fullWidth, ...props }, ref) => {
        return (
            <button
                ref={ref}
                className={buttonVariants({ variant, size, fullWidth, className })}
                {...props}
            />
        );
    }
);
Button.displayName = "Button";

```

#### frontend\src\components\ui\Card.tsx
```typescript
import { cn } from '../../utils/cn';
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    hover?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
    ({ className, hover = true, children, ...props }, ref) => {
        return (
            <div
                ref={ref}
                className={cn(
                    "bg-navy-800 border border-navy-700 rounded-xl shadow-md p-5",
                    "transition-all duration-200 ease-out",
                    hover && "hover:-translate-y-0.5 hover:shadow-lg hover:shadow-black/20 hover:border-navy-600",
                    className
                )}
                {...props}
            >
                {children}
            </div>
        );
    }
);
Card.displayName = "Card";

export function CardHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("mb-4 flex items-center justify-between", className)} {...props}>
            {children}
        </div>
    );
}

export function CardTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
    return (
        <h3 className={cn("text-lg font-bold text-white", className)} {...props}>
            {children}
        </h3>
    );
}

export function CardContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("text-sm text-slate-300 leading-relaxed", className)} {...props}>
            {children}
        </div>
    );
}

```

#### frontend\src\context\AuthContext.tsx
```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import { api } from '../services/api';

interface User {
    id: string;
    email: string;
    role: string;
    username: string;
}

interface AuthContextType {
    user: User | null;
    token: string | null;
    login: (token: string, user: User) => void;
    logout: () => void;
    isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [token, setToken] = useState<string | null>(null);

    useEffect(() => {
        // Init from local storage
        const storedToken = localStorage.getItem('token');
        const storedUser = localStorage.getItem('user');

        if (storedToken && storedUser) {
            try {
                setToken(storedToken);
                setUser(JSON.parse(storedUser));
                // Set default header
                api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
            } catch (e) {
                console.error("Failed to parse stored user", e);
                localStorage.clear();
            }
        }
    }, []);

    const login = (newToken: string, newUser: User) => {
        setToken(newToken);
        setUser(newUser);
        localStorage.setItem('token', newToken);
        localStorage.setItem('user', JSON.stringify(newUser));
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
    };

    const logout = () => {
        setToken(null);
        setUser(null);
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        delete api.defaults.headers.common['Authorization'];
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout, isAuthenticated: !!token }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

```

#### frontend\src\services\api.ts
```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';

export const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

export const Api = {
    // Nodes
    getNodes: async () => (await api.get('/nodes')).data,
    getNode: async (id: string) => (await api.get(`/nodes/${id}`)).data,
    createNode: async (data: any) => (await api.post('/nodes', data)).data,
    updateNode: async (id: string, data: any) => (await api.patch(`/nodes/${id}`, data)).data,
    deleteNode: async (id: string) => (await api.delete(`/nodes/${id}`)).data,
    calibrateNode: async (id: string) => (await api.post(`/nodes/${id}/calibrate`)).data,

    // Sessions
    getSessions: async () => (await api.get('/sessions')).data,
    getSession: async (id: string) => (await api.get(`/sessions/${id}`)).data,
    createSession: async (data: any) => (await api.post('/sessions', data)).data,
    updateSession: async (id: string, data: any) => (await api.patch(`/sessions/${id}`, data)).data,
    deleteSession: async (id: string) => (await api.delete(`/sessions/${id}`)).data,
    startSession: async (id: string) => (await api.post(`/sessions/${id}/start`)).data,
    stopSession: async (id: string) => (await api.post(`/sessions/${id}/stop`)).data,

    // Simulation
    startSimulation: async (config: any) => (await api.post('/simulation/start', config)).data,
    stopSimulation: async () => (await api.post('/simulation/stop')).data,
    getSimulationStatus: async () => (await api.get('/simulation/status')).data,

    // Entities
    getEntities: async () => (await api.get('/entities')).data,

    // Analytics
    getStats: async () => (await api.get('/analytics/stats')).data
};

```

#### frontend\src\services\websocket.ts
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketService {
    private socket: Socket | null = null;
    private callbacks: Map<string, Function[]> = new Map();

    connect(url: string) {
        const token = localStorage.getItem('auth_token');
        this.socket = io(url, {
            transports: ['websocket'],
            reconnection: true,
            auth: { token }
        });

        this.socket.on('connect', () => {
            console.log('WebSocket connected');
            // Re-subscribe if we had active subscriptions? 
            // For now, simpler to leave it to the components.
        });

        this.socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        // Register for all expected events
        ['sensor:frame', 'anomaly:detected', 'entity:tracking', 'session:stats', 'node:status']
            .forEach(event => {
                this.socket!.on(event, (data: any) => {
                    const cbs = this.callbacks.get(event) || [];
                    cbs.forEach(cb => cb(data));
                });
            });
    }

    subscribeToSession(sessionId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:session', { sessionId });
    }

    subscribeToNode(nodeId: string) {
        if (!this.socket) return;
        this.socket.emit('subscribe:node', { nodeId });
    }

    on(event: string, callback: Function) {
        if (!this.callbacks.has(event)) {
            this.callbacks.set(event, []);
        }
        this.callbacks.get(event)!.push(callback);
    }

    off(event: string, callback: Function) {
        if (!this.callbacks.has(event)) return;
        const cbs = this.callbacks.get(event) || [];
        this.callbacks.set(event, cbs.filter(cb => cb !== callback));
    }

    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
}

export const wsService = new WebSocketService();

```

#### frontend\src\utils\cn.ts
```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

```

#### frontend\src\views\Login.tsx
```typescript
import React, { useState } from 'react';
import { useAuth } from '../context/AuthContext';
import { api } from '../services/api';
import { useNavigate, useLocation } from 'react-router-dom';
import { KeyRound, Mail, User, Loader2 } from 'lucide-react';

export const Login: React.FC = () => {
    const { login } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    // Redirect to where they came from (or dashboard)
    const from = (location.state as any)?.from?.pathname || '/';

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            const response = await api.post('/auth/login', { email, password });
            const { token, user } = response.data;
            login(token, user);
            navigate(from, { replace: true });
        } catch (err: any) {
            console.error(err);
            setError(err.response?.data?.error || 'Login failed. Please check your credentials.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-slate-950 flex items-center justify-center p-4">
            <div className="bg-slate-900 border border-slate-800 rounded-xl max-w-md w-full p-8 shadow-2xl">
                <div className="text-center mb-8">
                    <div className="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-4 shadow-lg shadow-blue-900/50">
                        <KeyRound className="w-8 h-8 text-white" />
                    </div>
                    <h2 className="text-3xl font-bold text-white mb-2">Welcome Back</h2>
                    <p className="text-slate-400">Sign in to Motion Intelligence Grid</p>
                </div>

                {error && (
                    <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4 mb-6 text-red-500 text-sm">
                        {error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Email Address</label>
                        <div className="relative">
                            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="operator@motiongrid.com"
                            />
                        </div>
                    </div>

                    <div>
                        <label className="block text-sm font-medium text-slate-400 mb-2">Password</label>
                        <div className="relative">
                            <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
                            <input
                                type="password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full bg-slate-950 border border-slate-800 rounded-lg py-3 pl-10 pr-4 text-white placeholder-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:border-transparent transition"
                                placeholder="••••••••"
                            />
                        </div>
                    </div>

                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg transition shadow-lg shadow-blue-900/20 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                    >
                        {loading ? (
                            <>
                                <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                                Signing in...
                            </>
                        ) : (
                            'Sign In'
                        )}
                    </button>
                </form>

                <div className="mt-6 text-center text-sm text-slate-500">
                    <p>Default Admin: admin@freeforge.com / nimda</p>
                </div>
            </div>
        </div>
    );
};

```

#### frontend\src\views\Analytics\AnalyticsDashboard.tsx
```typescript
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';

export const AnalyticsDashboard = () => {
    return (
        <div className="p-6 space-y-6 text-white h-full overflow-y-auto">
            <h1 className="text-2xl font-bold mb-4">System Analytics</h1>

            {/* KPI Grid */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <KPICard title="Total Sessions" value="1,284" trend="+12%" />
                <KPICard title="Avg. Anomaly Rate" value="0.4/hr" trend="-5%" trendGood />
                <KPICard title="Active Nodes" value="24/24" trend="100%" />
                <KPICard title="Data Throughput" value="1.2 GB/s" trend="+8%" />
            </div>

            {/* Charts Section */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">Anomaly Distribution by Type</h3>
                    <div className="flex items-end justify-around h-60 gap-4 pb-2 border-b border-slate-700">
                        <Bar height="30%" label="Speed" color="bg-blue-500" />
                        <Bar height="60%" label="Crowd" color="bg-purple-500" />
                        <Bar height="15%" label="Zone" color="bg-yellow-500" />
                        <Bar height="45%" label="Formation" color="bg-green-500" />
                    </div>
                </Card>

                <Card className="p-4 h-80">
                    <h3 className="font-semibold mb-4">System Load (24h)</h3>
                    {/* Simple SVG Line Chart */}
                    <div className="h-60 w-full relative">
                        <svg className="w-full h-full overflow-visible">
                            <defs>
                                <linearGradient id="grad" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="#0ea5e9" stopOpacity="0.5" />
                                    <stop offset="100%" stopColor="#0ea5e9" stopOpacity="0" />
                                </linearGradient>
                            </defs>
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20 V150 H0 Z"
                                fill="url(#grad)"
                            />
                            <path
                                d="M0,80 Q50,20 100,50 T200,80 T300,40 T400,90 T500,20"
                                fill="none"
                                stroke="#0ea5e9"
                                strokeWidth="3"
                            />
                        </svg>
                        <div className="absolute bottom-0 w-full text-xs text-slate-500 flex justify-between">
                            <span>00:00</span>
                            <span>06:00</span>
                            <span>12:00</span>
                            <span>18:00</span>
                            <span>24:00</span>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const KPICard = ({ title, value, trend, trendGood = false }: any) => (
    <Card className="p-4">
        <div className="text-slate-400 text-sm">{title}</div>
        <div className="text-2xl font-bold mt-1">{value}</div>
        <div className={`text-xs mt-2 ${trendGood || trend.startsWith('+') ? 'text-green-400' : 'text-slate-500'}`}>
            {trend} vs last week
        </div>
    </Card>
);

const Bar = ({ height, label, color }: any) => (
    <div className="flex flex-col items-center flex-1 h-full justify-end group">
        <div className={`w-full max-w-[40px] rounded-t-sm ${color} transition-all duration-500`} style={{ height }}></div>
        <div className="text-xs text-slate-400 mt-2">{label}</div>
    </div>
);

```

#### frontend\src\views\Dashboard\Dashboard.tsx
```typescript
import { AnomalyPanel } from './components/AnomalyPanel';
import { DashboardControls } from './components/DashboardControls';
import { StadiumMap } from './components/StadiumMap';
import { DashboardSparkline } from './components/DashboardSparkline';

const Dashboard = () => {
    return (
        <div className="space-y-6">
            <DashboardControls />

            <div className="flex flex-col lg:flex-row gap-6">
                {/* Main View: Stadium Map */}
                <div className="flex-1">
                    <StadiumMap />

                    {/* Bottom Sparkline */}
                    <div className="mt-6 h-[100px] bg-navy-900 border border-navy-800 rounded-xl relative overflow-hidden p-2">
                        <DashboardSparkline />
                    </div>
                </div>

                {/* Right Panel: Anomalies */}
                <AnomalyPanel />
            </div>
        </div>
    );
};

export default Dashboard;

```

#### frontend\src\views\Dashboard\components\AnomalyPanel.tsx
```typescript
import { Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '../../../components/ui/Button';
import { Badge } from '../../../components/ui/Badge';

const ANOMALIES = [
    { id: 1, time: '11:22', zone: 'Gate B', type: 'Crowd Compression', severity: 'critical', score: 87, delta: '+150%' },
    { id: 2, time: '11:20', zone: 'Concourse N', type: 'Rapid Movement', severity: 'high', score: 65, delta: '+80%' },
    { id: 3, time: '11:15', zone: 'Field', type: 'Unauthorized Access', severity: 'medium', score: 45, delta: 'N/A' },
    { id: 4, time: '11:10', zone: 'Gate A', type: 'Loitering', severity: 'low', score: 20, delta: '+15%' },
];

export function AnomalyPanel() {
    return (
        <div className="w-full lg:w-[360px] bg-navy-900 border border-navy-800 rounded-2xl flex flex-col h-[600px]">
            {/* Header */}
            <div className="p-4 border-b border-navy-800 flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-bold text-white">Active Anomalies</h3>
                    <div className="text-xs text-slate-400">23 Detected • <span className="text-status-critical">4 Critical</span></div>
                </div>
                <div className="flex gap-2">
                    <Button variant="ghost" size="icon"><Filter className="w-4 h-4" /></Button>
                    <Button variant="ghost" size="icon"><MoreHorizontal className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* List */}
            <div className="flex-1 overflow-y-auto p-3 space-y-3">
                {ANOMALIES.map((item) => (
                    <div
                        key={item.id}
                        className="group bg-navy-800 rounded-xl p-3 border border-navy-700 hover:border-indigo-500/50 hover:bg-navy-800/80 transition-all cursor-pointer relative overflow-hidden"
                    >
                        {/* Severity Indicator Bar */}
                        <div className={`absolute left-0 top-0 bottom-0 w-1 ${item.severity === 'critical' ? 'bg-status-critical' :
                            item.severity === 'high' ? 'bg-status-high' :
                                item.severity === 'medium' ? 'bg-status-medium' : 'bg-status-low'
                            }`} />

                        <div className="pl-3">
                            <div className="flex justify-between items-start mb-1">
                                <Badge variant={item.severity as any} size="sm">{item.severity}</Badge>
                                <span className="text-xs font-mono text-slate-500">{item.time}</span>
                            </div>

                            <h4 className="font-bold text-white text-sm mb-1 group-hover:text-indigo-300 transition-colors">{item.type}</h4>
                            <div className="flex justify-between items-center text-xs">
                                <span className="text-slate-400 uppercase tracking-wide font-semibold">{item.zone}</span>
                                <div className="flex gap-3 text-slate-500">
                                    <span>Risk: <span className={item.score > 80 ? 'text-red-400' : 'text-slate-300'}>{item.score}</span></span>
                                    <span>Δ: {item.delta}</span>
                                </div>
                            </div>
                        </div>

                        {/* Hover Actions Overlay (Simulated) */}
                        <div className="absolute right-2 bottom-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button size="sm" variant="secondary" className="h-7 text-xs px-2">View</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* Footer */}
            <div className="p-4 border-t border-navy-800 bg-navy-950/50 rounded-b-2xl">
                <Button variant="primary" fullWidth size="md">View All Anomalies</Button>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardControls.tsx
```typescript
import { Calendar, ChevronDown } from 'lucide-react';

export function DashboardControls() {
    return (
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6 bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
            {/* Event Selector */}
            <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-indigo-500/20 rounded-lg flex items-center justify-center text-indigo-400">
                    <Calendar className="w-5 h-5" />
                </div>
                <div>
                    <div className="text-xs text-slate-400 uppercase font-bold tracking-wide">Current Event</div>
                    <div className="flex items-center gap-2 text-white font-semibold cursor-pointer hover:text-indigo-400 transition-colors">
                        Match Day: Team A vs Team B
                        <ChevronDown className="w-4 h-4" />
                    </div>
                </div>
            </div>

            {/* Time Range Chips */}
            <div className="flex bg-navy-900 rounded-lg p-1 border border-navy-700">
                {['Now', 'Last 30m', 'Last 2h', '24h', 'Custom'].map((range, idx) => (
                    <button
                        key={range}
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${idx === 0
                            ? 'bg-secondary-600 text-white shadow-md'
                            : 'text-slate-400 hover:text-white hover:bg-navy-700'
                            }`}
                    >
                        {range}
                    </button>
                ))}
            </div>

            {/* System Status */}
            <div className="flex items-center gap-2 px-4 py-2 bg-status-success/10 border border-status-success/20 rounded-lg text-status-success">
                <span className="relative flex h-2.5 w-2.5">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
                </span>
                <span className="text-sm font-bold tracking-wide">SYSTEM OPTIMAL</span>
            </div>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\DashboardSparkline.tsx
```typescript
import { Area, AreaChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from 'recharts';

const generateMockData = () => {
    const data = [];
    for (let i = 0; i < 24; i++) {
        data.push({
            time: `${i}:00`,
            events: Math.floor(Math.random() * 50) + 10,
            anomalies: Math.floor(Math.random() * 5),
        });
    }
    return data;
};

const data = generateMockData();

export function DashboardSparkline() {
    return (
        <div className="w-full h-full">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={data}>
                    <defs>
                        <linearGradient id="colorEvents" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#818cf8" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#818cf8" stopOpacity={0} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis hide />
                    <Tooltip
                        contentStyle={{ backgroundColor: '#1e293b', borderColor: '#334155', color: '#f8fafc' }}
                        itemStyle={{ color: '#818cf8' }}
                        labelStyle={{ color: '#94a3b8' }}
                    />
                    <Area
                        type="monotone"
                        dataKey="events"
                        stroke="#818cf8"
                        fillOpacity={1}
                        fill="url(#colorEvents)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
}

```

#### frontend\src\views\Dashboard\components\StadiumMap.tsx
```typescript
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ZONES = [
    { id: 'gate-a', name: 'GATE A', type: 'GATE', status: 'critical', x: '10%', y: '20%' },
    { id: 'gate-b', name: 'GATE B', type: 'GATE', status: 'normal', x: '80%', y: '20%' },
    { id: 'field', name: 'FIELD', type: 'FIELD', status: 'normal', x: '45%', y: '45%' },
    { id: 'concourse-n', name: 'CONCOURSE N', type: 'CONCOURSE', status: 'high', x: '45%', y: '10%' },
    { id: 'concourse-s', name: 'CONCOURSE S', type: 'CONCOURSE', status: 'normal', x: '45%', y: '80%' },
];

export function StadiumMap() {
    return (
        <div className="relative w-full h-[600px] bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden shadow-inner">
            {/* Grid Pattern Background */}
            <div className="absolute inset-0 opacity-10"
                style={{ backgroundImage: 'radial-gradient(circle, #334155 1px, transparent 1px)', backgroundSize: '30px 30px' }}
            />

            {/* Stadium Visual Placeholder - Simple SVG representation */}
            <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 600">
                {/* Field */}
                <rect x="250" y="150" width="500" height="300" rx="40" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <circle cx="500" cy="300" r="50" fill="none" stroke="#334155" strokeWidth="2" />
                <line x1="500" y1="150" x2="500" y2="450" stroke="#334155" strokeWidth="2" />

                {/* Zones Outline */}
                <path d="M 150 100 Q 500 0 850 100 L 900 250 L 850 500 Q 500 600 150 500 L 100 250 Z"
                    fill="none" stroke="#4f46e5" strokeWidth="2" strokeDasharray="10 5" opacity="0.3" />
            </svg>

            {/* Zone Cards Overlay */}
            {ZONES.map((zone) => (
                <div
                    key={zone.id}
                    className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer transition-transform hover:scale-105 hover:z-10"
                    style={{ left: zone.x, top: zone.y }}
                >
                    <Card className={`w-48 p-3 bg-navy-800/90 backdrop-blur-sm border-l-4 ${zone.status === 'critical' ? 'border-l-status-critical shadow-[0_0_20px_rgba(220,38,38,0.2)]' :
                            zone.status === 'high' ? 'border-l-status-high' :
                                'border-l-status-success'
                        }`}>
                        <div className="flex justify-between items-start mb-2">
                            <span className="text-xs font-bold text-slate-300 tracking-wider">{zone.name}</span>
                            <Badge variant={zone.status as any} size="sm">{zone.status}</Badge>
                        </div>
                        <div className="space-y-1">
                            <div className="text-xs text-slate-400">Last event: 2m ago</div>
                            <div className="text-xs text-slate-400">Anomalies: <span className="text-white font-mono">3</span></div>
                        </div>
                    </Card>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\Entities\EntitiesList.tsx
```typescript

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Search, Filter, Eye } from 'lucide-react';
import { api } from '../../services/api';

interface Entity {
    id: string;
    type: string;
    role?: string;
    team?: string;
    lastSeen: number;
    status: 'ACTIVE' | 'INACTIVE';
}

export const EntitiesList = () => {
    const navigate = useNavigate();
    const [entities, setEntities] = useState<Entity[]>([]);
    const [search, setSearch] = useState('');

    useEffect(() => {
        const fetchEntities = async () => {
            try {
                // Mock endpoint or real if available
                const data = await api.get('/entities');
                if (Array.isArray(data)) setEntities(data);
            } catch (err) {
                // Determine mock data if API fails (for demo robustness)
                setEntities([
                    { id: 'HOME_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'HOME_PLAYER_2', type: 'PERSON', role: 'PLAYER', team: 'HOME', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'AWAY_PLAYER_1', type: 'PERSON', role: 'PLAYER', team: 'AWAY', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'REF_1', type: 'PERSON', role: 'REFEREE', team: 'NEUTRAL', lastSeen: Date.now(), status: 'ACTIVE' },
                    { id: 'BALL', type: 'OBJECT', role: 'game_ball', lastSeen: Date.now(), status: 'ACTIVE' },
                ]);
            }
        }
        fetchEntities();
    }, []);

    const filtered = entities.filter(e => e.id.toLowerCase().includes(search.toLowerCase()));

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Entity Directory</h1>
                <div className="flex gap-2">
                    <div className="relative">
                        <Search className="absolute left-3 top-2.5 w-4 h-4 text-slate-400" />
                        <input
                            type="text"
                            placeholder="Search entities..."
                            className="bg-slate-900 border border-slate-700 rounded-md pl-9 pr-4 py-2 text-sm focus:outline-none focus:border-blue-500 w-64"
                            value={search}
                            onChange={(e) => setSearch(e.target.value)}
                        />
                    </div>
                    <Button variant="outline"><Filter className="w-4 h-4 mr-2" /> Filter</Button>
                </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filtered.map(entity => (
                    <Card key={entity.id} className="hover:border-blue-500/50 transition-colors cursor-pointer" onClick={() => navigate(`/entities/${entity.id}`)}>
                        <div className="flex justify-between items-start mb-4">
                            <Badge variant={entity.team === 'HOME' ? 'critical' : entity.team === 'AWAY' ? 'primary' : 'outline'}>
                                {entity.role || entity.type}
                            </Badge>
                            <div className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]" />
                        </div>
                        <h3 className="text-lg font-bold mb-1">{entity.id}</h3>
                        <div className="text-slate-400 text-sm mb-4">
                            Last seen: {new Date(entity.lastSeen).toLocaleTimeString()}
                        </div>
                        <div className="flex justify-end">
                            <Button variant="ghost" size="sm">
                                <Eye className="w-4 h-4 mr-2" /> View Profile
                            </Button>
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\Entities\EntityProfile.tsx
```typescript
import { useParams, useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { ArrowLeft, Activity, Shield, MapPin } from 'lucide-react';

export const EntityProfile = () => {
    const { id } = useParams();
    const navigate = useNavigate();

    return (
        <div className="p-6 text-white max-w-5xl mx-auto">
            <Button variant="ghost" size="sm" onClick={() => navigate(-1)} className="mb-4">
                <ArrowLeft className="w-4 h-4 mr-2" /> Back
            </Button>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Profile Header */}
                <Card className="md:col-span-3 p-6 flex items-center gap-6">
                    <div className="w-24 h-24 rounded-full bg-slate-800 flex items-center justify-center text-3xl font-bold text-blue-400">
                        {id?.substring(0, 2).toUpperCase() || 'E'}
                    </div>
                    <div>
                        <h1 className="text-3xl font-bold">{id || 'Unknown Entity'}</h1>
                        <div className="text-slate-400 flex gap-4 mt-2">
                            <span className="flex items-center gap-1"><Shield className="w-4 h-4" /> Security Staff</span>
                            <span className="flex items-center gap-1"><MapPin className="w-4 h-4" /> Zone B</span>
                            <span className="flex items-center gap-1 text-green-400"><Activity className="w-4 h-4" /> Active</span>
                        </div>
                    </div>
                </Card>

                {/* Stats */}
                <Card className="p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Movement Stats</h3>
                    <div className="space-y-4">
                        <Stat label="Avg Speed" value="1.4 m/s" />
                        <Stat label="Distance" value="4.2 km" />
                        <Stat label="Zone Violations" value="0" />
                    </div>
                </Card>

                {/* Recent Activity */}
                <Card className="md:col-span-2 p-6">
                    <h3 className="font-semibold mb-4 text-slate-400 uppercase text-xs">Recent Activity Timeline</h3>
                    <div className="space-y-4">
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:45</div>
                            <div>Entered Zone B (North Gate)</div>
                        </div>
                        <div className="flex gap-4">
                            <div className="text-sm text-slate-500 w-16">10:30</div>
                            <div>Shift Started</div>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

const Stat = ({ label, value }: any) => (
    <div className="flex justify-between items-center border-b border-slate-800 pb-2">
        <span className="text-slate-400 text-sm">{label}</span>
        <span className="font-mono">{value}</span>
    </div>
);

```

#### frontend\src\views\LiveMonitoring\AlertPanel.tsx
```typescript
import { useEffect, useState } from 'react';
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';
import { wsService } from '../../services/websocket';

interface Anomaly {
    id: string;
    headline: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    time: string;
}

export const AlertPanel = () => {
    const [alerts, setAlerts] = useState<Anomaly[]>([]);

    useEffect(() => {
        // Connect if not already (MeshView also connects, but idempotent)
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            console.log('Anomaly received:', data);

            // Map Python payload to frontend model
            // Python sends: { anomalyId, headline, severity, occurredAt, ... }
            const newAlert: Anomaly = {
                id: data.anomalyId || 'unknown',
                headline: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                // occurredAt is ISO string now
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };

            setAlerts(prev => [newAlert, ...prev].slice(0, 50)); // Keep last 50
        });

        return () => {
            // Unsubscribe logic if wsService supports it, or just let it exist
        };
    }, []);

    return (
        <div className="bg-gray-800 border-l border-gray-700 w-80 flex flex-col h-full">
            <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-red-400" />
                    Active Alerts
                </h3>
            </div>

            <div className="flex-1 overflow-auto p-4 space-y-3">
                {alerts.length === 0 && (
                    <div className="text-gray-500 text-center text-sm py-8">
                        No active alerts.
                    </div>
                )}
                {alerts.map(alert => (
                    <div key={alert.id} className="bg-gray-700/50 rounded-lg p-3 border border-gray-600 hover:border-gray-500 transition-colors">
                        <div className="flex justify-between items-start mb-2">
                            <span className={`text-xs font-bold px-1.5 py-0.5 rounded ${alert.severity === 'CRITICAL' ? 'bg-red-500/20 text-red-300' :
                                alert.severity === 'HIGH' ? 'bg-orange-500/20 text-orange-300' : 'bg-blue-500/20 text-blue-300'
                                }`}>
                                {alert.severity}
                            </span>
                            <span className="text-xs text-gray-400">{alert.time}</span>
                        </div>
                        <h4 className="text-sm font-medium mb-2">{alert.headline}</h4>

                        {/* Triage Actions */}
                        <div className="flex gap-2 mt-2">
                            <button className="flex-1 flex items-center justify-center gap-1 bg-green-900/30 hover:bg-green-900/50 text-green-300 py-1 rounded text-xs transition-colors">
                                <CheckCircle className="h-3 w-3" /> Confirm
                            </button>
                            <button className="flex-1 flex items-center justify-center gap-1 bg-gray-600/30 hover:bg-gray-600/50 text-gray-300 py-1 rounded text-xs transition-colors">
                                <XCircle className="h-3 w-3" /> Dismiss
                            </button>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\CameraGrid.tsx
```typescript

import { useEffect, useState } from 'react';
import { Camera } from 'lucide-react';
import { VideoPlaceholder } from './components/VideoPlaceholder';
import { Api } from '../../../services/api';

interface CameraNode {
    id: string; // real ID (uuid)
    nodeId: string; // human readable (CAM_01)
    status: string;
}

export const CameraGrid = () => {
    const [cameras, setCameras] = useState<CameraNode[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                // Map backend nodes to camera view
                // Backend node has: nodeId (string), id (uuid), config...
                const mapped = data.nodes.map((n: any) => ({
                    id: n._id,
                    nodeId: n.nodeId,
                    status: 'ONLINE' // Assume online if fetched for now
                }));

                if (mapped.length > 0) {
                    setCameras(mapped);
                } else {
                    // Fallback to placeholders if no real nodes found (for demo preservation)
                    setCameras([
                        { id: 'mock1', nodeId: 'CAM_01 (Sim)', status: 'ONLINE' },
                        { id: 'mock2', nodeId: 'CAM_02 (Sim)', status: 'ONLINE' },
                    ]);
                }
            } catch (e) {
                console.error("Failed to fetch camera nodes", e);
                // Fallback
                setCameras([
                    { id: 'mock1', nodeId: 'CAM_01 (Offline)', status: 'OFFLINE' },
                    { id: 'mock2', nodeId: 'CAM_02 (Offline)', status: 'OFFLINE' },
                ]);
            } finally {
                setLoading(false);
            }
        };

        fetchNodes();
    }, []);

    if (loading) {
        return <div className="text-white text-center p-4">Loading streams...</div>;
    }

    return (
        <div className="grid grid-cols-2 gap-2 h-full">
            {cameras.map(cam => (
                <div key={cam.id} className="relative bg-black rounded overflow-hidden group">
                    <div className="absolute inset-0 flex items-center justify-center text-gray-700">
                        {cam.status === 'ONLINE' ? (
                            <div className="flex-1 bg-black relative w-full h-full">
                                {/* Pass nodeId only if it's not a mock ID, or handle mock logic inside VideoPlaceholder? 
                                    Actually, if we want real stream, we need real nodeId (CAM_01 etc from sim).
                                    If mapped from real API, cam.nodeId is what we want.
                                */}
                                <VideoPlaceholder
                                    label={cam.nodeId}
                                    // Use cam.nodeId as endpoint parameter. 
                                    // If it's a mock fallback, this might fail to stream (404) and component will fallback to noise.
                                    nodeId={cam.nodeId}
                                />
                            </div>) : (
                            <div className="flex flex-col items-center">
                                <Camera className="h-8 w-8 mb-2 opacity-50" />
                                <span className="text-xs">OFFLINE</span>
                            </div>
                        )}
                    </div>

                    {/* Overlay */}
                    <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white backdrop-blur-sm">
                        {cam.nodeId}
                    </div>
                    <div className={`absolute top-2 right-2 w-2 h-2 rounded-full ${cam.status === 'ONLINE' ? 'bg-green-500' : 'bg-red-500'}`} />
                </div>
            ))}
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\index.tsx
```typescript
import { useEffect } from 'react';
import { MeshView3D } from './MeshView3D';
import { LayerControls } from './components/LayerControls';
import { LiveAlerts } from './components/LiveAlerts';
import { CameraStrip } from './components/CameraStrip';
import { wsService } from '../../services/websocket';
import { Button } from '../../components/ui/Button';
import { Pause, RefreshCw } from 'lucide-react';

export const LiveMonitoring = () => {
    useEffect(() => {
        const wsUrl = (import.meta as any).env?.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app';
        wsService.connect(wsUrl);
    }, []);

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] gap-4">
            {/* Top Controls */}
            <div className="flex items-center justify-between pb-2 border-b border-navy-800">
                <div className="flex gap-4 items-center">
                    <h2 className="text-lg font-bold text-white">Zone A: Main Concourse</h2>
                    <div className="flex gap-1">
                        <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span className="text-xs text-green-400 font-mono">LIVE FEED</span>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="icon" variant="ghost"><RefreshCw className="w-4 h-4" /></Button>
                    <Button size="icon" variant="secondary"><Pause className="w-4 h-4" /></Button>
                </div>
            </div>

            {/* Main Content Area */}
            <div className="flex flex-1 gap-4 overflow-hidden">
                {/* Left: Layers */}
                <div className="flex-shrink-0">
                    <LayerControls />
                </div>

                {/* Center: 3D View */}
                <div className="flex-1 bg-black rounded-2xl border border-navy-800 relative overflow-hidden group">
                    <MeshView3D />

                    {/* Camera Strip Overlay */}
                    <div className="translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                        <CameraStrip />
                    </div>
                </div>

                {/* Right: Alerts */}
                <div className="flex-shrink-0">
                    <LiveAlerts />
                </div>
            </div>
        </div>
    );
};


```

#### frontend\src\views\LiveMonitoring\MeshView3D.tsx
```typescript
import { useEffect, useState, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text, Html } from '@react-three/drei';
import * as THREE from 'three';
import { wsService } from '../../services/websocket';

interface Entity {
    id: string;
    type: string;
    position: { x: number; y: number; z: number };
    velocity: { x: number; y: number; z: number };
    radius?: number;
    color?: number[];
    severity?: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
}

const EntityMesh = ({ entity }: { entity: Entity }) => {
    // Convert array color or hex to THREE.Color
    const color = useMemo(() => {
        if (Array.isArray(entity.color)) {
            return new THREE.Color(entity.color[0] / 255, entity.color[1] / 255, entity.color[2] / 255);
        }
        return new THREE.Color(entity.color || 'white');
    }, [entity.color]);

    const VelocityArrow = ({ velocity }: { velocity: { x: number; y: number; z: number } }) => {
        const length = Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);
        if (length < 0.1) return null;
        // Normalize direction
        const dir = new THREE.Vector3(velocity.x, velocity.y, velocity.z).normalize();
        return (
            <arrowHelper args={[dir, new THREE.Vector3(0, 0, 0), Math.min(length, 2), 0xffff00]} />
        );
    };

    const RiskHalo = ({ severity }: { severity?: string }) => {
        if (!severity || severity === 'LOW') return null;
        const color = severity === 'CRITICAL' ? 'red' : severity === 'HIGH' ? 'orange' : 'yellow';
        return (
            <mesh position={[0, -0.9, 0]} rotation={[0, 0, 0]}>
                <ringGeometry args={[0.5, 0.7, 32]} />
                <meshBasicMaterial color={color} transparent opacity={0.5} side={THREE.DoubleSide} />
            </mesh>
        );
    };

    return (
        <group position={[entity.position.x, entity.position.y, entity.position.z]}>
            {/* Entity Body */}
            <mesh castShadow receiveShadow>
                <capsuleGeometry args={[entity.radius || 0.3, 1.8, 4, 8]} />
                <meshStandardMaterial color={color} roughness={0.3} metalness={0.1} />
            </mesh>

            <RiskHalo severity={entity.severity} />
            <VelocityArrow velocity={entity.velocity} />

            {/* ID Tag */}
            <Html position={[0, 2.2, 0]} center distanceFactor={15}>
                <div className={`text-[10px] px-1.5 py-0.5 rounded backdrop-blur-md whitespace-nowrap border font-mono
                    ${entity.severity === 'CRITICAL' ? 'bg-red-500/20 border-red-500 text-red-200' :
                        entity.severity === 'HIGH' ? 'bg-orange-500/20 border-orange-500 text-orange-200' :
                            'bg-slate-900/60 border-slate-700 text-slate-300'}`}>
                    {entity.id}
                </div>
            </Html>
        </group>
    );
};

const Floor = () => {
    return (
        <mesh receiveShadow rotation={[0, 0, 0]} position={[0, 0, -0.01]}>
            <planeGeometry args={[100, 100]} />
            <meshStandardMaterial color="#0f172a" roughness={0.8} metalness={0.2} />
            <gridHelper args={[100, 50, 0x334155, 0x1e293b]} rotation={[Math.PI / 2, 0, 0]} />
        </mesh>
    );
};

export const MeshView3D = () => {
    const [entities, setEntities] = useState<Entity[]>([]);
    const [stats, setStats] = useState({ fps: 0, frame: 0, time: 0 });

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');
        const unsubscribe = wsService.on('entity:tracking', (data: { entities: Entity[], stats?: any }) => {
            if (data && data.entities) setEntities(data.entities);
            if (data && data.stats) setStats(data.stats);
        });
        return () => { }; // Connection managed globally or by context in real app
    }, []);

    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden border border-slate-800 relative shadow-inner">
            <div className="absolute top-4 left-4 z-10 space-y-2">
                <div className="bg-slate-900/90 p-3 rounded-lg border border-slate-800 text-xs text-slate-300 backdrop-blur shadow-lg space-y-2">
                    <div className="font-bold text-slate-100 mb-1 border-b border-slate-700 pb-1">Live Telemetry</div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Entities</span>
                        <span className="font-mono text-white text-right">{entities.length}</span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sim FPS</span>
                        <span className={`font-mono text-right ${stats.fps < 25 ? 'text-yellow-400' : 'text-green-400'}`}>
                            {stats.fps.toFixed(1)}
                        </span>
                    </div>

                    <div className="flex items-center justify-between gap-4">
                        <span>Sync</span>
                        <div className="flex items-center gap-1.5 justify-end">
                            <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" />
                            <span className="font-mono text-white">ACTIVE</span>
                        </div>
                    </div>
                </div>
            </div>

            <Canvas shadows camera={{ position: [0, -30, 20], fov: 50, up: [0, 0, 1] }}>
                <color attach="background" args={['#020617']} />
                <fog attach="fog" args={['#020617', 20, 90]} />

                <ambientLight intensity={0.4} />
                <directionalLight
                    position={[10, -20, 20]}
                    intensity={1.2}
                    castShadow
                    shadow-mapSize={[1024, 1024]}
                />
                <pointLight position={[-10, 10, 5]} intensity={0.5} color="#3b82f6" />

                <OrbitControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2.1} />

                <Floor />
                <axesHelper args={[2]} position={[0, 0, 0.1]} />

                {entities.map(e => (
                    <EntityMesh key={e.id} entity={e} />
                ))}
            </Canvas>
        </div>
    );
};

```

#### frontend\src\views\LiveMonitoring\components\CameraStrip.tsx
```typescript
export function CameraStrip() {
    return (
        <div className="absolute bottom-4 left-4 right-4 flex gap-4 overflow-x-auto pb-2 scrollbar-hide">
            {[1, 2, 3, 4, 5].map(cam => (
                <div key={cam} className="w-40 h-24 bg-black rounded-lg border border-navy-700 relative flex-shrink-0 group cursor-pointer hover:border-indigo-500 transition-colors">
                    <div className="absolute top-1 left-1 bg-black/50 px-1 rounded text-[10px] text-slate-300">CAM-0{cam}</div>
                    <div className="w-full h-full flex items-center justify-center text-slate-700 text-xs">NO SIGNAL</div>
                    <div className="absolute top-1 right-1 h-2 w-2 bg-green-500 rounded-full shadow-[0_0_5px_rgba(34,197,94,0.5)]"></div>
                </div>
            ))}
        </div>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LayerControls.tsx
```typescript
import { Layers, Eye, Activity, Map, Users, Zap } from 'lucide-react';
import { Card } from '../../../components/ui/Card';

const LAYERS = [
    { id: 'entities', label: 'Entities', icon: Users, default: true },
    { id: 'risk', label: 'Risk Halos', icon: Zap, default: true },
    { id: 'velocity', label: 'Velocity Vectors', icon: Activity, default: false },
    { id: 'trails', label: 'Path Trails', icon: Map, default: false },
    { id: 'social', label: 'Social Radar', icon: Users, default: false },
    { id: 'terrain', label: 'Behavior Terrain', icon: Layers, default: true },
];

export function LayerControls() {
    return (
        <Card className="w-64 bg-navy-900 border-navy-800 flex flex-col gap-4 h-full">
            <div className="flex items-center gap-2 mb-2 pb-2 border-b border-navy-800">
                <Layers className="w-4 h-4 text-indigo-400" />
                <h3 className="font-bold text-white text-sm">View Layers</h3>
            </div>

            <div className="space-y-3">
                {LAYERS.map(layer => (
                    <label key={layer.id} className="flex items-center justify-between group cursor-pointer">
                        <div className="flex items-center gap-3 text-slate-300 group-hover:text-white transition-colors">
                            <layer.icon className="w-4 h-4 text-slate-500 group-hover:text-indigo-400" />
                            <span className="text-sm font-medium">{layer.label}</span>
                        </div>
                        <div className="relative inline-block w-8 h-4 rounded-full cursor-pointer">
                            <input type="checkbox" className="sr-only peer" defaultChecked={layer.default} />
                            <div className="w-8 h-4 bg-navy-800 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:bg-indigo-600"></div>
                        </div>
                    </label>
                ))}
            </div>

            <div className="mt-auto pt-4 border-t border-navy-800">
                <div className="text-xs text-slate-500 mb-2 uppercase font-bold">Camera Overlay</div>
                <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <Eye className="w-4 h-4" /> Show FOV Cones
                    <input type="checkbox" className="ml-auto accent-indigo-500" defaultChecked />
                </label>
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\LiveAlerts.tsx
```typescript
import { AlertTriangle, Clock } from 'lucide-react';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const ALERTS = [
    { id: 1, type: 'Crowd Crush', risk: 92, time: '10s ago', zone: 'Gate B' },
    { id: 2, type: 'Fight Precursor', risk: 78, time: '32s ago', zone: 'Concourse' },
    { id: 3, type: 'Fallen Object', risk: 45, time: '1m ago', zone: 'Aisle 12' },
];

export function LiveAlerts() {
    return (
        <Card className="w-80 bg-navy-900 border-navy-800 flex flex-col h-full">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-navy-800">
                <div className="flex items-center gap-2">
                    <AlertTriangle className="w-4 h-4 text-status-critical" />
                    <h3 className="font-bold text-white text-sm">Live Alerts</h3>
                </div>
                <Badge variant="critical">3 Active</Badge>
            </div>

            <div className="flex-1 overflow-y-auto space-y-3">
                {ALERTS.map(alert => (
                    <div key={alert.id} className="bg-navy-800 p-3 rounded-lg border border-navy-700 hover:border-red-500/50 transition-colors cursor-pointer group">
                        <div className="flex justify-between items-start mb-1">
                            <span className="text-xs font-bold text-red-300">{alert.type}</span>
                            <span className="text-[10px] text-slate-500 flex items-center gap-1">
                                <Clock className="w-3 h-3" /> {alert.time}
                            </span>
                        </div>
                        <div className="flex justify-between items-end">
                            <div className="text-xs text-slate-400">{alert.zone}</div>
                            <div className="text-sm font-mono font-bold text-white">
                                {alert.risk}% <span className="text-xs font-sans font-normal text-slate-500">Risk</span>
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
}

```

#### frontend\src\views\LiveMonitoring\components\VideoPlaceholder.tsx
```typescript
import { useEffect, useRef, useState } from 'react';
import { api } from '../../../services/api';

export function VideoPlaceholder({ label, nodeId }: { label: string, nodeId?: string }) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [useStream, setUseStream] = useState(!!nodeId);
    const [imgError, setImgError] = useState(false);

    // Construct stream URL
    // We need to access the baseURL from axios instance or env
    const baseURL = api.defaults.baseURL || import.meta.env.VITE_API_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app/api';
    const token = localStorage.getItem('auth_token');
    const streamUrl = nodeId ? `${baseURL}/nodes/${nodeId}/stream?token=${token}` : '';

    useEffect(() => {
        if (useStream && !imgError && nodeId) return; // If using stream, don't run canvas animation

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId: number;
        let time = 0;

        const draw = () => {
            time += 0.05;
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a'; // bg-slate-900
            ctx.fillRect(0, 0, width, height);

            // Digital Noise / Scanlines
            for (let i = 0; i < height; i += 4) {
                ctx.fillStyle = `rgba(30, 41, 59, ${Math.random() * 0.5})`;
                ctx.fillRect(0, i, width, 1);
            }

            // Moving "Entities" (Simple Blobs)
            const x = (Math.sin(time) * 0.4 + 0.5) * width;
            const y = (Math.cos(time * 0.7) * 0.4 + 0.5) * height;

            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(79, 70, 229, 0.4)'; // Indigo
            ctx.fill();

            // Overlay Text
            ctx.font = '12px monospace';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('REC', width - 40, 20);
            ctx.fillText(new Date().toLocaleTimeString(), 10, height - 10);
            ctx.fillText(label, 10, 20);

            if (imgError) {
                ctx.fillStyle = '#ef4444';
                ctx.fillText('SIGNAL LOST', width / 2 - 30, height / 2);
            }

            // Recording Dot
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(width - 50, 15, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }

            animationFrameId = window.requestAnimationFrame(draw);
        };

        const resize = () => {
            if (canvas?.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        };

        window.addEventListener('resize', resize);
        resize(); // Initial resize
        draw();

        return () => {
            window.removeEventListener('resize', resize);
            window.cancelAnimationFrame(animationFrameId);
        };
    }, [label, useStream, imgError, nodeId]);

    if (useStream && !imgError && nodeId) {
        return (
            <div className="relative w-full h-full bg-black">
                <img
                    src={streamUrl}
                    alt={label}
                    className="w-full h-full object-cover"
                    onError={() => setImgError(true)}
                />
                {/* Overlay Text for Stream too */}
                <div className="absolute top-0 left-0 p-2 text-xs font-mono text-green-500 w-full flex justify-between">
                    <span>{label}</span>
                    <span>LIVE</span>
                </div>
            </div>
        );
    }

    return (
        <canvas ref={canvasRef} className="w-full h-full block" />
    );
}

```

#### frontend\src\views\SessionReplay\SessionReplay.tsx
```typescript
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button } from '../../components/ui/Button';
import { Card } from '../../components/ui/Card';
import { Play, Pause, SkipBack, SkipForward, ArrowLeft } from 'lucide-react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';

interface SessionData {
    id: string;
    name: string;
    sport: string;
    startTime: string;
    duration: number;
    status: string;
}

export const SessionReplay = () => {
    const { id } = useParams();
    const navigate = useNavigate();
    const [session, setSession] = useState<SessionData | null>(null);
    const [currentTime, setCurrentTime] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const playbackRef = useRef<number>();

    // Mock fetch session details
    useEffect(() => {
        // In real app: fetch(`/api/sessions/${id}`)
        setSession({
            id: id || '1',
            name: 'Championship Final Game 3',
            sport: 'BASKETBALL',
            startTime: new Date().toISOString(),
            duration: 1200, // 20 mins
            status: 'COMPLETED'
        });
    }, [id]);

    // Playback loop
    useEffect(() => {
        if (isPlaying) {
            playbackRef.current = window.setInterval(() => {
                setCurrentTime(prev => {
                    if (prev >= (session?.duration || 0)) {
                        setIsPlaying(false);
                        return prev;
                    }
                    return prev + 1;
                });
            }, 1000); // 1x Speed
        } else {
            clearInterval(playbackRef.current);
        }
        return () => clearInterval(playbackRef.current);
    }, [isPlaying, session]);

    const formatTime = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    return (
        <div className="flex flex-col h-full gap-4 p-4 text-white">
            {/* Header */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="sm" onClick={() => navigate('/sessions')}>
                    <ArrowLeft className="w-4 h-4 mr-2" /> Back
                </Button>
                <div>
                    <h1 className="text-xl font-bold">{session?.name || 'Loading...'}</h1>
                    <div className="text-sm text-slate-400">
                        {session?.sport} • {new Date(session?.startTime || '').toLocaleDateString()}
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 flex gap-4 min-h-0">
                {/* 3D Replay Viewport */}
                <div className="flex-1 bg-slate-950 rounded-xl overflow-hidden relative border border-slate-800">
                    <div className="absolute top-4 left-4 z-10 bg-black/50 px-2 py-1 rounded text-xs">
                        REPLAY MODE
                    </div>
                    <Canvas camera={{ position: [0, -40, 30] }}>
                        <ambientLight intensity={0.5} />
                        <gridHelper args={[100, 100, 0x334155, 0x0f172a]} rotation={[Math.PI / 2, 0, 0]} />
                        <OrbitControls />
                        {/* Placeholder for entities at currentTime */}
                        <mesh position={[Math.sin(currentTime * 0.1) * 5, Math.cos(currentTime * 0.1) * 5, 1]}>
                            <sphereGeometry args={[0.5]} />
                            <meshStandardMaterial color="orange" />
                        </mesh>
                    </Canvas>
                </div>

                {/* Sidebar Stats */}
                <div className="w-80 flex flex-col gap-4">
                    <Card className="flex-1">
                        <div className="p-4">
                            <h3 className="font-semibold mb-4">Events Log</h3>
                            <div className="space-y-2 text-sm text-slate-400">
                                <div className="flex justify-between">
                                    <span>Sync Start</span>
                                    <span>0:00</span>
                                </div>
                                <div className="flex justify-between text-yellow-400">
                                    <span>Anomaly Detected</span>
                                    <span>0:45</span>
                                </div>
                                <div className="flex justify-between text-red-400">
                                    <span>Speed Violation</span>
                                    <span>1:20</span>
                                </div>
                            </div>
                        </div>
                    </Card>
                </div>
            </div>

            {/* Controls Bar */}
            <Card className="p-4 bg-slate-900 border-t border-slate-800">
                <div className="flex flex-col gap-2">
                    {/* Scrubber */}
                    <div className="flex items-center gap-4 text-xs text-slate-400">
                        <span className="w-12 text-right">{formatTime(currentTime)}</span>
                        <input
                            type="range"
                            min="0"
                            max={session?.duration || 100}
                            value={currentTime}
                            onChange={(e) => setCurrentTime(Number(e.target.value))}
                            className="flex-1 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="w-12">{formatTime(session?.duration || 0)}</span>
                    </div>

                    {/* Buttons */}
                    <div className="flex items-center justify-center gap-4">
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.max(0, currentTime - 10))}>
                            <SkipBack className="w-5 h-5" />
                        </Button>
                        <Button
                            variant="primary"
                            size="icon"
                            className="w-12 h-12 rounded-full"
                            onClick={() => setIsPlaying(!isPlaying)}
                        >
                            {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6 ml-1" />}
                        </Button>
                        <Button variant="ghost" size="icon" onClick={() => setCurrentTime(Math.min(session?.duration || 0, currentTime + 10))}>
                            <SkipForward className="w-5 h-5" />
                        </Button>
                    </div>
                </div>
            </Card>
        </div>
    );
};

```

#### frontend\src\views\Sessions\SessionsList.tsx
```typescript
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { Button } from '../../components/ui/Button';
import { Play, Loader2 } from 'lucide-react';
import { api } from '../../services/api';

interface Session {
    id: string;
    sessionId: string;
    startTime: number;
    endTime?: number;
    sport: string;
    anomalies: any[]; // Expecting count or array
}

export const SessionsList = () => {
    const navigate = useNavigate();
    const [sessions, setSessions] = useState<Session[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchSessions = async () => {
            try {
                const data = await api.get('/sessions');
                if (Array.isArray(data)) {
                    // Map or sort data if necessary (latest first)
                    const sorted = data.sort((a: any, b: any) => b.startTime - a.startTime);
                    setSessions(sorted);
                }
            } catch (error) {
                console.error('Failed to fetch sessions:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchSessions();
    }, []);

    const formatDuration = (start: number, end?: number) => {
        if (!end) return 'Live';
        const diff = end - start;
        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        return `${minutes}m ${seconds}s`;
    };

    const formatDate = (ts: number) => new Date(ts).toLocaleDateString() + ' ' + new Date(ts).toLocaleTimeString();

    return (
        <div className="p-6 text-white h-full">
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Recorded Sessions</h1>
                <Button variant="primary" onClick={() => window.location.reload()}>Refresh</Button>
            </div>

            <Card className="overflow-hidden">
                {loading ? (
                    <div className="p-12 flex justify-center text-slate-500">
                        <Loader2 className="animate-spin w-8 h-8" />
                    </div>
                ) : (
                    <table className="w-full text-left text-sm">
                        <thead className="bg-slate-900 uppercase text-slate-400 font-semibold">
                            <tr>
                                <th className="p-4">Session ID</th>
                                <th className="p-4">Sport</th>
                                <th className="p-4">Date</th>
                                <th className="p-4">Duration</th>
                                <th className="p-4">Anomalies</th>
                                <th className="p-4">Status</th>
                                <th className="p-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-800">
                            {sessions.length === 0 && (
                                <tr>
                                    <td colSpan={7} className="p-8 text-center text-slate-500">No sessions found.</td>
                                </tr>
                            )}
                            {sessions.map((session) => (
                                <tr key={session.id || session.sessionId} className="hover:bg-slate-800/50 transition-colors">
                                    <td className="p-4 font-mono text-slate-300">{session.sessionId}</td>
                                    <td className="p-4 font-medium">{session.sport}</td>
                                    <td className="p-4 text-slate-400">{formatDate(session.startTime)}</td>
                                    <td className="p-4 text-slate-400">{formatDuration(session.startTime, session.endTime)}</td>
                                    <td className="p-4">
                                        <Badge variant={session.anomalies?.length > 0 ? 'critical' : 'success'}>
                                            {session.anomalies?.length || 0} Detected
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Badge variant={session.endTime ? 'outline' : 'warning'}>
                                            {session.endTime ? 'COMPLETED' : 'LIVE'}
                                        </Badge>
                                    </td>
                                    <td className="p-4">
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            onClick={() => navigate(`/sessions/${session.sessionId}`)}
                                        >
                                            <Play className="w-4 h-4 mr-2" /> Replay
                                        </Button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </Card>
        </div>
    );
};

```

#### frontend\src\views\SystemConfig\SystemConfig.tsx
```typescript
import { useState } from 'react';
import { Network, Activity, Crosshair } from 'lucide-react';
import { Button } from '../../components/ui/Button';
import { NodeTopology } from './components/NodeTopology';
import { SensorHealth } from './components/SensorHealth';
import { CalibrationWizard } from './components/CalibrationWizard';

type Tab = 'topology' | 'health' | 'calibration';

const SystemConfig = () => {
    const [activeTab, setActiveTab] = useState<Tab>('topology');

    return (
        <div className="space-y-6">
            {/* Top Bar Actions */}
            <div className="flex justify-between items-center bg-navy-800/50 p-4 rounded-xl border border-navy-800 backdrop-blur-sm">
                <div className="flex gap-2">
                    <Button
                        variant={activeTab === 'topology' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('topology')}
                        className="gap-2"
                    >
                        <Network className="w-4 h-4" /> Node Topology
                    </Button>
                    <Button
                        variant={activeTab === 'health' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('health')}
                        className="gap-2"
                    >
                        <Activity className="w-4 h-4" /> Sensor Health
                    </Button>
                    <Button
                        variant={activeTab === 'calibration' ? 'primary' : 'ghost'}
                        onClick={() => setActiveTab('calibration')}
                        className="gap-2"
                    >
                        <Crosshair className="w-4 h-4" /> Calibration
                    </Button>
                </div>
                <div className="flex gap-2">
                    <Button variant="secondary" size="sm">Export Config</Button>
                    <Button variant="primary" size="sm">Save Changes</Button>
                </div>
            </div>

            {/* Tab Content */}
            <div className="min-h-[600px]">
                {activeTab === 'topology' && <NodeTopology />}
                {activeTab === 'health' && <SensorHealth />}
                {activeTab === 'calibration' && <CalibrationWizard />}
            </div>
        </div>
    );
};

export default SystemConfig;

```

#### frontend\src\views\SystemConfig\components\CalibrationWizard.tsx
```typescript
import { useState, useEffect } from 'react';
import { Button } from '../../../components/ui/Button';
import { Camera, CheckCircle, RefreshCw, AlertTriangle } from 'lucide-react';
import { Api } from '../../../services/api';

type Step = 'SELECT' | 'CAPTURE' | 'VERIFY' | 'COMPLETE';

export function CalibrationWizard() {
    const [step, setStep] = useState<Step>('SELECT');
    const [progress, setProgress] = useState(0);
    const [selectedNode, setSelectedNode] = useState<string | null>(null);
    const [nodes, setNodes] = useState<any[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    // Fetch nodes
    useEffect(() => {
        const fetchNodes = async () => {
            try {
                const data = await Api.getNodes();
                setNodes(data.nodes);
            } catch (err) {
                console.error('Failed to fetch nodes for calibration', err);
            }
        };
        fetchNodes();
    }, []);

    const handleStart = async () => {
        if (!selectedNode) return;
        setStep('CAPTURE');
        setProgress(10);
        setError(null);

        try {
            // Start calibration on backend
            const result = await Api.calibrateNode(selectedNode);

            // Progress animation simulation while waiting or based on real status 
            // but for now we just show it finish
            setProgress(50);
            setTimeout(() => {
                setProgress(100);
                setStep('VERIFY');
            }, 1500);

        } catch (err: any) {
            setError(err.message || 'Calibration failed');
            setStep('SELECT');
        }
    };

    const reset = () => {
        setStep('SELECT');
        setProgress(0);
        setSelectedNode(null);
        setError(null);
    };

    return (
        <div className="h-[500px] bg-navy-900 border border-navy-800 rounded-xl p-6 flex flex-col">
            <div className="mb-6">
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-3 mb-4 flex items-center gap-3">
                    <AlertTriangle className="w-5 h-5 text-blue-400" />
                    <div className="text-sm text-blue-200">
                        <strong>Simulation Mode:</strong> This wizard demonstrates the calibration workflow. No physical cameras detected.
                    </div>
                </div>
                <h3 className="text-xl font-bold text-white mb-2">Sensor Calibration</h3>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <span className={step === 'SELECT' ? 'text-indigo-400 font-bold' : ''}>1. Select Node</span>
                    <span>→</span>
                    <span className={step === 'CAPTURE' ? 'text-indigo-400 font-bold' : ''}>2. Capture</span>
                    <span>→</span>
                    <span className={step === 'VERIFY' ? 'text-indigo-400 font-bold' : ''}>3. Verify</span>
                </div>
            </div>

            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-navy-700 rounded-xl bg-navy-800/30 p-8">
                {step === 'SELECT' && (
                    <div className="text-center space-y-4 w-full">
                        <div className="bg-navy-700 p-4 rounded-full inline-block">
                            <Camera className="w-8 h-8 text-indigo-400" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Select a Node to Calibrate</h4>
                        {error && <div className="text-red-500 text-xs">{error}</div>}
                        <div className="grid grid-cols-2 gap-3 w-full max-w-md mx-auto">
                            {nodes.length > 0 ? nodes.map(node => (
                                <button
                                    key={node.nodeId}
                                    onClick={() => setSelectedNode(node.nodeId)}
                                    className={`p-3 rounded border text-sm truncate ${selectedNode === node.nodeId ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node.nodeId}
                                </button>
                            )) : (
                                <div className="col-span-2 text-slate-500 text-xs">No nodes found. Using demo nodes...</div>
                            )}

                            {/* DEMO FALLBACK if no real nodes */}
                            {nodes.length === 0 && ['CAM-01', 'CAM-02'].map(node => (
                                <button
                                    key={node}
                                    onClick={() => setSelectedNode(node)}
                                    className={`p-3 rounded border text-sm ${selectedNode === node ? 'border-indigo-500 bg-indigo-500/10 text-white' : 'border-navy-600 bg-navy-800 text-slate-300 hover:border-slate-500'}`}
                                >
                                    {node}
                                </button>
                            ))}
                        </div>
                        <Button
                            variant="primary"
                            disabled={!selectedNode}
                            onClick={handleStart}
                        >
                            Start Calibration
                        </Button>
                    </div>
                )}

                {step === 'CAPTURE' && (
                    <div className="text-center space-y-6 w-full max-w-md">
                        <RefreshCw className="w-12 h-12 text-indigo-400 animate-spin mx-auto" />
                        <div>
                            <h4 className="text-lg font-medium text-white mb-1">Calibrating {selectedNode}...</h4>
                            <p className="text-sm text-slate-400">Capturing extrinsic parameters and aligning with point cloud.</p>
                        </div>
                        <div className="w-full bg-navy-950 rounded-full h-2.5 overflow-hidden">
                            <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-100" style={{ width: `${progress}%` }}></div>
                        </div>
                        <p className="text-xs text-slate-500 font-mono">{progress}% Complete</p>
                    </div>
                )}

                {step === 'VERIFY' && (
                    <div className="text-center space-y-4">
                        <AlertTriangle className="w-12 h-12 text-amber-400 mx-auto" />
                        <h4 className="text-lg font-medium text-white">Verification Required</h4>
                        <p className="text-sm text-slate-400 max-w-xs mx-auto">
                            The calculated transform has a reprojection error of <span className="text-white font-mono">0.024m</span>. This is within acceptable limits.
                        </p>
                        <div className="flex gap-3 justify-center">
                            <Button variant="secondary" onClick={reset}>Discard</Button>
                            <Button variant="primary" onClick={() => setStep('COMPLETE')}>Apply Transform</Button>
                        </div>
                    </div>
                )}

                {step === 'COMPLETE' && (
                    <div className="text-center space-y-4">
                        <div className="bg-emerald-500/10 p-4 rounded-full inline-block">
                            <CheckCircle className="w-12 h-12 text-emerald-500" />
                        </div>
                        <h4 className="text-lg font-medium text-white">Calibration Successful</h4>
                        <p className="text-sm text-slate-400">Node {selectedNode} is now active and aligned.</p>
                        <Button variant="ghost" onClick={reset}>Calibrate Another Node</Button>
                    </div>
                )}
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\NodeTopology.tsx
```typescript
import { Plus } from 'lucide-react';
import { TopologyCanvas } from './TopologyCanvas';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Badge } from '../../../components/ui/Badge';

const NODES = [
    { id: 'NODE_001', name: 'Gate B Cam 1', status: 'online', type: 'Camera' },
    { id: 'NODE_002', name: 'Gate B LIDAR', status: 'offline', type: 'LIDAR' },
    { id: 'NODE_003', name: 'Field Cam Main', status: 'online', type: 'Camera' },
];

export function NodeTopology() {
    return (
        <div className="flex flex-col lg:flex-row gap-6 h-[700px]">
            {/* Left Panel: Node List */}
            <div className="w-full lg:w-[300px] flex flex-col gap-4">
                <Card className="flex-1 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-white">Nodes</h3>
                        <Button size="icon" variant="ghost"><Plus className="w-4 h-4" /></Button>
                    </div>

                    <div className="space-y-3 flex-1 overflow-y-auto">
                        {NODES.map(node => (
                            <div key={node.id} className="p-3 bg-navy-900 rounded-lg border border-navy-700 hover:border-indigo-500 cursor-pointer transition-colors">
                                <div className="flex justify-between items-start mb-1">
                                    <div className="font-mono text-xs text-slate-500">{node.id}</div>
                                    <Badge variant={node.status === 'online' ? 'success' : 'critical'} size="sm" className="h-2 w-2 p-0 rounded-full"> </Badge>
                                </div>
                                <div className="font-bold text-sm text-slate-200">{node.name}</div>
                                <div className="text-xs text-indigo-400 mt-1">{node.type}</div>
                            </div>
                        ))}
                    </div>

                    <Button variant="secondary" fullWidth className="mt-4">Add New Node</Button>
                </Card>
            </div>

            {/* Right Panel: 3D View */}
            <div className="flex-1 bg-navy-900 rounded-2xl border border-navy-800 overflow-hidden relative">
                <TopologyCanvas />
                <div className="absolute top-4 right-4 bg-navy-800/80 p-2 rounded text-xs text-slate-400">
                    <p>Left Click: Rotate</p>
                    <p>Right Click: Pan</p>
                    <p>Scroll: Zoom</p>
                </div>

                {/* Overlay Controls */}
                <div className="absolute top-4 right-4 bg-navy-800/80 backdrop-blur p-3 rounded-lg border border-navy-700 space-y-2">
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show Frustums
                    </label>
                    <label className="flex items-center gap-2 text-xs text-slate-300">
                        <input type="checkbox" checked readOnly className="rounded bg-navy-900 border-navy-600" /> Show LIDAR
                    </label>
                </div>
            </div>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\SensorHealth.tsx
```typescript
import { Badge } from '../../../components/ui/Badge';

export function SensorHealth() {
    return (
        <div className="bg-navy-800 rounded-xl border border-navy-700 overflow-hidden">
            <table className="w-full text-left text-sm">
                <thead className="bg-navy-900 text-slate-400 font-medium">
                    <tr>
                        <th className="p-4">Node ID</th>
                        <th className="p-4">Sensor</th>
                        <th className="p-4">Status</th>
                        <th className="p-4">FPS (Target)</th>
                        <th className="p-4">Latency</th>
                        <th className="p-4">Last Update</th>
                        <th className="p-4 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-navy-700">
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_001</td>
                        <td className="p-4">Camera</td>
                        <td className="p-4"><Badge variant="success">ONLINE</Badge></td>
                        <td className="p-4">30/30</td>
                        <td className="p-4 text-green-400">12ms</td>
                        <td className="p-4 text-slate-400">Just now</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                    <tr className="hover:bg-navy-700/50 transition-colors">
                        <td className="p-4 font-mono text-slate-300">NODE_002</td>
                        <td className="p-4">LIDAR</td>
                        <td className="p-4"><Badge variant="critical">OFFLINE</Badge></td>
                        <td className="p-4 text-red-400">0/10</td>
                        <td className="p-4 text-slate-500">--</td>
                        <td className="p-4 text-red-400">5m ago</td>
                        <td className="p-4 text-right">
                            <button className="text-indigo-400 hover:text-indigo-300">Restart</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    );
}

```

#### frontend\src\views\SystemConfig\components\TopologyCanvas.tsx
```typescript
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Grid, Center, Text } from '@react-three/drei';

const Node = ({ position, color, label }: { position: [number, number, number], color: string, label: string }) => {
    return (
        <group position={position}>
            {/* Node visual */}
            <mesh>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color={color} />
            </mesh>

            {/* Frustum Visual (Cone) */}
            <mesh position={[0, 0, 2]} rotation={[Math.PI / 2, 0, 0]}>
                <coneGeometry args={[1, 4, 32, 1, true]} />
                <meshStandardMaterial color={color} wireframe opacity={0.3} transparent />
            </mesh>

            {/* Label */}
            <Text position={[0, 1.2, 0]} fontSize={0.5} color="white" anchorX="center" anchorY="middle">
                {label}
            </Text>
        </group>
    );
};

export function TopologyCanvas() {
    return (
        <div className="w-full h-full bg-slate-950 rounded-lg overflow-hidden">
            <Canvas>
                <PerspectiveCamera makeDefault position={[10, 10, 10]} fov={50} />
                <OrbitControls makeDefault />

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} />

                <Grid infiniteGrid fadeDistance={50} sectionColor="#4f46e5" cellColor="#4f46e5" sectionSize={5} cellSize={1} />

                <Center>
                    <Node position={[0, 2, 0]} color="#10b981" label="Cam-01" />
                    <Node position={[-5, 2, 5]} color="#3b82f6" label="Lidar-01" />
                    <Node position={[5, 2, 5]} color="#3b82f6" label="Lidar-02" />
                </Center>
            </Canvas>
        </div>
    );
}

```

#### frontend\src\views\Triage\AnomalyTriage.tsx
```typescript
import { useEffect, useState } from 'react';
import { Card } from '../../components/ui/Card';
import { Badge } from '../../components/ui/Badge';
import { wsService } from '../../services/websocket';

interface TriageTask {
    id: string;
    title: string;
    time: string;
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

export const AnomalyTriage = () => {
    const [newIncidents, setNewIncidents] = useState<TriageTask[]>([]);

    // Mock existing state for other columns
    const [investigating] = useState<TriageTask[]>([
        { id: 'A-099', title: 'Crowd Density Warning', time: '09:30 AM', severity: 'MEDIUM' },
    ]);
    const [resolved] = useState<TriageTask[]>([
        { id: 'A-055', title: 'Sensor Dropout', time: 'Yesterday', severity: 'LOW' },
    ]);

    useEffect(() => {
        wsService.connect(import.meta.env.VITE_WS_URL || 'https://motiongrid-api-rrsyyeqnbq-uc.a.run.app');

        const unsubscribe = wsService.on('anomaly:detected', (data: any) => {
            const newTask: TriageTask = {
                id: data.anomalyId || 'unknown',
                title: data.headline || 'Unknown Anomaly',
                severity: data.severity || 'LOW',
                time: data.occurredAt ? new Date(data.occurredAt).toLocaleTimeString() : new Date().toLocaleTimeString()
            };
            setNewIncidents(prev => [newTask, ...prev]);
        });
        return () => { };
    }, []);

    return (
        <div className="p-6 h-full text-white overflow-hidden flex flex-col">
            <h1 className="text-2xl font-bold mb-6">Anomaly Triage (Live)</h1>

            <div className="flex-1 flex gap-6 min-h-0 overflow-x-auto">
                <Column title="New Incidents" color="border-red-500" items={newIncidents} />
                <Column title="Investigating" color="border-yellow-500" items={investigating} />
                <Column title="Resolved" color="border-green-500" items={resolved} />
            </div>
        </div>
    );
};

const Column = ({ title, color, items }: any) => (
    <div className="flex-1 flex flex-col gap-4 min-w-[300px]">
        <div className={`font-semibold pb-2 border-b-2 ${color} flex justify-between`}>
            {title}
            <span className="text-slate-500 text-sm">{items.length}</span>
        </div>
        <div className="flex-1 bg-slate-900/50 rounded-lg p-2 space-y-3 overflow-y-auto">
            {items.map((item: any) => (
                <Card key={item.id} className="p-3 cursor-move hover:bg-slate-800 transition-colors">
                    <div className="flex justify-between items-start mb-2">
                        <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                        <Badge variant={item.severity.toLowerCase()}>{item.severity}</Badge>
                    </div>
                    <div className="font-medium text-sm mb-2">{item.title}</div>
                    <div className="text-xs text-slate-400">{item.time}</div>
                </Card>
            ))}
        </div>
    </div>
);

```
